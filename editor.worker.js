/******/ (function(modules) { // webpackBootstrap
/******/ 	this["webpackChunk"] = function webpackChunkCallback(chunkIds, moreModules) {
/******/ 		for(var moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		while(chunkIds.length)
/******/ 			installedChunks[chunkIds.pop()] = 1;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "1" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		"main": 1
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/aurelia-dynamic-html/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/monaco-editor/esm/vs/editor/editor.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/monaco-editor/esm/vs/base/common/async.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/async.js ***!
  \****************************************************************/
/*! exports provided: isPromiseLike, toPromiseLike, asWinJsPromise, wireCancellationToken, Throttler, SimpleThrottler, Delayer, ThrottledDelayer, Barrier, ShallowCancelThenPromise, timeout, always, sequence, first, Limiter, Queue, ResourceQueue, setDisposableTimeout, TimeoutTimer, IntervalTimer, RunOnceScheduler, nfcall, ninvoke, ThrottledEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPromiseLike\", function() { return isPromiseLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toPromiseLike\", function() { return toPromiseLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asWinJsPromise\", function() { return asWinJsPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wireCancellationToken\", function() { return wireCancellationToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Throttler\", function() { return Throttler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleThrottler\", function() { return SimpleThrottler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Delayer\", function() { return Delayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThrottledDelayer\", function() { return ThrottledDelayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Barrier\", function() { return Barrier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShallowCancelThenPromise\", function() { return ShallowCancelThenPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timeout\", function() { return timeout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"always\", function() { return always; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sequence\", function() { return sequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"first\", function() { return first; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Limiter\", function() { return Limiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Queue\", function() { return Queue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResourceQueue\", function() { return ResourceQueue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDisposableTimeout\", function() { return setDisposableTimeout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeoutTimer\", function() { return TimeoutTimer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntervalTimer\", function() { return IntervalTimer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RunOnceScheduler\", function() { return RunOnceScheduler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nfcall\", function() { return nfcall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ninvoke\", function() { return ninvoke; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThrottledEmitter\", function() { return ThrottledEmitter; });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./winjs.base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\");\n/* harmony import */ var _cancellation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cancellation.js */ \"./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nfunction isPromiseLike(obj) {\n    return obj && typeof obj.then === 'function';\n}\nfunction toPromiseLike(arg) {\n    if (isPromiseLike(arg)) {\n        return arg;\n    }\n    else {\n        return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(arg);\n    }\n}\nfunction asWinJsPromise(callback) {\n    var source = new _cancellation_js__WEBPACK_IMPORTED_MODULE_2__[\"CancellationTokenSource\"]();\n    return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (resolve, reject, progress) {\n        var item = callback(source.token);\n        if (item instanceof _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"]) {\n            always(item, function () { return source.dispose(); });\n            item.then(resolve, reject, progress);\n        }\n        else if (isPromiseLike(item)) {\n            always(item, function () { return source.dispose(); });\n            item.then(resolve, reject);\n        }\n        else {\n            source.dispose();\n            resolve(item);\n        }\n    }, function () {\n        source.cancel();\n    });\n}\n/**\n * Hook a cancellation token to a WinJS Promise\n */\nfunction wireCancellationToken(token, promise, resolveAsUndefinedWhenCancelled) {\n    var subscription = token.onCancellationRequested(function () { return promise.cancel(); });\n    if (resolveAsUndefinedWhenCancelled) {\n        promise = promise.then(undefined, function (err) {\n            if (!_errors_js__WEBPACK_IMPORTED_MODULE_0__[\"isPromiseCanceledError\"](err)) {\n                return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].wrapError(err);\n            }\n            return undefined;\n        });\n    }\n    return always(promise, function () { return subscription.dispose(); });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nvar Throttler = /** @class */ (function () {\n    function Throttler() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    Throttler.prototype.queue = function (promiseFactory) {\n        var _this = this;\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                var onComplete_1 = function () {\n                    _this.queuedPromise = null;\n                    var result = _this.queue(_this.queuedPromiseFactory);\n                    _this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e, p) {\n                    _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);\n                }, function () {\n                    _this.activePromise.cancel();\n                });\n            }\n            return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e, p) {\n                _this.queuedPromise.then(c, e, p);\n            }, function () {\n                // no-op\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e, p) {\n            _this.activePromise.done(function (result) {\n                _this.activePromise = null;\n                c(result);\n            }, function (err) {\n                _this.activePromise = null;\n                e(err);\n            }, p);\n        }, function () {\n            _this.activePromise.cancel();\n        });\n    };\n    return Throttler;\n}());\n\n// TODO@Joao: can the previous throttler be replaced with this?\nvar SimpleThrottler = /** @class */ (function () {\n    function SimpleThrottler() {\n        this.current = _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].wrap(null);\n    }\n    SimpleThrottler.prototype.queue = function (promiseTask) {\n        return this.current = this.current.then(function () { return promiseTask(); });\n    };\n    return SimpleThrottler;\n}());\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so the he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nvar Delayer = /** @class */ (function () {\n    function Delayer(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = null;\n        this.completionPromise = null;\n        this.onSuccess = null;\n        this.task = null;\n    }\n    Delayer.prototype.trigger = function (task, delay) {\n        var _this = this;\n        if (delay === void 0) { delay = this.defaultDelay; }\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c) {\n                _this.onSuccess = c;\n            }, function () {\n                // no-op\n            }).then(function () {\n                _this.completionPromise = null;\n                _this.onSuccess = null;\n                var task = _this.task;\n                _this.task = null;\n                return task();\n            });\n        }\n        this.timeout = setTimeout(function () {\n            _this.timeout = null;\n            _this.onSuccess(null);\n        }, delay);\n        return this.completionPromise;\n    };\n    Delayer.prototype.isTriggered = function () {\n        return this.timeout !== null;\n    };\n    Delayer.prototype.cancel = function () {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            this.completionPromise.cancel();\n            this.completionPromise = null;\n        }\n    };\n    Delayer.prototype.cancelTimeout = function () {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    };\n    return Delayer;\n}());\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * Simply combine the two mail man strategies from the Throttler and Delayer\n * helpers, for an analogy.\n */\nvar ThrottledDelayer = /** @class */ (function (_super) {\n    __extends(ThrottledDelayer, _super);\n    function ThrottledDelayer(defaultDelay) {\n        var _this = _super.call(this, defaultDelay) || this;\n        _this.throttler = new Throttler();\n        return _this;\n    }\n    ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {\n        var _this = this;\n        return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);\n    };\n    return ThrottledDelayer;\n}(Delayer));\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nvar Barrier = /** @class */ (function () {\n    function Barrier() {\n        var _this = this;\n        this._isOpen = false;\n        this._promise = new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e, p) {\n            _this._completePromise = c;\n        }, function () {\n            console.warn('You should really not try to cancel this ready promise!');\n        });\n    }\n    Barrier.prototype.isOpen = function () {\n        return this._isOpen;\n    };\n    Barrier.prototype.open = function () {\n        this._isOpen = true;\n        this._completePromise(true);\n    };\n    Barrier.prototype.wait = function () {\n        return this._promise;\n    };\n    return Barrier;\n}());\n\nvar ShallowCancelThenPromise = /** @class */ (function (_super) {\n    __extends(ShallowCancelThenPromise, _super);\n    function ShallowCancelThenPromise(outer) {\n        var _this = this;\n        var completeCallback, errorCallback, progressCallback;\n        _this = _super.call(this, function (c, e, p) {\n            completeCallback = c;\n            errorCallback = e;\n            progressCallback = p;\n        }, function () {\n            // cancel this promise but not the\n            // outer promise\n            errorCallback(_errors_js__WEBPACK_IMPORTED_MODULE_0__[\"canceled\"]());\n        }) || this;\n        outer.then(completeCallback, errorCallback, progressCallback);\n        return _this;\n    }\n    return ShallowCancelThenPromise;\n}(_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"]));\n\n/**\n * Replacement for `WinJS.Promise.timeout`.\n */\nfunction timeout(n) {\n    return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"Promise\"](function (resolve) { return setTimeout(resolve, n); });\n}\nfunction isWinJSPromise(candidate) {\n    return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].is(candidate) && typeof candidate.done === 'function';\n}\nfunction always(winjsPromiseOrPromiseLike, f) {\n    if (isWinJSPromise(winjsPromiseOrPromiseLike)) {\n        return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e, p) {\n            winjsPromiseOrPromiseLike.done(function (result) {\n                try {\n                    f(result);\n                }\n                catch (e1) {\n                    _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"onUnexpectedError\"](e1);\n                }\n                c(result);\n            }, function (err) {\n                try {\n                    f(err);\n                }\n                catch (e1) {\n                    _errors_js__WEBPACK_IMPORTED_MODULE_0__[\"onUnexpectedError\"](e1);\n                }\n                e(err);\n            }, function (progress) {\n                p(progress);\n            });\n        }, function () {\n            winjsPromiseOrPromiseLike.cancel();\n        });\n    }\n    else {\n        // simple\n        winjsPromiseOrPromiseLike.then(function (_) { return f(); }, function (_) { return f(); });\n        return winjsPromiseOrPromiseLike;\n    }\n}\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\nfunction sequence(promiseFactories) {\n    var results = [];\n    // reverse since we start with last element using pop()\n    promiseFactories = promiseFactories.reverse();\n    function next() {\n        if (promiseFactories.length) {\n            return promiseFactories.pop()();\n        }\n        return null;\n    }\n    function thenHandler(result) {\n        if (result !== undefined && result !== null) {\n            results.push(result);\n        }\n        var n = next();\n        if (n) {\n            return n.then(thenHandler);\n        }\n        return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(results);\n    }\n    return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(null).then(thenHandler);\n}\nfunction first(promiseFactories, shouldStop) {\n    if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }\n    promiseFactories = promiseFactories.reverse().slice();\n    var loop = function () {\n        if (promiseFactories.length === 0) {\n            return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(null);\n        }\n        var factory = promiseFactories.pop();\n        var promise = factory();\n        return promise.then(function (result) {\n            if (shouldStop(result)) {\n                return _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nvar Limiter = /** @class */ (function () {\n    function Limiter(maxDegreeOfParalellism) {\n        this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n        this.outstandingPromises = [];\n        this.runningPromises = 0;\n        this._onFinished = new _event_js__WEBPACK_IMPORTED_MODULE_4__[\"Emitter\"]();\n    }\n    Object.defineProperty(Limiter.prototype, \"onFinished\", {\n        get: function () {\n            return this._onFinished.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Limiter.prototype, \"size\", {\n        get: function () {\n            return this.runningPromises + this.outstandingPromises.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Limiter.prototype.queue = function (promiseFactory) {\n        var _this = this;\n        return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e, p) {\n            _this.outstandingPromises.push({\n                factory: promiseFactory,\n                c: c,\n                e: e,\n                p: p\n            });\n            _this.consume();\n        });\n    };\n    Limiter.prototype.consume = function () {\n        var _this = this;\n        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n            var iLimitedTask = this.outstandingPromises.shift();\n            this.runningPromises++;\n            var promise = iLimitedTask.factory();\n            promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);\n            promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });\n        }\n    };\n    Limiter.prototype.consumed = function () {\n        this.runningPromises--;\n        if (this.outstandingPromises.length > 0) {\n            this.consume();\n        }\n        else {\n            this._onFinished.fire();\n        }\n    };\n    Limiter.prototype.dispose = function () {\n        this._onFinished.dispose();\n    };\n    return Limiter;\n}());\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nvar Queue = /** @class */ (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        return _super.call(this, 1) || this;\n    }\n    return Queue;\n}(Limiter));\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nvar ResourceQueue = /** @class */ (function () {\n    function ResourceQueue() {\n        this.queues = Object.create(null);\n    }\n    ResourceQueue.prototype.queueFor = function (resource) {\n        var _this = this;\n        var key = resource.toString();\n        if (!this.queues[key]) {\n            var queue_1 = new Queue();\n            queue_1.onFinished(function () {\n                queue_1.dispose();\n                delete _this.queues[key];\n            });\n            this.queues[key] = queue_1;\n        }\n        return this.queues[key];\n    };\n    return ResourceQueue;\n}());\n\nfunction setDisposableTimeout(handler, timeout) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    var handle = setTimeout.apply(void 0, [handler, timeout].concat(args));\n    return { dispose: function () { clearTimeout(handle); } };\n}\nvar TimeoutTimer = /** @class */ (function (_super) {\n    __extends(TimeoutTimer, _super);\n    function TimeoutTimer() {\n        var _this = _super.call(this) || this;\n        _this._token = -1;\n        return _this;\n    }\n    TimeoutTimer.prototype.dispose = function () {\n        this.cancel();\n        _super.prototype.dispose.call(this);\n    };\n    TimeoutTimer.prototype.cancel = function () {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    };\n    TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {\n        var _this = this;\n        this.cancel();\n        this._token = setTimeout(function () {\n            _this._token = -1;\n            runner();\n        }, timeout);\n    };\n    TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {\n        var _this = this;\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(function () {\n            _this._token = -1;\n            runner();\n        }, timeout);\n    };\n    return TimeoutTimer;\n}(_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__[\"Disposable\"]));\n\nvar IntervalTimer = /** @class */ (function (_super) {\n    __extends(IntervalTimer, _super);\n    function IntervalTimer() {\n        var _this = _super.call(this) || this;\n        _this._token = -1;\n        return _this;\n    }\n    IntervalTimer.prototype.dispose = function () {\n        this.cancel();\n        _super.prototype.dispose.call(this);\n    };\n    IntervalTimer.prototype.cancel = function () {\n        if (this._token !== -1) {\n            clearInterval(this._token);\n            this._token = -1;\n        }\n    };\n    IntervalTimer.prototype.cancelAndSet = function (runner, interval) {\n        this.cancel();\n        this._token = setInterval(function () {\n            runner();\n        }, interval);\n    };\n    return IntervalTimer;\n}(_lifecycle_js__WEBPACK_IMPORTED_MODULE_3__[\"Disposable\"]));\n\nvar RunOnceScheduler = /** @class */ (function () {\n    function RunOnceScheduler(runner, timeout) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = timeout;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    RunOnceScheduler.prototype.dispose = function () {\n        this.cancel();\n        this.runner = null;\n    };\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    RunOnceScheduler.prototype.cancel = function () {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    };\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    RunOnceScheduler.prototype.schedule = function (delay) {\n        if (delay === void 0) { delay = this.timeout; }\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    };\n    /**\n     * Returns true if scheduled.\n     */\n    RunOnceScheduler.prototype.isScheduled = function () {\n        return this.timeoutToken !== -1;\n    };\n    RunOnceScheduler.prototype.onTimeout = function () {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.runner();\n        }\n    };\n    return RunOnceScheduler;\n}());\n\nfunction nfcall(fn) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); }, function () { return null; });\n}\nfunction ninvoke(thisArg, fn) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); }, function () { return null; });\n}\n/**\n * An emitter that will ignore any events that occur during a specific code\n * execution triggered via throttle() until the promise has finished (either\n * successfully or with an error). Only after the promise has finished, the\n * last event that was fired during the operation will get emitted.\n *\n */\nvar ThrottledEmitter = /** @class */ (function (_super) {\n    __extends(ThrottledEmitter, _super);\n    function ThrottledEmitter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ThrottledEmitter.prototype.throttle = function (promise) {\n        var _this = this;\n        this.suspended = true;\n        return always(promise, function () { return _this.resume(); });\n    };\n    ThrottledEmitter.prototype.fire = function (event) {\n        if (this.suspended) {\n            this.lastEvent = event;\n            this.hasLastEvent = true;\n            return;\n        }\n        return _super.prototype.fire.call(this, event);\n    };\n    ThrottledEmitter.prototype.resume = function () {\n        this.suspended = false;\n        if (this.hasLastEvent) {\n            this.fire(this.lastEvent);\n        }\n        this.hasLastEvent = false;\n        this.lastEvent = void 0;\n    };\n    return ThrottledEmitter;\n}(_event_js__WEBPACK_IMPORTED_MODULE_4__[\"Emitter\"]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYXN5bmMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vYXN5bmMuanM/NWZlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IFByb21pc2UsIFRQcm9taXNlIH0gZnJvbSAnLi93aW5qcy5iYXNlLmpzJztcbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VMaWtlKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbWlzZUxpa2UoYXJnKSB7XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFRQcm9taXNlLmFzKGFyZyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFzV2luSnNQcm9taXNlKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgIHJldHVybiBuZXcgVFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFjayhzb3VyY2UudG9rZW4pO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRQcm9taXNlKSB7XG4gICAgICAgICAgICBhbHdheXMoaXRlbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICBpdGVtLnRoZW4ocmVzb2x2ZSwgcmVqZWN0LCBwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlTGlrZShpdGVtKSkge1xuICAgICAgICAgICAgYWx3YXlzKGl0ZW0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgaXRlbS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc291cmNlLmNhbmNlbCgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBIb29rIGEgY2FuY2VsbGF0aW9uIHRva2VuIHRvIGEgV2luSlMgUHJvbWlzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2lyZUNhbmNlbGxhdGlvblRva2VuKHRva2VuLCBwcm9taXNlLCByZXNvbHZlQXNVbmRlZmluZWRXaGVuQ2FuY2VsbGVkKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7IH0pO1xuICAgIGlmIChyZXNvbHZlQXNVbmRlZmluZWRXaGVuQ2FuY2VsbGVkKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIWVycm9ycy5pc1Byb21pc2VDYW5jZWxlZEVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFByb21pc2Uud3JhcEVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFsd2F5cyhwcm9taXNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpcHRpb24uZGlzcG9zZSgpOyB9KTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdG8gcHJldmVudCBhY2N1bXVsYXRpb24gb2Ygc2VxdWVudGlhbCBhc3luYyB0YXNrcy5cbiAqXG4gKiBJbWFnaW5lIGEgbWFpbCBtYW4gd2l0aCB0aGUgc29sZSB0YXNrIG9mIGRlbGl2ZXJpbmcgbGV0dGVycy4gQXMgc29vbiBhc1xuICogYSBsZXR0ZXIgc3VibWl0dGVkIGZvciBkZWxpdmVyeSwgaGUgZHJpdmVzIHRvIHRoZSBkZXN0aW5hdGlvbiwgZGVsaXZlcnMgaXRcbiAqIGFuZCByZXR1cm5zIHRvIGhpcyBiYXNlLiBJbWFnaW5lIHRoYXQgZHVyaW5nIHRoZSB0cmlwLCBOIG1vcmUgbGV0dGVycyB3ZXJlIHN1Ym1pdHRlZC5cbiAqIFdoZW4gdGhlIG1haWwgbWFuIHJldHVybnMsIGhlIHBpY2tzIHRob3NlIE4gbGV0dGVycyBhbmQgZGVsaXZlcnMgdGhlbSBhbGwgaW4gYVxuICogc2luZ2xlIHRyaXAuIEV2ZW4gdGhvdWdoIE4rMSBzdWJtaXNzaW9ucyBvY2N1cnJlZCwgb25seSAyIGRlbGl2ZXJpZXMgd2VyZSBtYWRlLlxuICpcbiAqIFRoZSB0aHJvdHRsZXIgaW1wbGVtZW50cyB0aGlzIHZpYSB0aGUgcXVldWUoKSBtZXRob2QsIGJ5IHByb3ZpZGluZyBpdCBhIHRhc2tcbiAqIGZhY3RvcnkuIEZvbGxvd2luZyB0aGUgZXhhbXBsZTpcbiAqXG4gKiBcdFx0Y29uc3QgdGhyb3R0bGVyID0gbmV3IFRocm90dGxlcigpO1xuICogXHRcdGNvbnN0IGxldHRlcnMgPSBbXTtcbiAqXG4gKiBcdFx0ZnVuY3Rpb24gZGVsaXZlcigpIHtcbiAqIFx0XHRcdGNvbnN0IGxldHRlcnNUb0RlbGl2ZXIgPSBsZXR0ZXJzO1xuICogXHRcdFx0bGV0dGVycyA9IFtdO1xuICogXHRcdFx0cmV0dXJuIG1ha2VUaGVUcmlwKGxldHRlcnNUb0RlbGl2ZXIpO1xuICogXHRcdH1cbiAqXG4gKiBcdFx0ZnVuY3Rpb24gb25MZXR0ZXJSZWNlaXZlZChsKSB7XG4gKiBcdFx0XHRsZXR0ZXJzLnB1c2gobCk7XG4gKiBcdFx0XHR0aHJvdHRsZXIucXVldWUoZGVsaXZlcik7XG4gKiBcdFx0fVxuICovXG52YXIgVGhyb3R0bGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlcigpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWV1ZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWV1ZWRQcm9taXNlRmFjdG9yeSA9IG51bGw7XG4gICAgfVxuICAgIFRocm90dGxlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAocHJvbWlzZUZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRQcm9taXNlRmFjdG9yeSA9IHByb21pc2VGYWN0b3J5O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlZFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25Db21wbGV0ZV8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5xdWV1ZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnF1ZXVlKF90aGlzLnF1ZXVlZFByb21pc2VGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucXVldWVkUHJvbWlzZUZhY3RvcnkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZWRQcm9taXNlID0gbmV3IFRQcm9taXNlKGZ1bmN0aW9uIChjLCBlLCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVByb21pc2UudGhlbihvbkNvbXBsZXRlXzEsIG9uQ29tcGxldGVfMSwgcCkuZG9uZShjKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRQcm9taXNlKGZ1bmN0aW9uIChjLCBlLCBwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucXVldWVkUHJvbWlzZS50aGVuKGMsIGUsIHApO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVByb21pc2UgPSBwcm9taXNlRmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gbmV3IFRQcm9taXNlKGZ1bmN0aW9uIChjLCBlLCBwKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmVQcm9taXNlLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGMocmVzdWx0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlKGVycik7XG4gICAgICAgICAgICB9LCBwKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZlUHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVyO1xufSgpKTtcbmV4cG9ydCB7IFRocm90dGxlciB9O1xuLy8gVE9ET0BKb2FvOiBjYW4gdGhlIHByZXZpb3VzIHRocm90dGxlciBiZSByZXBsYWNlZCB3aXRoIHRoaXM/XG52YXIgU2ltcGxlVGhyb3R0bGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZVRocm90dGxlcigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gVFByb21pc2Uud3JhcChudWxsKTtcbiAgICB9XG4gICAgU2ltcGxlVGhyb3R0bGVyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uIChwcm9taXNlVGFzaykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvbWlzZVRhc2soKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlVGhyb3R0bGVyO1xufSgpKTtcbmV4cG9ydCB7IFNpbXBsZVRocm90dGxlciB9O1xuLyoqXG4gKiBBIGhlbHBlciB0byBkZWxheSBleGVjdXRpb24gb2YgYSB0YXNrIHRoYXQgaXMgYmVpbmcgcmVxdWVzdGVkIG9mdGVuLlxuICpcbiAqIEZvbGxvd2luZyB0aGUgdGhyb3R0bGVyLCBub3cgaW1hZ2luZSB0aGUgbWFpbCBtYW4gd2FudHMgdG8gb3B0aW1pemUgdGhlIG51bWJlciBvZlxuICogdHJpcHMgcHJvYWN0aXZlbHkuIFRoZSB0cmlwIGl0c2VsZiBjYW4gYmUgbG9uZywgc28gdGhlIGhlIGRlY2lkZXMgbm90IHRvIG1ha2UgdGhlIHRyaXBcbiAqIGFzIHNvb24gYXMgYSBsZXR0ZXIgaXMgc3VibWl0dGVkLiBJbnN0ZWFkIGhlIHdhaXRzIGEgd2hpbGUsIGluIGNhc2UgbW9yZVxuICogbGV0dGVycyBhcmUgc3VibWl0dGVkLiBBZnRlciBzYWlkIHdhaXRpbmcgcGVyaW9kLCBpZiBubyBsZXR0ZXJzIHdlcmUgc3VibWl0dGVkLCBoZVxuICogZGVjaWRlcyB0byBtYWtlIHRoZSB0cmlwLiBJbWFnaW5lIHRoYXQgTiBtb3JlIGxldHRlcnMgd2VyZSBzdWJtaXR0ZWQgYWZ0ZXIgdGhlIGZpcnN0XG4gKiBvbmUsIGFsbCB3aXRoaW4gYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVhY2ggb3RoZXIuIEV2ZW4gdGhvdWdoIE4rMVxuICogc3VibWlzc2lvbnMgb2NjdXJyZWQsIG9ubHkgMSBkZWxpdmVyeSB3YXMgbWFkZS5cbiAqXG4gKiBUaGUgZGVsYXllciBvZmZlcnMgdGhpcyBiZWhhdmlvciB2aWEgdGhlIHRyaWdnZXIoKSBtZXRob2QsIGludG8gd2hpY2ggYm90aCB0aGUgdGFza1xuICogdG8gYmUgZXhlY3V0ZWQgYW5kIHRoZSB3YWl0aW5nIHBlcmlvZCAoZGVsYXkpIG11c3QgYmUgcGFzc2VkIGluIGFzIGFyZ3VtZW50cy4gRm9sbG93aW5nXG4gKiB0aGUgZXhhbXBsZTpcbiAqXG4gKiBcdFx0Y29uc3QgZGVsYXllciA9IG5ldyBEZWxheWVyKFdBSVRJTkdfUEVSSU9EKTtcbiAqIFx0XHRjb25zdCBsZXR0ZXJzID0gW107XG4gKlxuICogXHRcdGZ1bmN0aW9uIGxldHRlclJlY2VpdmVkKGwpIHtcbiAqIFx0XHRcdGxldHRlcnMucHVzaChsKTtcbiAqIFx0XHRcdGRlbGF5ZXIudHJpZ2dlcigoKSA9PiB7IHJldHVybiBtYWtlVGhlVHJpcCgpOyB9KTtcbiAqIFx0XHR9XG4gKi9cbnZhciBEZWxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5ZXIoZGVmYXVsdERlbGF5KSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdERlbGF5ID0gZGVmYXVsdERlbGF5O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgICBEZWxheWVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHRhc2ssIGRlbGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gdGhpcy5kZWZhdWx0RGVsYXk7IH1cbiAgICAgICAgdGhpcy50YXNrID0gdGFzaztcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIGlmICghdGhpcy5jb21wbGV0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uUHJvbWlzZSA9IG5ldyBUUHJvbWlzZShmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uU3VjY2VzcyA9IGM7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0YXNrID0gX3RoaXMudGFzaztcbiAgICAgICAgICAgICAgICBfdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFzaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm9uU3VjY2VzcyhudWxsKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIERlbGF5ZXIucHJvdG90eXBlLmlzVHJpZ2dlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lb3V0ICE9PSBudWxsO1xuICAgIH07XG4gICAgRGVsYXllci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbFRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvblByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXllci5wcm90b3R5cGUuY2FuY2VsVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXllcjtcbn0oKSk7XG5leHBvcnQgeyBEZWxheWVyIH07XG4vKipcbiAqIEEgaGVscGVyIHRvIGRlbGF5IGV4ZWN1dGlvbiBvZiBhIHRhc2sgdGhhdCBpcyBiZWluZyByZXF1ZXN0ZWQgb2Z0ZW4sIHdoaWxlXG4gKiBwcmV2ZW50aW5nIGFjY3VtdWxhdGlvbiBvZiBjb25zZWN1dGl2ZSBleGVjdXRpb25zLCB3aGlsZSB0aGUgdGFzayBydW5zLlxuICpcbiAqIFNpbXBseSBjb21iaW5lIHRoZSB0d28gbWFpbCBtYW4gc3RyYXRlZ2llcyBmcm9tIHRoZSBUaHJvdHRsZXIgYW5kIERlbGF5ZXJcbiAqIGhlbHBlcnMsIGZvciBhbiBhbmFsb2d5LlxuICovXG52YXIgVGhyb3R0bGVkRGVsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVkRGVsYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZWREZWxheWVyKGRlZmF1bHREZWxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZWZhdWx0RGVsYXkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRocm90dGxlciA9IG5ldyBUaHJvdHRsZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaHJvdHRsZWREZWxheWVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHByb21pc2VGYWN0b3J5LCBkZWxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50cmlnZ2VyLmNhbGwodGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGhyb3R0bGVyLnF1ZXVlKHByb21pc2VGYWN0b3J5KTsgfSwgZGVsYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlZERlbGF5ZXI7XG59KERlbGF5ZXIpKTtcbmV4cG9ydCB7IFRocm90dGxlZERlbGF5ZXIgfTtcbi8qKlxuICogQSBiYXJyaWVyIHRoYXQgaXMgaW5pdGlhbGx5IGNsb3NlZCBhbmQgdGhlbiBiZWNvbWVzIG9wZW5lZCBwZXJtYW5lbnRseS5cbiAqL1xudmFyIEJhcnJpZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFycmllcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgVFByb21pc2UoZnVuY3Rpb24gKGMsIGUsIHApIHtcbiAgICAgICAgICAgIF90aGlzLl9jb21wbGV0ZVByb21pc2UgPSBjO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdSBzaG91bGQgcmVhbGx5IG5vdCB0cnkgdG8gY2FuY2VsIHRoaXMgcmVhZHkgcHJvbWlzZSEnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEJhcnJpZXIucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcbiAgICB9O1xuICAgIEJhcnJpZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlUHJvbWlzZSh0cnVlKTtcbiAgICB9O1xuICAgIEJhcnJpZXIucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIEJhcnJpZXI7XG59KCkpO1xuZXhwb3J0IHsgQmFycmllciB9O1xudmFyIFNoYWxsb3dDYW5jZWxUaGVuUHJvbWlzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2hhbGxvd0NhbmNlbFRoZW5Qcm9taXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNoYWxsb3dDYW5jZWxUaGVuUHJvbWlzZShvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tcGxldGVDYWxsYmFjaywgZXJyb3JDYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaztcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAoYywgZSwgcCkge1xuICAgICAgICAgICAgY29tcGxldGVDYWxsYmFjayA9IGM7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrID0gZTtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2sgPSBwO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjYW5jZWwgdGhpcyBwcm9taXNlIGJ1dCBub3QgdGhlXG4gICAgICAgICAgICAvLyBvdXRlciBwcm9taXNlXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9ycy5jYW5jZWxlZCgpKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgb3V0ZXIudGhlbihjb21wbGV0ZUNhbGxiYWNrLCBlcnJvckNhbGxiYWNrLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2hhbGxvd0NhbmNlbFRoZW5Qcm9taXNlO1xufShUUHJvbWlzZSkpO1xuZXhwb3J0IHsgU2hhbGxvd0NhbmNlbFRoZW5Qcm9taXNlIH07XG4vKipcbiAqIFJlcGxhY2VtZW50IGZvciBgV2luSlMuUHJvbWlzZS50aW1lb3V0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQobikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBuKTsgfSk7XG59XG5mdW5jdGlvbiBpc1dpbkpTUHJvbWlzZShjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gVFByb21pc2UuaXMoY2FuZGlkYXRlKSAmJiB0eXBlb2YgY2FuZGlkYXRlLmRvbmUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gYWx3YXlzKHdpbmpzUHJvbWlzZU9yUHJvbWlzZUxpa2UsIGYpIHtcbiAgICBpZiAoaXNXaW5KU1Byb21pc2Uod2luanNQcm9taXNlT3JQcm9taXNlTGlrZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUUHJvbWlzZShmdW5jdGlvbiAoYywgZSwgcCkge1xuICAgICAgICAgICAgd2luanNQcm9taXNlT3JQcm9taXNlTGlrZS5kb25lKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlMSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMub25VbmV4cGVjdGVkRXJyb3IoZTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjKHJlc3VsdCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLm9uVW5leHBlY3RlZEVycm9yKGUxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZShlcnIpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcChwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luanNQcm9taXNlT3JQcm9taXNlTGlrZS5jYW5jZWwoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzaW1wbGVcbiAgICAgICAgd2luanNQcm9taXNlT3JQcm9taXNlTGlrZS50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBmKCk7IH0sIGZ1bmN0aW9uIChfKSB7IHJldHVybiBmKCk7IH0pO1xuICAgICAgICByZXR1cm4gd2luanNQcm9taXNlT3JQcm9taXNlTGlrZTtcbiAgICB9XG59XG4vKipcbiAqIFJ1bnMgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgcHJvbWlzZSBmYWN0b3JpZXMgaW4gc2VxdWVudGlhbCBvcmRlci4gVGhlIHJldHVybmVkXG4gKiBwcm9taXNlIHdpbGwgY29tcGxldGUgdG8gYW4gYXJyYXkgb2YgcmVzdWx0cyBmcm9tIGVhY2ggcHJvbWlzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbmNlKHByb21pc2VGYWN0b3JpZXMpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIC8vIHJldmVyc2Ugc2luY2Ugd2Ugc3RhcnQgd2l0aCBsYXN0IGVsZW1lbnQgdXNpbmcgcG9wKClcbiAgICBwcm9taXNlRmFjdG9yaWVzID0gcHJvbWlzZUZhY3Rvcmllcy5yZXZlcnNlKCk7XG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHByb21pc2VGYWN0b3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUZhY3Rvcmllcy5wb3AoKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aGVuSGFuZGxlcihyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBuZXh0KCk7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gbi50aGVuKHRoZW5IYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVFByb21pc2UuYXMocmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiBUUHJvbWlzZS5hcyhudWxsKS50aGVuKHRoZW5IYW5kbGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChwcm9taXNlRmFjdG9yaWVzLCBzaG91bGRTdG9wKSB7XG4gICAgaWYgKHNob3VsZFN0b3AgPT09IHZvaWQgMCkgeyBzaG91bGRTdG9wID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuICEhdDsgfTsgfVxuICAgIHByb21pc2VGYWN0b3JpZXMgPSBwcm9taXNlRmFjdG9yaWVzLnJldmVyc2UoKS5zbGljZSgpO1xuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvbWlzZUZhY3Rvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBUUHJvbWlzZS5hcyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmFjdG9yeSA9IHByb21pc2VGYWN0b3JpZXMucG9wKCk7XG4gICAgICAgIHZhciBwcm9taXNlID0gZmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdG9wKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFByb21pc2UuYXMocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb29wKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGxvb3AoKTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdG8gcXVldWUgTiBwcm9taXNlcyBhbmQgcnVuIHRoZW0gYWxsIHdpdGggYSBtYXggZGVncmVlIG9mIHBhcmFsbGVsaXNtLiBUaGUgaGVscGVyXG4gKiBlbnN1cmVzIHRoYXQgYXQgYW55IHRpbWUgbm8gbW9yZSB0aGFuIE0gcHJvbWlzZXMgYXJlIHJ1bm5pbmcgYXQgdGhlIHNhbWUgdGltZS5cbiAqL1xudmFyIExpbWl0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGltaXRlcihtYXhEZWdyZWVPZlBhcmFsZWxsaXNtKSB7XG4gICAgICAgIHRoaXMubWF4RGVncmVlT2ZQYXJhbGVsbGlzbSA9IG1heERlZ3JlZU9mUGFyYWxlbGxpc207XG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgICB0aGlzLnJ1bm5pbmdQcm9taXNlcyA9IDA7XG4gICAgICAgIHRoaXMuX29uRmluaXNoZWQgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGltaXRlci5wcm90b3R5cGUsIFwib25GaW5pc2hlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uRmluaXNoZWQuZXZlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW1pdGVyLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nUHJvbWlzZXMgKyB0aGlzLm91dHN0YW5kaW5nUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaW1pdGVyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uIChwcm9taXNlRmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFRQcm9taXNlKGZ1bmN0aW9uIChjLCBlLCBwKSB7XG4gICAgICAgICAgICBfdGhpcy5vdXRzdGFuZGluZ1Byb21pc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZhY3Rvcnk6IHByb21pc2VGYWN0b3J5LFxuICAgICAgICAgICAgICAgIGM6IGMsXG4gICAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgICBwOiBwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaW1pdGVyLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodGhpcy5vdXRzdGFuZGluZ1Byb21pc2VzLmxlbmd0aCAmJiB0aGlzLnJ1bm5pbmdQcm9taXNlcyA8IHRoaXMubWF4RGVncmVlT2ZQYXJhbGVsbGlzbSkge1xuICAgICAgICAgICAgdmFyIGlMaW1pdGVkVGFzayA9IHRoaXMub3V0c3RhbmRpbmdQcm9taXNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nUHJvbWlzZXMrKztcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gaUxpbWl0ZWRUYXNrLmZhY3RvcnkoKTtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZShpTGltaXRlZFRhc2suYywgaUxpbWl0ZWRUYXNrLmUsIGlMaW1pdGVkVGFzay5wKTtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25zdW1lZCgpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25zdW1lZCgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGltaXRlci5wcm90b3R5cGUuY29uc3VtZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucnVubmluZ1Byb21pc2VzLS07XG4gICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaGVkLmZpcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGltaXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25GaW5pc2hlZC5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGltaXRlcjtcbn0oKSk7XG5leHBvcnQgeyBMaW1pdGVyIH07XG4vKipcbiAqIEEgcXVldWUgaXMgaGFuZGxlcyBvbmUgcHJvbWlzZSBhdCBhIHRpbWUgYW5kIGd1YXJhbnRlZXMgdGhhdCBhdCBhbnkgdGltZSBvbmx5IG9uZSBwcm9taXNlIGlzIGV4ZWN1dGluZy5cbiAqL1xudmFyIFF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWV1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIDEpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBRdWV1ZTtcbn0oTGltaXRlcikpO1xuZXhwb3J0IHsgUXVldWUgfTtcbi8qKlxuICogQSBoZWxwZXIgdG8gb3JnYW5pemUgcXVldWVzIHBlciByZXNvdXJjZS4gVGhlIFJlc291cmNlUXVldWUgbWFrZXMgc3VyZSB0byBtYW5hZ2UgcXVldWVzIHBlciByZXNvdXJjZVxuICogYnkgZGlzcG9zaW5nIHRoZW0gb25jZSB0aGUgcXVldWUgaXMgZW1wdHkuXG4gKi9cbnZhciBSZXNvdXJjZVF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlUXVldWUoKSB7XG4gICAgICAgIHRoaXMucXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgUmVzb3VyY2VRdWV1ZS5wcm90b3R5cGUucXVldWVGb3IgPSBmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGtleSA9IHJlc291cmNlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5xdWV1ZXNba2V5XSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlXzEgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgICAgIHF1ZXVlXzEub25GaW5pc2hlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcXVldWVfMS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnF1ZXVlc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlc1trZXldID0gcXVldWVfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZXNba2V5XTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvdXJjZVF1ZXVlO1xufSgpKTtcbmV4cG9ydCB7IFJlc291cmNlUXVldWUgfTtcbmV4cG9ydCBmdW5jdGlvbiBzZXREaXNwb3NhYmxlVGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dC5hcHBseSh2b2lkIDAsIFtoYW5kbGVyLCB0aW1lb3V0XS5jb25jYXQoYXJncykpO1xuICAgIHJldHVybiB7IGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgY2xlYXJUaW1lb3V0KGhhbmRsZSk7IH0gfTtcbn1cbnZhciBUaW1lb3V0VGltZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVvdXRUaW1lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lb3V0VGltZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90b2tlbiA9IC0xO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVvdXRUaW1lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBUaW1lb3V0VGltZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rva2VuICE9PSAtMSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Rva2VuKTtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRUaW1lci5wcm90b3R5cGUuY2FuY2VsQW5kU2V0ID0gZnVuY3Rpb24gKHJ1bm5lciwgdGltZW91dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl90b2tlbiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Rva2VuID0gLTE7XG4gICAgICAgICAgICBydW5uZXIoKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfTtcbiAgICBUaW1lb3V0VGltZXIucHJvdG90eXBlLnNldElmTm90U2V0ID0gZnVuY3Rpb24gKHJ1bm5lciwgdGltZW91dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fdG9rZW4gIT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aW1lciBpcyBhbHJlYWR5IHNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rva2VuID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdG9rZW4gPSAtMTtcbiAgICAgICAgICAgIHJ1bm5lcigpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0VGltZXI7XG59KERpc3Bvc2FibGUpKTtcbmV4cG9ydCB7IFRpbWVvdXRUaW1lciB9O1xudmFyIEludGVydmFsVGltZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludGVydmFsVGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50ZXJ2YWxUaW1lcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rva2VuID0gLTE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW50ZXJ2YWxUaW1lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBJbnRlcnZhbFRpbWVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b2tlbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50ZXJ2YWxUaW1lci5wcm90b3R5cGUuY2FuY2VsQW5kU2V0ID0gZnVuY3Rpb24gKHJ1bm5lciwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5uZXIoKTtcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVydmFsVGltZXI7XG59KERpc3Bvc2FibGUpKTtcbmV4cG9ydCB7IEludGVydmFsVGltZXIgfTtcbnZhciBSdW5PbmNlU2NoZWR1bGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJ1bk9uY2VTY2hlZHVsZXIocnVubmVyLCB0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMudGltZW91dFRva2VuID0gLTE7XG4gICAgICAgIHRoaXMucnVubmVyID0gcnVubmVyO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGVyID0gdGhpcy5vblRpbWVvdXQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBSdW5PbmNlU2NoZWR1bGVyXG4gICAgICovXG4gICAgUnVuT25jZVNjaGVkdWxlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5ydW5uZXIgPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGN1cnJlbnQgc2NoZWR1bGVkIHJ1bm5lciAoaWYgYW55KS5cbiAgICAgKi9cbiAgICBSdW5PbmNlU2NoZWR1bGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2NoZWR1bGVkKCkpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUb2tlbik7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRUb2tlbiA9IC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgcHJldmlvdXMgcnVubmVyIChpZiBhbnkpICYgc2NoZWR1bGUgYSBuZXcgcnVubmVyLlxuICAgICAqL1xuICAgIFJ1bk9uY2VTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gdGhpcy50aW1lb3V0OyB9XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMudGltZW91dFRva2VuID0gc2V0VGltZW91dCh0aGlzLnRpbWVvdXRIYW5kbGVyLCBkZWxheSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc2NoZWR1bGVkLlxuICAgICAqL1xuICAgIFJ1bk9uY2VTY2hlZHVsZXIucHJvdG90eXBlLmlzU2NoZWR1bGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lb3V0VG9rZW4gIT09IC0xO1xuICAgIH07XG4gICAgUnVuT25jZVNjaGVkdWxlci5wcm90b3R5cGUub25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRUb2tlbiA9IC0xO1xuICAgICAgICBpZiAodGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSdW5PbmNlU2NoZWR1bGVyO1xufSgpKTtcbmV4cG9ydCB7IFJ1bk9uY2VTY2hlZHVsZXIgfTtcbmV4cG9ydCBmdW5jdGlvbiBuZmNhbGwoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVFByb21pc2UoZnVuY3Rpb24gKGMsIGUpIHsgcmV0dXJuIGZuLmFwcGx5KHZvaWQgMCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyByZXR1cm4gZXJyID8gZShlcnIpIDogYyhyZXN1bHQpOyB9XSkpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuaW52b2tlKHRoaXNBcmcsIGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRQcm9taXNlKGZ1bmN0aW9uIChjLCBlKSB7IHJldHVybiBmbi5jYWxsLmFwcGx5KGZuLCBbdGhpc0FyZ10uY29uY2F0KGFyZ3MsIFtmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgcmV0dXJuIGVyciA/IGUoZXJyKSA6IGMocmVzdWx0KTsgfV0pKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG59XG4vKipcbiAqIEFuIGVtaXR0ZXIgdGhhdCB3aWxsIGlnbm9yZSBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgZHVyaW5nIGEgc3BlY2lmaWMgY29kZVxuICogZXhlY3V0aW9uIHRyaWdnZXJlZCB2aWEgdGhyb3R0bGUoKSB1bnRpbCB0aGUgcHJvbWlzZSBoYXMgZmluaXNoZWQgKGVpdGhlclxuICogc3VjY2Vzc2Z1bGx5IG9yIHdpdGggYW4gZXJyb3IpLiBPbmx5IGFmdGVyIHRoZSBwcm9taXNlIGhhcyBmaW5pc2hlZCwgdGhlXG4gKiBsYXN0IGV2ZW50IHRoYXQgd2FzIGZpcmVkIGR1cmluZyB0aGUgb3BlcmF0aW9uIHdpbGwgZ2V0IGVtaXR0ZWQuXG4gKlxuICovXG52YXIgVGhyb3R0bGVkRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVkRW1pdHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZWRFbWl0dGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRocm90dGxlZEVtaXR0ZXIucHJvdG90eXBlLnRocm90dGxlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYWx3YXlzKHByb21pc2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlc3VtZSgpOyB9KTtcbiAgICB9O1xuICAgIFRocm90dGxlZEVtaXR0ZXIucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3VzcGVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgdGhpcy5oYXNMYXN0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmZpcmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICBUaHJvdHRsZWRFbWl0dGVyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc0xhc3RFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKHRoaXMubGFzdEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0xhc3RFdmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHZvaWQgMDtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZWRFbWl0dGVyO1xufShFbWl0dGVyKSk7XG5leHBvcnQgeyBUaHJvdHRsZWRFbWl0dGVyIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/async.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js ***!
  \***********************************************************************/
/*! exports provided: CancellationToken, CancellationTokenSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CancellationToken\", function() { return CancellationToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CancellationTokenSource\", function() { return CancellationTokenSource; });\n/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar shortcutEvent = Object.freeze(function (callback, context) {\n    var handle = setTimeout(callback.bind(context), 0);\n    return { dispose: function () { clearTimeout(handle); } };\n});\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: _event_js__WEBPACK_IMPORTED_MODULE_0__[\"Event\"].None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: shortcutEvent\n    });\n})(CancellationToken || (CancellationToken = {}));\nvar MutableToken = /** @class */ (function () {\n    function MutableToken() {\n        this._isCancelled = false;\n    }\n    MutableToken.prototype.cancel = function () {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    };\n    Object.defineProperty(MutableToken.prototype, \"isCancellationRequested\", {\n        get: function () {\n            return this._isCancelled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MutableToken.prototype, \"onCancellationRequested\", {\n        get: function () {\n            if (this._isCancelled) {\n                return shortcutEvent;\n            }\n            if (!this._emitter) {\n                this._emitter = new _event_js__WEBPACK_IMPORTED_MODULE_0__[\"Emitter\"]();\n            }\n            return this._emitter.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MutableToken.prototype.dispose = function () {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    };\n    return MutableToken;\n}());\nvar CancellationTokenSource = /** @class */ (function () {\n    function CancellationTokenSource() {\n    }\n    Object.defineProperty(CancellationTokenSource.prototype, \"token\", {\n        get: function () {\n            if (!this._token) {\n                // be lazy and create the token only when\n                // actually needed\n                this._token = new MutableToken();\n            }\n            return this._token;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CancellationTokenSource.prototype.cancel = function () {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually cancel\n            this._token.cancel();\n        }\n    };\n    CancellationTokenSource.prototype.dispose = function () {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    };\n    return CancellationTokenSource;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2NhbmNlbGxhdGlvbi5qcz8yNTA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRXZlbnQsIEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50LmpzJztcbnZhciBzaG9ydGN1dEV2ZW50ID0gT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7IGNsZWFyVGltZW91dChoYW5kbGUpOyB9IH07XG59KTtcbmV4cG9ydCB2YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBFdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogc2hvcnRjdXRFdmVudFxuICAgIH0pO1xufSkoQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKENhbmNlbGxhdGlvblRva2VuID0ge30pKTtcbnZhciBNdXRhYmxlVG9rZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXV0YWJsZVRva2VuKCkge1xuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBNdXRhYmxlVG9rZW4ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE11dGFibGVUb2tlbi5wcm90b3R5cGUsIFwiaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE11dGFibGVUb2tlbi5wcm90b3R5cGUsIFwib25DYW5jZWxsYXRpb25SZXF1ZXN0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTXV0YWJsZVRva2VuLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTXV0YWJsZVRva2VuO1xufSgpKTtcbnZhciBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbmNlbGxhdGlvblRva2VuU291cmNlLnByb3RvdHlwZSwgXCJ0b2tlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGJlIGxhenkgYW5kIGNyZWF0ZSB0aGUgdG9rZW4gb25seSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuU291cmNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzb21lb25lIGFza3MgZm9yIHRoZSB0b2tlblxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGNhbmNlbFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbmNlbGxhdGlvblRva2VuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc3Bvc2VcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhbmNlbGxhdGlvblRva2VuU291cmNlO1xufSgpKTtcbmV4cG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js ***!
  \********************************************************************/
/*! exports provided: stringDiff, Debug, MyArray, LcsDiff */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringDiff\", function() { return stringDiff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Debug\", function() { return Debug; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MyArray\", function() { return MyArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LcsDiff\", function() { return LcsDiff; });\n/* harmony import */ var _diffChange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffChange.js */ \"./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction createStringSequence(a) {\n    return {\n        getLength: function () { return a.length; },\n        getElementHash: function (pos) { return a[pos]; }\n    };\n}\nfunction stringDiff(original, modified, pretty) {\n    return new LcsDiff(createStringSequence(original), createStringSequence(modified)).ComputeDiff(pretty);\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nvar Debug = /** @class */ (function () {\n    function Debug() {\n    }\n    Debug.Assert = function (condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    };\n    return Debug;\n}());\n\nvar MyArray = /** @class */ (function () {\n    function MyArray() {\n    }\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (var i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    };\n    return MyArray;\n}());\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nvar MaxDifferencesHistory = 1447;\n//let MaxDifferencesHistory = 100;\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nvar DiffChangeHelper = /** @class */ (function () {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    function DiffChangeHelper() {\n        this.m_changes = [];\n        this.m_originalStart = Number.MAX_VALUE;\n        this.m_modifiedStart = Number.MAX_VALUE;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    DiffChangeHelper.prototype.MarkNextChange = function () {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = Number.MAX_VALUE;\n        this.m_modifiedStart = Number.MAX_VALUE;\n    };\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    };\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    };\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    DiffChangeHelper.prototype.getChanges = function () {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    };\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    DiffChangeHelper.prototype.getReverseChanges = function () {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    };\n    return DiffChangeHelper;\n}());\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nvar LcsDiff = /** @class */ (function () {\n    /**\n     * Constructs the DiffFinder\n     */\n    function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {\n        if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }\n        this.OriginalSequence = originalSequence;\n        this.ModifiedSequence = newSequence;\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this.m_originalIds = [];\n        this.m_modifiedIds = [];\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        this.ComputeUniqueIdentifiers();\n    }\n    LcsDiff.prototype.ComputeUniqueIdentifiers = function () {\n        var originalSequenceLength = this.OriginalSequence.getLength();\n        var modifiedSequenceLength = this.ModifiedSequence.getLength();\n        this.m_originalIds = new Array(originalSequenceLength);\n        this.m_modifiedIds = new Array(modifiedSequenceLength);\n        // Create a new hash table for unique elements from the original\n        // sequence.\n        var hashTable = {};\n        var currentUniqueId = 1;\n        var i;\n        // Fill up the hash table for unique elements\n        for (i = 0; i < originalSequenceLength; i++) {\n            var originalElementHash = this.OriginalSequence.getElementHash(i);\n            if (!hasOwnProperty.call(hashTable, originalElementHash)) {\n                // No entry in the hashtable so this is a new unique element.\n                // Assign the element a new unique identifier and add it to the\n                // hash table\n                this.m_originalIds[i] = currentUniqueId++;\n                hashTable[originalElementHash] = this.m_originalIds[i];\n            }\n            else {\n                this.m_originalIds[i] = hashTable[originalElementHash];\n            }\n        }\n        // Now match up modified elements\n        for (i = 0; i < modifiedSequenceLength; i++) {\n            var modifiedElementHash = this.ModifiedSequence.getElementHash(i);\n            if (!hasOwnProperty.call(hashTable, modifiedElementHash)) {\n                this.m_modifiedIds[i] = currentUniqueId++;\n                hashTable[modifiedElementHash] = this.m_modifiedIds[i];\n            }\n            else {\n                this.m_modifiedIds[i] = hashTable[modifiedElementHash];\n            }\n        }\n    };\n    LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {\n        return this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];\n    };\n    LcsDiff.prototype.OriginalElementsAreEqual = function (index1, index2) {\n        return this.m_originalIds[index1] === this.m_originalIds[index2];\n    };\n    LcsDiff.prototype.ModifiedElementsAreEqual = function (index1, index2) {\n        return this.m_modifiedIds[index1] === this.m_modifiedIds[index2];\n    };\n    LcsDiff.prototype.ComputeDiff = function (pretty) {\n        return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1, pretty);\n    };\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        var quitEarlyArr = [false];\n        var changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            return this.ShiftChanges(changes);\n        }\n        return changes;\n    };\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            var changes = void 0;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        var midOriginalArr = [0], midModifiedArr = [0];\n        var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        var midOriginal = midOriginalArr[0];\n        var midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            var rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We did't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    };\n    LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        var forwardChanges = null, reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        var changeHelper = new DiffChangeHelper();\n        var diagonalMin = diagonalForwardStart;\n        var diagonalMax = diagonalForwardEnd;\n        var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        var lastOriginalIndex = Number.MIN_VALUE;\n        var historyIndex = this.m_forwardHistory.length - 1;\n        var diagonal;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            var originalStartPoint = midOriginalArr[0] + 1;\n            var modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                var lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = Number.MAX_VALUE;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    };\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        var originalIndex, modifiedIndex;\n        var diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        var diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        var numDifferences;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        var numDiagonals = maxDifferences + 1;\n        var forwardPoints = new Array(numDiagonals);\n        var reversePoints = new Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        var diagonalForwardBase = (modifiedEnd - modifiedStart);\n        var diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        var diagonalForwardOffset = (originalStart - modifiedStart);\n        var diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        var delta = diagonalReverseBase - diagonalForwardBase;\n        var deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        var diagonal, tempOriginalIndex;\n        for (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            var furthestOriginalIndex = 0;\n            var furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= MaxDifferencesHistory) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    };\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    LcsDiff.prototype.ShiftChanges = function (changes) {\n        var mergedDiffs;\n        do {\n            mergedDiffs = false;\n            // Shift all the changes down first\n            for (var i = 0; i < changes.length; i++) {\n                var change = changes[i];\n                var originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this.OriginalSequence.getLength();\n                var modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this.ModifiedSequence.getLength();\n                var checkOriginal = change.originalLength > 0;\n                var checkModified = change.modifiedLength > 0;\n                while (change.originalStart + change.originalLength < originalStop &&\n                    change.modifiedStart + change.modifiedLength < modifiedStop &&\n                    (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\n                    (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                    change.originalStart++;\n                    change.modifiedStart++;\n                }\n            }\n            // Build up the new list (we have to build a new list because we\n            // might have changes we can merge together now)\n            var result = new Array();\n            var mergedChangeArr = [null];\n            for (var i = 0; i < changes.length; i++) {\n                if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                    mergedDiffs = true;\n                    result.push(mergedChangeArr[0]);\n                    i++;\n                }\n                else {\n                    result.push(changes[i]);\n                }\n            }\n            changes = result;\n        } while (mergedDiffs);\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (var i = changes.length - 1; i >= 0; i--) {\n            var change = changes[i];\n            var originalStop = 0;\n            var modifiedStop = 0;\n            if (i > 0) {\n                var prevChange = changes[i - 1];\n                if (prevChange.originalLength > 0) {\n                    originalStop = prevChange.originalStart + prevChange.originalLength;\n                }\n                if (prevChange.modifiedLength > 0) {\n                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n                }\n            }\n            var checkOriginal = change.originalLength > 0;\n            var checkModified = change.modifiedLength > 0;\n            var bestDelta = 0;\n            var bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (var delta = 1;; delta++) {\n                var originalStart = change.originalStart - delta;\n                var modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                var score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n        }\n        return changes;\n    };\n    LcsDiff.prototype._OriginalIsBoundary = function (index) {\n        if (index <= 0 || index >= this.OriginalSequence.getLength() - 1) {\n            return true;\n        }\n        return /^\\s*$/.test(this.OriginalSequence.getElementHash(index));\n    };\n    LcsDiff.prototype._OriginalRegionIsBoundary = function (originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            var originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    LcsDiff.prototype._ModifiedIsBoundary = function (index) {\n        if (index <= 0 || index >= this.ModifiedSequence.getLength() - 1) {\n            return true;\n        }\n        return /^\\s*$/.test(this.ModifiedSequence.getElementHash(index));\n    };\n    LcsDiff.prototype._ModifiedRegionIsBoundary = function (modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            var modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    LcsDiff.prototype._boundaryScore = function (originalStart, originalLength, modifiedStart, modifiedLength) {\n        var originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        var modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    };\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    LcsDiff.prototype.ConcatenateChanges = function (left, right) {\n        var mergedChangeArr = [];\n        var result = null;\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    };\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            var originalStart = left.originalStart;\n            var originalLength = left.originalLength;\n            var modifiedStart = left.modifiedStart;\n            var modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__[\"DiffChange\"](originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    };\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        var diagonalsBelow = diagonalBaseIndex;\n        var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        var diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            var lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            var upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    };\n    return LcsDiff;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZi5qcz8xYjBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRGlmZkNoYW5nZSB9IGZyb20gJy4vZGlmZkNoYW5nZS5qcyc7XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdTZXF1ZW5jZShhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7IHJldHVybiBhLmxlbmd0aDsgfSxcbiAgICAgICAgZ2V0RWxlbWVudEhhc2g6IGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGFbcG9zXTsgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRGlmZihvcmlnaW5hbCwgbW9kaWZpZWQsIHByZXR0eSkge1xuICAgIHJldHVybiBuZXcgTGNzRGlmZihjcmVhdGVTdHJpbmdTZXF1ZW5jZShvcmlnaW5hbCksIGNyZWF0ZVN0cmluZ1NlcXVlbmNlKG1vZGlmaWVkKSkuQ29tcHV0ZURpZmYocHJldHR5KTtcbn1cbi8vXG4vLyBUaGUgY29kZSBiZWxvdyBoYXMgYmVlbiBwb3J0ZWQgZnJvbSBhIEMjIGltcGxlbWVudGF0aW9uIGluIFZTXG4vL1xudmFyIERlYnVnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYnVnKCkge1xuICAgIH1cbiAgICBEZWJ1Zy5Bc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJ1Zztcbn0oKSk7XG5leHBvcnQgeyBEZWJ1ZyB9O1xudmFyIE15QXJyYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXlBcnJheSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSBhbiBBcnJheSBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIHNvdXJjZSBpbmRleCBhbmQgcGFzdGVzXG4gICAgICogdGhlbSB0byBhbm90aGVyIEFycmF5IHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gaW5kZXguIFRoZSBsZW5ndGggYW5kIHRoZSBpbmRleGVzXG4gICAgICogYXJlIHNwZWNpZmllZCBhcyA2NC1iaXQgaW50ZWdlcnMuXG4gICAgICogc291cmNlQXJyYXk6XG4gICAgICpcdFx0VGhlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgdG8gY29weS5cbiAgICAgKiBzb3VyY2VJbmRleDpcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIHNvdXJjZUFycmF5IGF0IHdoaWNoIGNvcHlpbmcgYmVnaW5zLlxuICAgICAqIGRlc3RpbmF0aW9uQXJyYXk6XG4gICAgICpcdFx0VGhlIEFycmF5IHRoYXQgcmVjZWl2ZXMgdGhlIGRhdGEuXG4gICAgICogZGVzdGluYXRpb25JbmRleDpcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIGRlc3RpbmF0aW9uQXJyYXkgYXQgd2hpY2ggc3RvcmluZyBiZWdpbnMuXG4gICAgICogbGVuZ3RoOlxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY29weS5cbiAgICAgKi9cbiAgICBNeUFycmF5LkNvcHkgPSBmdW5jdGlvbiAoc291cmNlQXJyYXksIHNvdXJjZUluZGV4LCBkZXN0aW5hdGlvbkFycmF5LCBkZXN0aW5hdGlvbkluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25BcnJheVtkZXN0aW5hdGlvbkluZGV4ICsgaV0gPSBzb3VyY2VBcnJheVtzb3VyY2VJbmRleCArIGldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTXlBcnJheTtcbn0oKSk7XG5leHBvcnQgeyBNeUFycmF5IH07XG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyBMY3NEaWZmLmNzXG4vL1xuLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGRpZmZlcmVuY2UgYWxnb3JpdGhtIGRlc2NyaWJlZCBpblxuLy8gXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIHZhcmlhdGlvbnNcIiBieSBFdWdlbmUgVy4gTXllcnNcbi8vXG4vLyBDb3B5cmlnaHQgKEMpIDIwMDggTWljcm9zb2Z0IENvcnBvcmF0aW9uIEBtaW5pZmllcl9kb19ub3RfcHJlc2VydmVcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIE91ciB0b3RhbCBtZW1vcnkgdXNhZ2UgZm9yIHN0b3JpbmcgaGlzdG9yeSBpcyAod29yc3QtY2FzZSk6XG4vLyAyICogWyhNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKyAxKSAqIChNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKyAxKSAtIDFdICogc2l6ZW9mKGludClcbi8vIDIgKiBbMTQ0OCoxNDQ4IC0gMV0gKiA0ID0gMTY3NzM2MjQgPSAxNk1CXG52YXIgTWF4RGlmZmVyZW5jZXNIaXN0b3J5ID0gMTQ0Nztcbi8vbGV0IE1heERpZmZlcmVuY2VzSGlzdG9yeSA9IDEwMDtcbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHdoaWNoIGhlbHBzIHRvIGNyZWF0ZSB0aGUgc2V0IG9mIERpZmZDaGFuZ2VzIGZyb21cbiAqIGEgZGlmZmVyZW5jZSBvcGVyYXRpb24uIFRoaXMgY2xhc3MgYWNjZXB0cyBvcmlnaW5hbCBEaWZmRWxlbWVudHMgYW5kXG4gKiBtb2RpZmllZCBEaWZmRWxlbWVudHMgdGhhdCBhcmUgaW52b2x2ZWQgaW4gYSBwYXJ0aWN1bGFyIGNoYW5nZS4gVGhlXG4gKiBNYXJrdE5leHRDaGFuZ2UoKSBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byBtYXJrIHRoZSBzZXBhcmF0aW9uIGJldHdlZW5cbiAqIGRpc3RpbmN0IGNoYW5nZXMuIEF0IHRoZSBlbmQsIHRoZSBDaGFuZ2VzIHByb3BlcnR5IGNhbiBiZSBjYWxsZWQgdG8gcmV0cmlldmVcbiAqIHRoZSBjb25zdHJ1Y3RlZCBjaGFuZ2VzLlxuICovXG52YXIgRGlmZkNoYW5nZUhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IERpZmZDaGFuZ2VIZWxwZXIgZm9yIHRoZSBnaXZlbiBEaWZmU2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpZmZDaGFuZ2VIZWxwZXIoKSB7XG4gICAgICAgIHRoaXMubV9jaGFuZ2VzID0gW107XG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBjaGFuZ2UgaW4gdGhlIHNldCBvZiBkaWZmZXJlbmNlcy5cbiAgICAgKi9cbiAgICBEaWZmQ2hhbmdlSGVscGVyLnByb3RvdHlwZS5NYXJrTmV4dENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT25seSBhZGQgdG8gdGhlIGxpc3QgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGFkZFxuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgY2hhbmdlIHRvIG91ciBsaXN0XG4gICAgICAgICAgICB0aGlzLm1fY2hhbmdlcy5wdXNoKG5ldyBEaWZmQ2hhbmdlKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCB0aGlzLm1fb3JpZ2luYWxDb3VudCwgdGhpcy5tX21vZGlmaWVkU3RhcnQsIHRoaXMubV9tb2RpZmllZENvdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGNoYW5nZVxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBvcmlnaW5hbCBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZWxlbWVudHNcbiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBtb2RpZmllZCBpbmRleCBnaXZlcyBjb250ZXh0XG4gICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0byBhZGQuXG4gICAgICogQHBhcmFtIG1vZGlmaWVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBtb2RpZmllZCBlbGVtZW50IHRoYXQgcHJvdmlkZXMgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgRGlmZkNoYW5nZUhlbHBlci5wcm90b3R5cGUuQWRkT3JpZ2luYWxFbGVtZW50ID0gZnVuY3Rpb24gKG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlICd0cnVlJyBzdGFydCBpbmRleCBpcyB0aGUgc21hbGxlc3Qgb2YgdGhlIG9uZXMgd2UndmUgc2VlblxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IE1hdGgubWluKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEluZGV4KTtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRJbmRleCk7XG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBtb2RpZmllZCBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZWxlbWVudHNcbiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBvcmlnaW5hbCBpbmRleCBnaXZlcyBjb250ZXh0XG4gICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0byBhZGQuXG4gICAgICovXG4gICAgRGlmZkNoYW5nZUhlbHBlci5wcm90b3R5cGUuQWRkTW9kaWZpZWRFbGVtZW50ID0gZnVuY3Rpb24gKG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlICd0cnVlJyBzdGFydCBpbmRleCBpcyB0aGUgc21hbGxlc3Qgb2YgdGhlIG9uZXMgd2UndmUgc2VlblxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IE1hdGgubWluKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEluZGV4KTtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRJbmRleCk7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIG1hcmtlZCBieSB0aGUgY2xhc3MuXG4gICAgICovXG4gICAgRGlmZkNoYW5nZUhlbHBlci5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIEZpbmlzaCB1cCBvbiB3aGF0ZXZlciBpcyBsZWZ0XG4gICAgICAgICAgICB0aGlzLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubV9jaGFuZ2VzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY2hhbmdlcyBtYXJrZWQgYnkgdGhlIGNsYXNzIGluIHRoZSByZXZlcnNlIG9yZGVyXG4gICAgICovXG4gICAgRGlmZkNoYW5nZUhlbHBlci5wcm90b3R5cGUuZ2V0UmV2ZXJzZUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggdXAgb24gd2hhdGV2ZXIgaXMgbGVmdFxuICAgICAgICAgICAgdGhpcy5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubV9jaGFuZ2VzLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jaGFuZ2VzO1xuICAgIH07XG4gICAgcmV0dXJuIERpZmZDaGFuZ2VIZWxwZXI7XG59KCkpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGRpZmZlcmVuY2UgYWxnb3JpdGhtIGRlc2NyaWJlZCBpblxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIHZhcmlhdGlvbnNcIiBieSBFdWdlbmUgVy4gTXllcnNcbiAqL1xudmFyIExjc0RpZmYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyB0aGUgRGlmZkZpbmRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExjc0RpZmYob3JpZ2luYWxTZXF1ZW5jZSwgbmV3U2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSkge1xuICAgICAgICBpZiAoY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID09PSB2b2lkIDApIHsgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLk9yaWdpbmFsU2VxdWVuY2UgPSBvcmlnaW5hbFNlcXVlbmNlO1xuICAgICAgICB0aGlzLk1vZGlmaWVkU2VxdWVuY2UgPSBuZXdTZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgPSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGU7XG4gICAgICAgIHRoaXMubV9vcmlnaW5hbElkcyA9IFtdO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLkNvbXB1dGVVbmlxdWVJZGVudGlmaWVycygpO1xuICAgIH1cbiAgICBMY3NEaWZmLnByb3RvdHlwZS5Db21wdXRlVW5pcXVlSWRlbnRpZmllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFNlcXVlbmNlTGVuZ3RoID0gdGhpcy5PcmlnaW5hbFNlcXVlbmNlLmdldExlbmd0aCgpO1xuICAgICAgICB2YXIgbW9kaWZpZWRTZXF1ZW5jZUxlbmd0aCA9IHRoaXMuTW9kaWZpZWRTZXF1ZW5jZS5nZXRMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsSWRzID0gbmV3IEFycmF5KG9yaWdpbmFsU2VxdWVuY2VMZW5ndGgpO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRJZHMgPSBuZXcgQXJyYXkobW9kaWZpZWRTZXF1ZW5jZUxlbmd0aCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBoYXNoIHRhYmxlIGZvciB1bmlxdWUgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gc2VxdWVuY2UuXG4gICAgICAgIHZhciBoYXNoVGFibGUgPSB7fTtcbiAgICAgICAgdmFyIGN1cnJlbnRVbmlxdWVJZCA9IDE7XG4gICAgICAgIHZhciBpO1xuICAgICAgICAvLyBGaWxsIHVwIHRoZSBoYXNoIHRhYmxlIGZvciB1bmlxdWUgZWxlbWVudHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsU2VxdWVuY2VMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRWxlbWVudEhhc2ggPSB0aGlzLk9yaWdpbmFsU2VxdWVuY2UuZ2V0RWxlbWVudEhhc2goaSk7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoaGFzaFRhYmxlLCBvcmlnaW5hbEVsZW1lbnRIYXNoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGVudHJ5IGluIHRoZSBoYXNodGFibGUgc28gdGhpcyBpcyBhIG5ldyB1bmlxdWUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdGhlIGVsZW1lbnQgYSBuZXcgdW5pcXVlIGlkZW50aWZpZXIgYW5kIGFkZCBpdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBoYXNoIHRhYmxlXG4gICAgICAgICAgICAgICAgdGhpcy5tX29yaWdpbmFsSWRzW2ldID0gY3VycmVudFVuaXF1ZUlkKys7XG4gICAgICAgICAgICAgICAgaGFzaFRhYmxlW29yaWdpbmFsRWxlbWVudEhhc2hdID0gdGhpcy5tX29yaWdpbmFsSWRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX29yaWdpbmFsSWRzW2ldID0gaGFzaFRhYmxlW29yaWdpbmFsRWxlbWVudEhhc2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBtYXRjaCB1cCBtb2RpZmllZCBlbGVtZW50c1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kaWZpZWRTZXF1ZW5jZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRFbGVtZW50SGFzaCA9IHRoaXMuTW9kaWZpZWRTZXF1ZW5jZS5nZXRFbGVtZW50SGFzaChpKTtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChoYXNoVGFibGUsIG1vZGlmaWVkRWxlbWVudEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vZGlmaWVkSWRzW2ldID0gY3VycmVudFVuaXF1ZUlkKys7XG4gICAgICAgICAgICAgICAgaGFzaFRhYmxlW21vZGlmaWVkRWxlbWVudEhhc2hdID0gdGhpcy5tX21vZGlmaWVkSWRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vZGlmaWVkSWRzW2ldID0gaGFzaFRhYmxlW21vZGlmaWVkRWxlbWVudEhhc2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMY3NEaWZmLnByb3RvdHlwZS5FbGVtZW50c0FyZUVxdWFsID0gZnVuY3Rpb24gKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fb3JpZ2luYWxJZHNbb3JpZ2luYWxJbmRleF0gPT09IHRoaXMubV9tb2RpZmllZElkc1tuZXdJbmRleF07XG4gICAgfTtcbiAgICBMY3NEaWZmLnByb3RvdHlwZS5PcmlnaW5hbEVsZW1lbnRzQXJlRXF1YWwgPSBmdW5jdGlvbiAoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9vcmlnaW5hbElkc1tpbmRleDFdID09PSB0aGlzLm1fb3JpZ2luYWxJZHNbaW5kZXgyXTtcbiAgICB9O1xuICAgIExjc0RpZmYucHJvdG90eXBlLk1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbCA9IGZ1bmN0aW9uIChpbmRleDEsIGluZGV4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5tX21vZGlmaWVkSWRzW2luZGV4MV0gPT09IHRoaXMubV9tb2RpZmllZElkc1tpbmRleDJdO1xuICAgIH07XG4gICAgTGNzRGlmZi5wcm90b3R5cGUuQ29tcHV0ZURpZmYgPSBmdW5jdGlvbiAocHJldHR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9Db21wdXRlRGlmZigwLCB0aGlzLk9yaWdpbmFsU2VxdWVuY2UuZ2V0TGVuZ3RoKCkgLSAxLCAwLCB0aGlzLk1vZGlmaWVkU2VxdWVuY2UuZ2V0TGVuZ3RoKCkgLSAxLCBwcmV0dHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCBtb2RpZmllZCBpbnB1dFxuICAgICAqIHNlcXVlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZS5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBMY3NEaWZmLnByb3RvdHlwZS5fQ29tcHV0ZURpZmYgPSBmdW5jdGlvbiAob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBwcmV0dHkpIHtcbiAgICAgICAgdmFyIHF1aXRFYXJseUFyciA9IFtmYWxzZV07XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycik7XG4gICAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gY2xlYW4gdXAgdGhlIGNvbXB1dGVkIGRpZmYgdG8gYmUgbW9yZSBpbnR1aXRpdmVcbiAgICAgICAgICAgIC8vIGJ1dCBpdCB0dXJucyBvdXQgdGhpcyBjYW5ub3QgYmUgZG9uZSBjb3JyZWN0bHkgdW50aWwgdGhlIGVudGlyZSBzZXRcbiAgICAgICAgICAgIC8vIG9mIGRpZmZzIGhhdmUgYmVlbiBjb21wdXRlZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuU2hpZnRDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHdoaWNoIGNvbXB1dGVzIHRoZSBkaWZmZXJlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZVxuICAgICAqIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIExjc0RpZmYucHJvdG90eXBlLkNvbXB1dGVEaWZmUmVjdXJzaXZlID0gZnVuY3Rpb24gKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKSB7XG4gICAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlO1xuICAgICAgICAvLyBGaW5kIHRoZSBzdGFydCBvZiB0aGUgZGlmZmVyZW5jZXNcbiAgICAgICAgd2hpbGUgKG9yaWdpbmFsU3RhcnQgPD0gb3JpZ2luYWxFbmQgJiYgbW9kaWZpZWRTdGFydCA8PSBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCkpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIGRpZmZlcmVuY2VzXG4gICAgICAgIHdoaWxlIChvcmlnaW5hbEVuZCA+PSBvcmlnaW5hbFN0YXJ0ICYmIG1vZGlmaWVkRW5kID49IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsRW5kLCBtb2RpZmllZEVuZCkpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kLS07XG4gICAgICAgICAgICBtb2RpZmllZEVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgZWl0aGVyIGhhdmUgYWxsIGluc2VydGlvbnMgb3IgYWxsIGRlbGV0aW9ucyBvciB0aGUgc2VxdWVuY2VzIGFyZSBpZGVudGljYWxcbiAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnQgPiBvcmlnaW5hbEVuZCB8fCBtb2RpZmllZFN0YXJ0ID4gbW9kaWZpZWRFbmQpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkU3RhcnQgPD0gbW9kaWZpZWRFbmQpIHtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7XG4gICAgICAgICAgICAgICAgLy8gQWxsIGluc2VydGlvbnNcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCAwLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kKSB7XG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xuICAgICAgICAgICAgICAgIC8vIEFsbCBkZWxldGlvbnNcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQgKyAxLCBtb2RpZmllZFN0YXJ0LCAwKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7XG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xuICAgICAgICAgICAgICAgIC8vIElkZW50aWNhbCBzZXF1ZW5jZXMgLSBObyBkaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcHJvYmxlbSBjYW4gYmUgc29sdmVkIHVzaW5nIHRoZSBEaXZpZGUtQW5kLUNvbnF1ZXIgdGVjaG5pcXVlLlxuICAgICAgICB2YXIgbWlkT3JpZ2luYWxBcnIgPSBbMF0sIG1pZE1vZGlmaWVkQXJyID0gWzBdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5Db21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycik7XG4gICAgICAgIHZhciBtaWRPcmlnaW5hbCA9IG1pZE9yaWdpbmFsQXJyWzBdO1xuICAgICAgICB2YXIgbWlkTW9kaWZpZWQgPSBtaWRNb2RpZmllZEFyclswXTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVzdWx0IGlzIG5vdC1udWxsIHdoZW4gdGhlcmUgd2FzIGVub3VnaCBtZW1vcnkgdG8gY29tcHV0ZSB0aGUgY2hhbmdlcyB3aGlsZVxuICAgICAgICAgICAgLy8gc2VhcmNoaW5nIGZvciB0aGUgcmVjdXJzaW9uIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBicmVhayB0aGUgcHJvYmxlbSBkb3duIHJlY3Vyc2l2ZWx5IGJ5IGZpbmRpbmcgdGhlIGNoYW5nZXMgaW4gdGhlXG4gICAgICAgICAgICAvLyBGaXJzdCBIYWxmOiAgIChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KSB0byAobWlkT3JpZ2luYWwsIG1pZE1vZGlmaWVkKVxuICAgICAgICAgICAgLy8gU2Vjb25kIEhhbGY6ICAobWlkT3JpZ2luYWwgKyAxLCBtaW5Nb2RpZmllZCArIDEpIHRvIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXG4gICAgICAgICAgICAvLyBOT1RFOiBDb21wdXRlRGlmZigpIGlzIGluY2x1c2l2ZSwgdGhlcmVmb3JlIHRoZSBzZWNvbmQgcmFuZ2Ugc3RhcnRzIG9uIHRoZSBuZXh0IHBvaW50XG4gICAgICAgICAgICB2YXIgbGVmdENoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG1pZE9yaWdpbmFsLCBtb2RpZmllZFN0YXJ0LCBtaWRNb2RpZmllZCwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgICAgIHZhciByaWdodENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICghcXVpdEVhcmx5QXJyWzBdKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShtaWRPcmlnaW5hbCArIDEsIG9yaWdpbmFsRW5kLCBtaWRNb2RpZmllZCArIDEsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZGlkJ3QgaGF2ZSB0aW1lIHRvIGZpbmlzaCB0aGUgZmlyc3QgaGFsZiwgc28gd2UgZG9uJ3QgaGF2ZSB0aW1lIHRvIGNvbXB1dGUgdGhpcyBoYWxmLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZSBlbnRpcmUgcmVzdCBvZiB0aGUgc2VxdWVuY2UgZGlmZmVyZW50LlxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2UobWlkT3JpZ2luYWwgKyAxLCBvcmlnaW5hbEVuZCAtIChtaWRPcmlnaW5hbCArIDEpICsgMSwgbWlkTW9kaWZpZWQgKyAxLCBtb2RpZmllZEVuZCAtIChtaWRNb2RpZmllZCArIDEpICsgMSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ29uY2F0ZW5hdGVDaGFuZ2VzKGxlZnRDaGFuZ2VzLCByaWdodENoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhpdCBoZXJlLCB3ZSBxdWl0IGVhcmx5LCBhbmQgc28gY2FuJ3QgcmV0dXJuIGFueXRoaW5nIG1lYW5pbmdmdWxcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICBMY3NEaWZmLnByb3RvdHlwZS5XQUxLVFJBQ0UgPSBmdW5jdGlvbiAoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKSB7XG4gICAgICAgIHZhciBmb3J3YXJkQ2hhbmdlcyA9IG51bGwsIHJldmVyc2VDaGFuZ2VzID0gbnVsbDtcbiAgICAgICAgLy8gRmlyc3QsIHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgZm9yd2FyZCBkaWFnb25hbHMgaGlzdG9yeVxuICAgICAgICB2YXIgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTtcbiAgICAgICAgdmFyIGRpYWdvbmFsTWluID0gZGlhZ29uYWxGb3J3YXJkU3RhcnQ7XG4gICAgICAgIHZhciBkaWFnb25hbE1heCA9IGRpYWdvbmFsRm9yd2FyZEVuZDtcbiAgICAgICAgdmFyIGRpYWdvbmFsUmVsYXRpdmUgPSAobWlkT3JpZ2luYWxBcnJbMF0gLSBtaWRNb2RpZmllZEFyclswXSkgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XG4gICAgICAgIHZhciBsYXN0T3JpZ2luYWxJbmRleCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICAgIHZhciBoaXN0b3J5SW5kZXggPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGRpYWdvbmFsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRpYWdvbmFsIGluZGV4IGZyb20gdGhlIHJlbGF0aXZlIGRpYWdvbmFsIG51bWJlclxuICAgICAgICAgICAgZGlhZ29uYWwgPSBkaWFnb25hbFJlbGF0aXZlICsgZGlhZ29uYWxGb3J3YXJkQmFzZTtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hlcmUgd2UgY2FtZSBmcm9tXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsTWluIHx8IChkaWFnb25hbCA8IGRpYWdvbmFsTWF4ICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhbiBpbnNlcnQpXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgKyAxKSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhIGRlbGV0aW9uKVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8IGxhc3RPcmlnaW5hbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgLSAxKSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpc3RvcnlJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBvaW50cyA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeVtoaXN0b3J5SW5kZXhdO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZEJhc2UgPSBmb3J3YXJkUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90XG4gICAgICAgICAgICAgICAgZGlhZ29uYWxNaW4gPSAxO1xuICAgICAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gZm9yd2FyZFBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgtLWhpc3RvcnlJbmRleCA+PSAtMSk7XG4gICAgICAgIC8vIElyb25pY2FsbHksIHdlIGdldCB0aGUgZm9yd2FyZCBjaGFuZ2VzIGFzIHRoZSByZXZlcnNlIG9mIHRoZVxuICAgICAgICAvLyBvcmRlciB3ZSBhZGRlZCB0aGVtIHNpbmNlIHdlIHRlY2huaWNhbGx5IGFkZGVkIHRoZW0gYmFja3dhcmRzXG4gICAgICAgIGZvcndhcmRDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldFJldmVyc2VDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChxdWl0RWFybHlBcnJbMF0pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IENhbGN1bGF0ZSBhIHBhcnRpYWwgZnJvbSB0aGUgcmV2ZXJzZSBkaWFnb25hbHMuXG4gICAgICAgICAgICAvLyAgICAgICBGb3Igbm93LCBqdXN0IGFzc3VtZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBtaWRPcmlnaW5hbC9taWRNb2RpZmllZCBwb2ludCBpcyBhIGRpZmZcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBtaWRPcmlnaW5hbEFyclswXSArIDE7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRTdGFydFBvaW50ID0gbWlkTW9kaWZpZWRBcnJbMF0gKyAxO1xuICAgICAgICAgICAgaWYgKGZvcndhcmRDaGFuZ2VzICE9PSBudWxsICYmIGZvcndhcmRDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdEZvcndhcmRDaGFuZ2UgPSBmb3J3YXJkQ2hhbmdlc1tmb3J3YXJkQ2hhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBNYXRoLm1heChvcmlnaW5hbFN0YXJ0UG9pbnQsIGxhc3RGb3J3YXJkQ2hhbmdlLmdldE9yaWdpbmFsRW5kKCkpO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRQb2ludCA9IE1hdGgubWF4KG1vZGlmaWVkU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0TW9kaWZpZWRFbmQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXZlcnNlQ2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0UG9pbnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydFBvaW50ICsgMSwgbW9kaWZpZWRTdGFydFBvaW50LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnRQb2ludCArIDEpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm93IHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgcmV2ZXJzZSBkaWFnb25hbHMgaGlzdG9yeVxuICAgICAgICAgICAgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTtcbiAgICAgICAgICAgIGRpYWdvbmFsTWluID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7XG4gICAgICAgICAgICBkaWFnb25hbE1heCA9IGRpYWdvbmFsUmV2ZXJzZUVuZDtcbiAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAobWlkT3JpZ2luYWxBcnJbMF0gLSBtaWRNb2RpZmllZEFyclswXSkgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBoaXN0b3J5SW5kZXggPSAoZGVsdGFJc0V2ZW4pID8gdGhpcy5tX3JldmVyc2VIaXN0b3J5Lmxlbmd0aCAtIDEgOiB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGRpYWdvbmFsIGluZGV4IGZyb20gdGhlIHJlbGF0aXZlIGRpYWdvbmFsIG51bWJlclxuICAgICAgICAgICAgICAgIGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsUmV2ZXJzZUJhc2U7XG4gICAgICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGVyZSB3ZSBjYW1lIGZyb21cbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsTWluIHx8IChkaWFnb25hbCA8IGRpYWdvbmFsTWF4ICYmIHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXSA+PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbikpXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0gLSAxO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID4gbGFzdE9yaWdpbmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCArIDEpIC0gZGlhZ29uYWxSZXZlcnNlQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhbiBpbnNlcnRpb24pXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPiBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgLSAxKSAtIGRpYWdvbmFsUmV2ZXJzZUJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZVBvaW50cyA9IHRoaXMubV9yZXZlcnNlSGlzdG9yeVtoaXN0b3J5SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbFJldmVyc2VCYXNlID0gcmV2ZXJzZVBvaW50c1swXTsgLy9XZSBzdG9yZWQgdGhpcyBpbiB0aGUgZmlyc3Qgc3BvdFxuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbE1pbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gcmV2ZXJzZVBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKC0taGlzdG9yeUluZGV4ID49IC0xKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgcmV2ZXJzZSBoaXN0b3J5IHdpbGwgZmluZCBkaWZmcyB0aGF0XG4gICAgICAgICAgICAvLyBhcmUgY29ycmVjdCwgYnV0IG5vdCBpbnR1aXRpdmUsIHNvIHdlIG5lZWQgc2hpZnQgdGhlbS5cbiAgICAgICAgICAgIHJldmVyc2VDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5Db25jYXRlbmF0ZUNoYW5nZXMoZm9yd2FyZENoYW5nZXMsIHJldmVyc2VDaGFuZ2VzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSByYW5nZSB0byBjb21wdXRlIHRoZSBkaWZmIG9uLCB0aGlzIG1ldGhvZCBmaW5kcyB0aGUgcG9pbnQ6XG4gICAgICogKG1pZE9yaWdpbmFsLCBtaWRNb2RpZmllZClcbiAgICAgKiB0aGF0IGV4aXN0cyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBMQ1Mgb2YgdGhlIHR3byBzZXF1ZW5jZXMgYW5kXG4gICAgICogaXMgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBMQ1MgcHJvYmxlbSBtYXkgYmUgYnJva2VuIGRvd24gcmVjdXJzaXZlbHkuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB0cnkgdG8ga2VlcCB0aGUgTENTIHRyYWNlIGluIG1lbW9yeS4gSWYgdGhlIExDUyByZWN1cnNpb25cbiAgICAgKiBwb2ludCBpcyBjYWxjdWxhdGVkIGFuZCB0aGUgZnVsbCB0cmFjZSBpcyBhdmFpbGFibGUgaW4gbWVtb3J5LCB0aGVuIHRoaXMgbWV0aG9kXG4gICAgICogd2lsbCByZXR1cm4gdGhlIGNoYW5nZSBsaXN0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbFN0YXJ0IFRoZSBzdGFydCBib3VuZCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxFbmQgVGhlIGVuZCBib3VuZCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRTdGFydCBUaGUgc3RhcnQgYm91bmQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG1vZGlmaWVkRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG1pZE9yaWdpbmFsIFRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG1pZE1vZGlmaWVkIFRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHJldHVybnMgVGhlIGRpZmYgY2hhbmdlcywgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIExjc0RpZmYucHJvdG90eXBlLkNvbXB1dGVSZWN1cnNpb25Qb2ludCA9IGZ1bmN0aW9uIChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIG1pZE9yaWdpbmFsQXJyLCBtaWRNb2RpZmllZEFyciwgcXVpdEVhcmx5QXJyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4O1xuICAgICAgICB2YXIgZGlhZ29uYWxGb3J3YXJkU3RhcnQgPSAwLCBkaWFnb25hbEZvcndhcmRFbmQgPSAwO1xuICAgICAgICB2YXIgZGlhZ29uYWxSZXZlcnNlU3RhcnQgPSAwLCBkaWFnb25hbFJldmVyc2VFbmQgPSAwO1xuICAgICAgICB2YXIgbnVtRGlmZmVyZW5jZXM7XG4gICAgICAgIC8vIFRvIHRyYXZlcnNlIHRoZSBlZGl0IGdyYXBoIGFuZCBwcm9kdWNlIHRoZSBwcm9wZXIgTENTLCBvdXIgYWN0dWFsXG4gICAgICAgIC8vIHN0YXJ0IHBvc2l0aW9uIGlzIGp1c3Qgb3V0c2lkZSB0aGUgZ2l2ZW4gYm91bmRhcnlcbiAgICAgICAgb3JpZ2luYWxTdGFydC0tO1xuICAgICAgICBtb2RpZmllZFN0YXJ0LS07XG4gICAgICAgIC8vIFdlIHNldCB0aGVzZSB1cCB0byBtYWtlIHRoZSBjb21waWxlciBoYXBweSwgYnV0IHRoZXkgd2lsbFxuICAgICAgICAvLyBiZSByZXBsYWNlZCBiZWZvcmUgd2UgcmV0dXJuIHdpdGggdGhlIGFjdHVhbCByZWN1cnNpb24gcG9pbnRcbiAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSAwO1xuICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IDA7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgaGlzdG9yeVxuICAgICAgICB0aGlzLm1fZm9yd2FyZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5tX3JldmVyc2VIaXN0b3J5ID0gW107XG4gICAgICAgIC8vIEVhY2ggY2VsbCBpbiB0aGUgdHdvIGFycmF5cyBjb3JyZXNwb25kcyB0byBhIGRpYWdvbmFsIGluIHRoZSBlZGl0IGdyYXBoLlxuICAgICAgICAvLyBUaGUgaW50ZWdlciB2YWx1ZSBpbiB0aGUgY2VsbCByZXByZXNlbnRzIHRoZSBvcmlnaW5hbEluZGV4IG9mIHRoZSBmdXJ0aGVzdFxuICAgICAgICAvLyByZWFjaGluZyBwb2ludCBmb3VuZCBzbyBmYXIgdGhhdCBlbmRzIGluIHRoYXQgZGlhZ29uYWwuXG4gICAgICAgIC8vIFRoZSBtb2RpZmllZEluZGV4IGNhbiBiZSBjb21wdXRlZCBtYXRoZW1hdGljYWxseSBmcm9tIHRoZSBvcmlnaW5hbEluZGV4IGFuZCB0aGUgZGlhZ29uYWwgbnVtYmVyLlxuICAgICAgICB2YXIgbWF4RGlmZmVyZW5jZXMgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KSArIChtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQpO1xuICAgICAgICB2YXIgbnVtRGlhZ29uYWxzID0gbWF4RGlmZmVyZW5jZXMgKyAxO1xuICAgICAgICB2YXIgZm9yd2FyZFBvaW50cyA9IG5ldyBBcnJheShudW1EaWFnb25hbHMpO1xuICAgICAgICB2YXIgcmV2ZXJzZVBvaW50cyA9IG5ldyBBcnJheShudW1EaWFnb25hbHMpO1xuICAgICAgICAvLyBkaWFnb25hbEZvcndhcmRCYXNlOiBJbmRleCBpbnRvIGZvcndhcmRQb2ludHMgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KVxuICAgICAgICAvLyBkaWFnb25hbFJldmVyc2VCYXNlOiBJbmRleCBpbnRvIHJldmVyc2VQb2ludHMgb2YgdGhlIGRpYWdvbmFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXG4gICAgICAgIHZhciBkaWFnb25hbEZvcndhcmRCYXNlID0gKG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCk7XG4gICAgICAgIHZhciBkaWFnb25hbFJldmVyc2VCYXNlID0gKG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCk7XG4gICAgICAgIC8vIGRpYWdvbmFsRm9yd2FyZE9mZnNldDogR2VvbWV0cmljIG9mZnNldCB3aGljaCBhbGxvd3MgbW9kaWZpZWRJbmRleCB0byBiZSBjb21wdXRlZCBmcm9tIG9yaWdpbmFsSW5kZXggYW5kIHRoZVxuICAgICAgICAvLyAgICBkaWFnb25hbCBudW1iZXIgKHJlbGF0aXZlIHRvIGRpYWdvbmFsRm9yd2FyZEJhc2UpXG4gICAgICAgIC8vIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDogR2VvbWV0cmljIG9mZnNldCB3aGljaCBhbGxvd3MgbW9kaWZpZWRJbmRleCB0byBiZSBjb21wdXRlZCBmcm9tIG9yaWdpbmFsSW5kZXggYW5kIHRoZVxuICAgICAgICAvLyAgICBkaWFnb25hbCBudW1iZXIgKHJlbGF0aXZlIHRvIGRpYWdvbmFsUmV2ZXJzZUJhc2UpXG4gICAgICAgIHZhciBkaWFnb25hbEZvcndhcmRPZmZzZXQgPSAob3JpZ2luYWxTdGFydCAtIG1vZGlmaWVkU3RhcnQpO1xuICAgICAgICB2YXIgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0ID0gKG9yaWdpbmFsRW5kIC0gbW9kaWZpZWRFbmQpO1xuICAgICAgICAvLyBkZWx0YTogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZW5kIGRpYWdvbmFsIGFuZCB0aGUgc3RhcnQgZGlhZ29uYWwuIFRoaXMgaXMgdXNlZCB0byByZWxhdGUgZGlhZ29uYWwgbnVtYmVyc1xuICAgICAgICAvLyAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBkaWFnb25hbCB3aXRoIGRpYWdvbmFsIG51bWJlcnMgcmVsYXRpdmUgdG8gdGhlIGVuZCBkaWFnb25hbC5cbiAgICAgICAgLy8gVGhlIEV2ZW4vT2Rkbi1uZXNzIG9mIHRoaXMgZGVsdGEgaXMgaW1wb3J0YW50IGZvciBkZXRlcm1pbmluZyB3aGVuIHdlIHNob3VsZCBjaGVjayBmb3Igb3ZlcmxhcFxuICAgICAgICB2YXIgZGVsdGEgPSBkaWFnb25hbFJldmVyc2VCYXNlIC0gZGlhZ29uYWxGb3J3YXJkQmFzZTtcbiAgICAgICAgdmFyIGRlbHRhSXNFdmVuID0gKGRlbHRhICUgMiA9PT0gMCk7XG4gICAgICAgIC8vIEhlcmUgd2Ugc2V0IHVwIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBhcyB0aGUgZnVydGhlc3QgcG9pbnRzIGZvdW5kIHNvIGZhclxuICAgICAgICAvLyBpbiBib3RoIHRoZSBmb3J3YXJkIGFuZCByZXZlcnNlIGRpcmVjdGlvbnMsIHJlc3BlY3RpdmVseVxuICAgICAgICBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsRm9yd2FyZEJhc2VdID0gb3JpZ2luYWxTdGFydDtcbiAgICAgICAgcmV2ZXJzZVBvaW50c1tkaWFnb25hbFJldmVyc2VCYXNlXSA9IG9yaWdpbmFsRW5kO1xuICAgICAgICAvLyBSZW1lbWJlciBpZiB3ZSBxdWl0IGVhcmx5LCBhbmQgdGh1cyBuZWVkIHRvIGRvIGEgYmVzdC1lZmZvcnQgcmVzdWx0IGluc3RlYWQgb2YgYSByZWFsIHJlc3VsdC5cbiAgICAgICAgcXVpdEVhcmx5QXJyWzBdID0gZmFsc2U7XG4gICAgICAgIC8vIEEgY291cGxlIG9mIHBvaW50czpcbiAgICAgICAgLy8gLS1XaXRoIHRoaXMgbWV0aG9kLCB3ZSBpdGVyYXRlIG9uIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIHNlcXVlbmNlcy5cbiAgICAgICAgLy8gICBUaGUgbW9yZSBkaWZmZXJlbmNlcyB0aGVyZSBhY3R1YWxseSBhcmUsIHRoZSBsb25nZXIgdGhpcyB3aWxsIHRha2UuXG4gICAgICAgIC8vIC0tQWxzbywgYXMgdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlcyBpbmNyZWFzZXMsIHdlIGhhdmUgdG8gc2VhcmNoIG9uIGRpYWdvbmFscyBmdXJ0aGVyXG4gICAgICAgIC8vICAgYXdheSBmcm9tIHRoZSByZWZlcmVuY2UgZGlhZ29uYWwgKHdoaWNoIGlzIGRpYWdvbmFsRm9yd2FyZEJhc2UgZm9yIGZvcndhcmQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UgZm9yIHJldmVyc2UpLlxuICAgICAgICAvLyAtLVdlIGV4dGVuZCBvbiBldmVuIGRpYWdvbmFscyAocmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSBkaWFnb25hbCkgb25seSB3aGVuIG51bURpZmZlcmVuY2VzXG4gICAgICAgIC8vICAgaXMgZXZlbiBhbmQgb2RkIGRpYWdvbmFscyBvbmx5IHdoZW4gbnVtRGlmZmVyZW5jZXMgaXMgb2RkLlxuICAgICAgICB2YXIgZGlhZ29uYWwsIHRlbXBPcmlnaW5hbEluZGV4O1xuICAgICAgICBmb3IgKG51bURpZmZlcmVuY2VzID0gMTsgbnVtRGlmZmVyZW5jZXMgPD0gKG1heERpZmZlcmVuY2VzIC8gMikgKyAxOyBudW1EaWZmZXJlbmNlcysrKSB7XG4gICAgICAgICAgICB2YXIgZnVydGhlc3RPcmlnaW5hbEluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbGdvcml0aG0gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uXG4gICAgICAgICAgICBkaWFnb25hbEZvcndhcmRTdGFydCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSAtIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcbiAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZEVuZCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSArIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcbiAgICAgICAgICAgIGZvciAoZGlhZ29uYWwgPSBkaWFnb25hbEZvcndhcmRTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxGb3J3YXJkRW5kOyBkaWFnb25hbCArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KVxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxGb3J3YXJkRW5kICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsRm9yd2FyZEJhc2UpIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcCBpbiBzdGVwIDNcbiAgICAgICAgICAgICAgICB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAyOiBXZSBjYW4gY29udGludWUgdG8gZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxuICAgICAgICAgICAgICAgIC8vIHNvIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA8IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkSW5kZXggPCBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ICsgbW9kaWZpZWRJbmRleCA+IGZ1cnRoZXN0T3JpZ2luYWxJbmRleCArIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSBtb2RpZmllZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTVEVQIDM6IElmIGRlbHRhIGlzIG9kZCAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIGZvcndhcmQgd2hlbiBkZWx0YSBpcyBvZGQpXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpYWdvbmFsIGlzIGluIHRoZSByYW5nZSBvZiByZXZlcnNlIGRpYWdvbmFscyBjb21wdXRlZCBmb3IgbnVtRGlmZmVyZW5jZXMtMVxuICAgICAgICAgICAgICAgIC8vICh0aGUgcHJldmlvdXMgaXRlcmF0aW9uOyB3ZSBoYXZlbid0IGNvbXB1dGVkIHJldmVyc2UgZGlhZ29uYWxzIGZvciBudW1EaWZmZXJlbmNlcyB5ZXQpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICBpZiAoIWRlbHRhSXNFdmVuICYmIE1hdGguYWJzKGRpYWdvbmFsIC0gZGlhZ29uYWxSZXZlcnNlQmFzZSkgPD0gKG51bURpZmZlcmVuY2VzIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gbW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA8PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSAmJiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgPiAwICYmIG51bURpZmZlcmVuY2VzIDw9IChNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJJTkdPISBXZSBvdmVybGFwcGVkLCBhbmQgd2UgaGF2ZSB0aGUgZnVsbCB0cmFjZSBpbiBtZW1vcnkhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgZmFsc2Ugb3ZlcmxhcCwgb3Igd2UgZGlkbid0IGhhdmUgZW5vdWdoIG1lbW9yeSBmb3IgdGhlIGZ1bGwgdHJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHJldHVybiB0aGUgcmVjdXJzaW9uIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIGJlIHF1aXR0aW5nIGVhcmx5LCBiZWZvcmUgbW92aW5nIG9uIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIHZhciBtYXRjaExlbmd0aE9mTG9uZ2VzdCA9ICgoZnVydGhlc3RPcmlnaW5hbEluZGV4IC0gb3JpZ2luYWxTdGFydCkgKyAoZnVydGhlc3RNb2RpZmllZEluZGV4IC0gbW9kaWZpZWRTdGFydCkgLSBudW1EaWZmZXJlbmNlcykgLyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlICE9PSBudWxsICYmICF0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZShmdXJ0aGVzdE9yaWdpbmFsSW5kZXgsIHRoaXMuT3JpZ2luYWxTZXF1ZW5jZSwgbWF0Y2hMZW5ndGhPZkxvbmdlc3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZmluaXNoLCBzbyBza2lwIGFoZWFkIHRvIGdlbmVyYXRpbmcgYSByZXN1bHQgZnJvbSB3aGF0IHdlIGhhdmUuXG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5QXJyWzBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZ1cnRoZXN0IGRpc3RhbmNlIHdlIGdvdCBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSBmdXJ0aGVzdE9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBmdXJ0aGVzdE1vZGlmaWVkSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoTGVuZ3RoT2ZMb25nZXN0ID4gMCAmJiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgPiAwICYmIG51bURpZmZlcmVuY2VzIDw9IChNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbm91Z2ggb2YgdGhlIGhpc3RvcnkgaXMgaW4gbWVtb3J5IHRvIHdhbGsgaXQgYmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZGlkbid0IGFjdHVhbGx5IHJlbWVtYmVyIGVub3VnaCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgICAgICAgICAgICAgICAgLy9TaW5jZSB3ZSBhcmUgcXVpdGluZyB0aGUgZGlmZiBlYXJseSwgd2UgbmVlZCB0byBzaGlmdCBiYWNrIHRoZSBvcmlnaW5hbFN0YXJ0IGFuZCBtb2RpZmllZCBzdGFydFxuICAgICAgICAgICAgICAgICAgICAvL2JhY2sgaW50byB0aGUgYm91bmRhcnkgbGltaXRzIHNpbmNlIHdlIGRlY3JlbWVudGVkIHRoZWlyIHZhbHVlIGFib3ZlIGJleW9uZCB0aGUgYm91bmRhcnkgbGltaXQuXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZGlhZ29uYWxSZXZlcnNlRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZm9yIChkaWFnb25hbCA9IGRpYWdvbmFsUmV2ZXJzZVN0YXJ0OyBkaWFnb25hbCA8PSBkaWFnb25hbFJldmVyc2VFbmQ7IGRpYWdvbmFsICs9IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDE6IFdlIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICAvLyBieSBsb29raW5nIGF0IHRoZSBkaWFnb25hbHMgYWJvdmUgYW5kIGJlbG93IGFuZCBwaWNraW5nIHRoZSBvbmUgd2hvc2UgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgc3RhcnQgcG9pbnQgKG9yaWdpbmFsRW5kLCBtb2RpZmllZEVuZClcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsUmV2ZXJzZVN0YXJ0IHx8IChkaWFnb25hbCA8IGRpYWdvbmFsUmV2ZXJzZUVuZCAmJiByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV0gPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gKGRpYWdvbmFsIC0gZGlhZ29uYWxSZXZlcnNlQmFzZSkgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBvcmlnaW5hbEluZGV4IHNvIHdlIGNhbiB0ZXN0IGZvciBmYWxzZSBvdmVybGFwXG4gICAgICAgICAgICAgICAgdGVtcE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIFNURVAgMjogV2UgY2FuIGNvbnRpbnVlIHRvIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICAvLyBhcyBsb25nIGFzIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsSW5kZXggPiBvcmlnaW5hbFN0YXJ0ICYmIG1vZGlmaWVkSW5kZXggPiBtb2RpZmllZFN0YXJ0ICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0gPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIFNURVAgNDogSWYgZGVsdGEgaXMgZXZlbiAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIHJldmVyc2Ugd2hlbiBkZWx0YSBpcyBldmVuKVxuICAgICAgICAgICAgICAgIC8vIGFuZCBkaWFnb25hbCBpcyBpbiB0aGUgcmFuZ2Ugb2YgZm9yd2FyZCBkaWFnb25hbHMgY29tcHV0ZWQgZm9yIG51bURpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFJc0V2ZW4gJiYgTWF0aC5hYnMoZGlhZ29uYWwgLSBkaWFnb25hbEZvcndhcmRCYXNlKSA8PSBudW1EaWZmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA8PSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBtb2RpZmllZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBPcmlnaW5hbEluZGV4ID49IGZvcndhcmRQb2ludHNbZGlhZ29uYWxdICYmIE1heERpZmZlcmVuY2VzSGlzdG9yeSA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKE1heERpZmZlcmVuY2VzSGlzdG9yeSArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQklOR08hIFdlIG92ZXJsYXBwZWQsIGFuZCB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIG1lbW9yeSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhdmUgY3VycmVudCB2ZWN0b3JzIHRvIGhpc3RvcnkgYmVmb3JlIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgaWYgKG51bURpZmZlcmVuY2VzIDw9IE1heERpZmZlcmVuY2VzSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhbGxvY2F0aW5nIHNwYWNlIGZvciBvbmUgZXh0cmEgaW50LCB3aGljaCB3ZSBmaWxsIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGRpYWdvbmFsIGJhc2UgaW5kZXhcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBBcnJheShkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDIpO1xuICAgICAgICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbEZvcndhcmRCYXNlIC0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgKyAxO1xuICAgICAgICAgICAgICAgIE15QXJyYXkuQ29weShmb3J3YXJkUG9pbnRzLCBkaWFnb25hbEZvcndhcmRTdGFydCwgdGVtcCwgMSwgZGlhZ29uYWxGb3J3YXJkRW5kIC0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZm9yd2FyZEhpc3RvcnkucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gbmV3IEFycmF5KGRpYWdvbmFsUmV2ZXJzZUVuZCAtIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ICsgMik7XG4gICAgICAgICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDE7XG4gICAgICAgICAgICAgICAgTXlBcnJheS5Db3B5KHJldmVyc2VQb2ludHMsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCB0ZW1wLCAxLCBkaWFnb25hbFJldmVyc2VFbmQgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeS5wdXNoKHRlbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gaGlzdG9yeS4gV2UganVzdCBoYXZlIHRvIGNvbnZlcnQgaXQgdG8gYSBjaGFuZ2UgbGlzdFxuICAgICAgICAvLyBOT1RFOiBUaGlzIHBhcnQgaXMgYSBiaXQgbWVzc3lcbiAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIGdpdmVuIGNoYW5nZXMgdG8gcHJvdmlkZSBhIG1vcmUgaW50dWl0aXZlIGRpZmYuXG4gICAgICogV2hpbGUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBkaWZmIG1hdGNoZXMgdGhlIGZpcnN0IGVsZW1lbnQgYWZ0ZXIgdGhlIGRpZmYsXG4gICAgICogd2Ugc2hpZnQgdGhlIGRpZmYgZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIFRoZSBsaXN0IG9mIGNoYW5nZXMgdG8gc2hpZnRcbiAgICAgKiBAcmV0dXJucyBUaGUgc2hpZnRlZCBjaGFuZ2VzXG4gICAgICovXG4gICAgTGNzRGlmZi5wcm90b3R5cGUuU2hpZnRDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG1lcmdlZERpZmZzO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBtZXJnZWREaWZmcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU2hpZnQgYWxsIHRoZSBjaGFuZ2VzIGRvd24gZmlyc3RcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbFN0b3AgPSAoaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSkgPyBjaGFuZ2VzW2kgKyAxXS5vcmlnaW5hbFN0YXJ0IDogdGhpcy5PcmlnaW5hbFNlcXVlbmNlLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZFN0b3AgPSAoaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSkgPyBjaGFuZ2VzW2kgKyAxXS5tb2RpZmllZFN0YXJ0IDogdGhpcy5Nb2RpZmllZFNlcXVlbmNlLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja09yaWdpbmFsID0gY2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoIDwgb3JpZ2luYWxTdG9wICYmXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoIDwgbW9kaWZpZWRTdG9wICYmXG4gICAgICAgICAgICAgICAgICAgICghY2hlY2tPcmlnaW5hbCB8fCB0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWNoZWNrTW9kaWZpZWQgfHwgdGhpcy5Nb2RpZmllZEVsZW1lbnRzQXJlRXF1YWwoY2hhbmdlLm1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgbmV3IGxpc3QgKHdlIGhhdmUgdG8gYnVpbGQgYSBuZXcgbGlzdCBiZWNhdXNlIHdlXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIGNoYW5nZXMgd2UgY2FuIG1lcmdlIHRvZ2V0aGVyIG5vdylcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIHZhciBtZXJnZWRDaGFuZ2VBcnIgPSBbbnVsbF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSAmJiB0aGlzLkNoYW5nZXNPdmVybGFwKGNoYW5nZXNbaV0sIGNoYW5nZXNbaSArIDFdLCBtZXJnZWRDaGFuZ2VBcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZERpZmZzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVyZ2VkQ2hhbmdlQXJyWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcyA9IHJlc3VsdDtcbiAgICAgICAgfSB3aGlsZSAobWVyZ2VkRGlmZnMpO1xuICAgICAgICAvLyBTaGlmdCBjaGFuZ2VzIGJhY2sgdXAgdW50aWwgd2UgaGl0IGVtcHR5IG9yIHdoaXRlc3BhY2Utb25seSBsaW5lc1xuICAgICAgICBmb3IgKHZhciBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTdG9wID0gMDtcbiAgICAgICAgICAgIHZhciBtb2RpZmllZFN0b3AgPSAwO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZDaGFuZ2UgPSBjaGFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9wID0gcHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RvcCA9IHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydCArIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoZWNrT3JpZ2luYWwgPSBjaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIGNoZWNrTW9kaWZpZWQgPSBjaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIGJlc3REZWx0YSA9IDA7XG4gICAgICAgICAgICB2YXIgYmVzdFNjb3JlID0gdGhpcy5fYm91bmRhcnlTY29yZShjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGRlbHRhID0gMTs7IGRlbHRhKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxTdGFydCA9IGNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gZGVsdGE7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkU3RhcnQgPSBjaGFuZ2UubW9kaWZpZWRTdGFydCAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0IDwgb3JpZ2luYWxTdG9wIHx8IG1vZGlmaWVkU3RhcnQgPCBtb2RpZmllZFN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja09yaWdpbmFsICYmICF0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZWQgJiYgIXRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2NvcmUgPSB0aGlzLl9ib3VuZGFyeVNjb3JlKG9yaWdpbmFsU3RhcnQsIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3REZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZS5vcmlnaW5hbFN0YXJ0IC09IGJlc3REZWx0YTtcbiAgICAgICAgICAgIGNoYW5nZS5tb2RpZmllZFN0YXJ0IC09IGJlc3REZWx0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9O1xuICAgIExjc0RpZmYucHJvdG90eXBlLl9PcmlnaW5hbElzQm91bmRhcnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDw9IDAgfHwgaW5kZXggPj0gdGhpcy5PcmlnaW5hbFNlcXVlbmNlLmdldExlbmd0aCgpIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC9eXFxzKiQvLnRlc3QodGhpcy5PcmlnaW5hbFNlcXVlbmNlLmdldEVsZW1lbnRIYXNoKGluZGV4KSk7XG4gICAgfTtcbiAgICBMY3NEaWZmLnByb3RvdHlwZS5fT3JpZ2luYWxSZWdpb25Jc0JvdW5kYXJ5ID0gZnVuY3Rpb24gKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxTdGFydCkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQgLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRW5kID0gb3JpZ2luYWxTdGFydCArIG9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbEVuZCAtIDEpIHx8IHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbEVuZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMY3NEaWZmLnByb3RvdHlwZS5fTW9kaWZpZWRJc0JvdW5kYXJ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID49IHRoaXMuTW9kaWZpZWRTZXF1ZW5jZS5nZXRMZW5ndGgoKSAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvXlxccyokLy50ZXN0KHRoaXMuTW9kaWZpZWRTZXF1ZW5jZS5nZXRFbGVtZW50SGFzaChpbmRleCkpO1xuICAgIH07XG4gICAgTGNzRGlmZi5wcm90b3R5cGUuX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeSA9IGZ1bmN0aW9uIChtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fTW9kaWZpZWRJc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0IC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBtb2RpZmllZEVuZCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQgLSAxKSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTGNzRGlmZi5wcm90b3R5cGUuX2JvdW5kYXJ5U2NvcmUgPSBmdW5jdGlvbiAob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFNjb3JlID0gKHRoaXMuX09yaWdpbmFsUmVnaW9uSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCkgPyAxIDogMCk7XG4gICAgICAgIHZhciBtb2RpZmllZFNjb3JlID0gKHRoaXMuX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWxTY29yZSArIG1vZGlmaWVkU2NvcmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIHRoZSB0d28gaW5wdXQgRGlmZkNoYW5nZSBsaXN0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nXG4gICAgICogbGlzdC5cbiAgICAgKiBAcGFyYW0gVGhlIGxlZnQgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBUaGUgcmlnaHQgY2hhbmdlc1xuICAgICAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgbGlzdFxuICAgICAqL1xuICAgIExjc0RpZmYucHJvdG90eXBlLkNvbmNhdGVuYXRlQ2hhbmdlcyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgbWVyZ2VkQ2hhbmdlQXJyID0gW107XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDAgfHwgcmlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJpZ2h0Lmxlbmd0aCA+IDApID8gcmlnaHQgOiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuQ2hhbmdlc092ZXJsYXAobGVmdFtsZWZ0Lmxlbmd0aCAtIDFdLCByaWdodFswXSwgbWVyZ2VkQ2hhbmdlQXJyKSkge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgYnJlYWsgdGhlIHByb2JsZW0gZG93biByZWN1cnNpdmVseSwgaXQgaXMgcG9zc2libGUgdGhhdCB3ZVxuICAgICAgICAgICAgLy8gbWlnaHQgcmVjdXJzZSBpbiB0aGUgbWlkZGxlIG9mIGEgY2hhbmdlIHRoZXJlYnkgc3BsaXR0aW5nIGl0IGludG9cbiAgICAgICAgICAgIC8vIHR3byBjaGFuZ2VzLiBIZXJlIGluIHRoZSBjb21iaW5pbmcgc3RhZ2UsIHdlIGRldGVjdCBhbmQgZnVzZSB0aG9zZVxuICAgICAgICAgICAgLy8gY2hhbmdlcyBiYWNrIHRvZ2V0aGVyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXN1bHRbbGVmdC5sZW5ndGggLSAxXSA9IG1lcmdlZENoYW5nZUFyclswXTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMSwgcmVzdWx0LCBsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMCwgcmVzdWx0LCBsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGNoYW5nZXMgb3ZlcmxhcCBhbmQgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlXG4gICAgICogY2hhbmdlXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY2hhbmdlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBjaGFuZ2VcbiAgICAgKiBAcGFyYW0gbWVyZ2VkQ2hhbmdlIFRoZSBtZXJnZWQgY2hhbmdlIGlmIHRoZSB0d28gb3ZlcmxhcCwgbnVsbCBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwXG4gICAgICovXG4gICAgTGNzRGlmZi5wcm90b3R5cGUuQ2hhbmdlc092ZXJsYXAgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIG1lcmdlZENoYW5nZUFycikge1xuICAgICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5vcmlnaW5hbFN0YXJ0IDw9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpO1xuICAgICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5tb2RpZmllZFN0YXJ0IDw9IHJpZ2h0Lm1vZGlmaWVkU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpO1xuICAgICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0IHx8IGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3RhcnQgPSBsZWZ0Lm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxMZW5ndGggPSBsZWZ0Lm9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1vZGlmaWVkU3RhcnQgPSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRMZW5ndGggPSBsZWZ0Lm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlZnQub3JpZ2luYWxTdGFydCArIGxlZnQub3JpZ2luYWxMZW5ndGggPj0gcmlnaHQub3JpZ2luYWxTdGFydCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGVuZ3RoID0gcmlnaHQub3JpZ2luYWxTdGFydCArIHJpZ2h0Lm9yaWdpbmFsTGVuZ3RoIC0gbGVmdC5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVuZ3RoID0gcmlnaHQubW9kaWZpZWRTdGFydCArIHJpZ2h0Lm1vZGlmaWVkTGVuZ3RoIC0gbGVmdC5tb2RpZmllZFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB1c2VkIHRvIGNsaXAgYSBkaWFnb25hbCBpbmRleCB0byB0aGUgcmFuZ2Ugb2YgdmFsaWRcbiAgICAgKiBkaWFnb25hbHMuIFRoaXMgYWxzbyBkZWNpZGVzIHdoZXRoZXIgb3Igbm90IHRoZSBkaWFnb25hbCBpbmRleCxcbiAgICAgKiBpZiBpdCBleGNlZWRzIHRoZSBib3VuZGFyeSwgc2hvdWxkIGJlIGNsaXBwZWQgdG8gdGhlIGJvdW5kYXJ5IG9yIGNsaXBwZWRcbiAgICAgKiBvbmUgaW5zaWRlIHRoZSBib3VuZGFyeSBkZXBlbmRpbmcgb24gdGhlIEV2ZW4vT2RkIHN0YXR1cyBvZiB0aGUgYm91bmRhcnlcbiAgICAgKiBhbmQgbnVtRGlmZmVyZW5jZXMuXG4gICAgICogQHBhcmFtIGRpYWdvbmFsIFRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgdG8gY2xpcC5cbiAgICAgKiBAcGFyYW0gbnVtRGlmZmVyZW5jZXMgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJlaW5nIGl0ZXJhdGVkIHVwb24uXG4gICAgICogQHBhcmFtIGRpYWdvbmFsQmFzZUluZGV4IFRoZSBiYXNlIHJlZmVyZW5jZSBkaWFnb25hbC5cbiAgICAgKiBAcGFyYW0gbnVtRGlhZ29uYWxzIFRoZSB0b3RhbCBudW1iZXIgb2YgZGlhZ29uYWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGlwcGVkIGRpYWdvbmFsIGluZGV4LlxuICAgICAqL1xuICAgIExjc0RpZmYucHJvdG90eXBlLkNsaXBEaWFnb25hbEJvdW5kID0gZnVuY3Rpb24gKGRpYWdvbmFsLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxCYXNlSW5kZXgsIG51bURpYWdvbmFscykge1xuICAgICAgICBpZiAoZGlhZ29uYWwgPj0gMCAmJiBkaWFnb25hbCA8IG51bURpYWdvbmFscykge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBjbGlwLCBpdHMgaW4gcmFuZ2VcbiAgICAgICAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaWFnb25hbHNCZWxvdzogVGhlIG51bWJlciBvZiBkaWFnb25hbHMgYmVsb3cgdGhlIHJlZmVyZW5jZSBkaWFnb25hbFxuICAgICAgICAvLyBkaWFnb25hbHNBYm92ZTogVGhlIG51bWJlciBvZiBkaWFnb25hbHMgYWJvdmUgdGhlIHJlZmVyZW5jZSBkaWFnb25hbFxuICAgICAgICB2YXIgZGlhZ29uYWxzQmVsb3cgPSBkaWFnb25hbEJhc2VJbmRleDtcbiAgICAgICAgdmFyIGRpYWdvbmFsc0Fib3ZlID0gbnVtRGlhZ29uYWxzIC0gZGlhZ29uYWxCYXNlSW5kZXggLSAxO1xuICAgICAgICB2YXIgZGlmZkV2ZW4gPSAobnVtRGlmZmVyZW5jZXMgJSAyID09PSAwKTtcbiAgICAgICAgaWYgKGRpYWdvbmFsIDwgMCkge1xuICAgICAgICAgICAgdmFyIGxvd2VyQm91bmRFdmVuID0gKGRpYWdvbmFsc0JlbG93ICUgMiA9PT0gMCk7XG4gICAgICAgICAgICByZXR1cm4gKGRpZmZFdmVuID09PSBsb3dlckJvdW5kRXZlbikgPyAwIDogMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1cHBlckJvdW5kRXZlbiA9IChkaWFnb25hbHNBYm92ZSAlIDIgPT09IDApO1xuICAgICAgICAgICAgcmV0dXJuIChkaWZmRXZlbiA9PT0gdXBwZXJCb3VuZEV2ZW4pID8gbnVtRGlhZ29uYWxzIC0gMSA6IG51bURpYWdvbmFscyAtIDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMY3NEaWZmO1xufSgpKTtcbmV4cG9ydCB7IExjc0RpZmYgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js ***!
  \**************************************************************************/
/*! exports provided: DiffChange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiffChange\", function() { return DiffChange; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents information about a specific difference between two sequences.\n */\nvar DiffChange = /** @class */ (function () {\n    /**\n     * Constructs a new DiffChange with the given sequence information\n     * and content.\n     */\n    function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the original sequence.\n     */\n    DiffChange.prototype.getOriginalEnd = function () {\n        return this.originalStart + this.originalLength;\n    };\n    /**\n     * The end point (exclusive) of the change in the modified sequence.\n     */\n    DiffChange.prototype.getModifiedEnd = function () {\n        return this.modifiedStart + this.modifiedLength;\n    };\n    return DiffChange;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmQ2hhbmdlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZkNoYW5nZS5qcz8xNWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBSZXByZXNlbnRzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBzZXF1ZW5jZXMuXG4gKi9cbnZhciBEaWZmQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZSB3aXRoIHRoZSBnaXZlbiBzZXF1ZW5jZSBpbmZvcm1hdGlvblxuICAgICAqIGFuZCBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKSB7XG4gICAgICAgIC8vRGVidWcuQXNzZXJ0KG9yaWdpbmFsTGVuZ3RoID4gMCB8fCBtb2RpZmllZExlbmd0aCA+IDAsIFwib3JpZ2luYWxMZW5ndGggYW5kIG1vZGlmaWVkTGVuZ3RoIGNhbm5vdCBib3RoIGJlIDw9IDBcIik7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydCA9IG9yaWdpbmFsU3RhcnQ7XG4gICAgICAgIHRoaXMub3JpZ2luYWxMZW5ndGggPSBvcmlnaW5hbExlbmd0aDtcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0ID0gbW9kaWZpZWRTdGFydDtcbiAgICAgICAgdGhpcy5tb2RpZmllZExlbmd0aCA9IG1vZGlmaWVkTGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIHBvaW50IChleGNsdXNpdmUpIG9mIHRoZSBjaGFuZ2UgaW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIERpZmZDaGFuZ2UucHJvdG90eXBlLmdldE9yaWdpbmFsRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFN0YXJ0ICsgdGhpcy5vcmlnaW5hbExlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSkgb2YgdGhlIGNoYW5nZSBpbiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgRGlmZkNoYW5nZS5wcm90b3R5cGUuZ2V0TW9kaWZpZWRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVkU3RhcnQgKyB0aGlzLm1vZGlmaWVkTGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIERpZmZDaGFuZ2U7XG59KCkpO1xuZXhwb3J0IHsgRGlmZkNoYW5nZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/errors.js ***!
  \*****************************************************************/
/*! exports provided: ErrorHandler, errorHandler, setUnexpectedErrorHandler, onUnexpectedError, onUnexpectedExternalError, transformErrorForSerialization, isPromiseCanceledError, canceled, illegalArgument, illegalState, readonly, disposed, isErrorWithActions, create, getErrorMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorHandler\", function() { return ErrorHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"errorHandler\", function() { return errorHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setUnexpectedErrorHandler\", function() { return setUnexpectedErrorHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onUnexpectedError\", function() { return onUnexpectedError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onUnexpectedExternalError\", function() { return onUnexpectedExternalError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformErrorForSerialization\", function() { return transformErrorForSerialization; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPromiseCanceledError\", function() { return isPromiseCanceledError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canceled\", function() { return canceled; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"illegalArgument\", function() { return illegalArgument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"illegalState\", function() { return illegalState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readonly\", function() { return readonly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disposed\", function() { return disposed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isErrorWithActions\", function() { return isErrorWithActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getErrorMessage\", function() { return getErrorMessage; });\n/* harmony import */ var _winjs_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./winjs.base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n// ------ BEGIN Hook up error listeners to winjs promises\nvar outstandingPromiseErrors = {};\nfunction promiseErrorHandler(e) {\n    //\n    // e.detail looks like: { exception, error, promise, handler, id, parent }\n    //\n    var details = e.detail;\n    var id = details.id;\n    // If the error has a parent promise then this is not the origination of the\n    //  error so we check if it has a handler, and if so we mark that the error\n    //  was handled by removing it from outstandingPromiseErrors\n    //\n    if (details.parent) {\n        if (details.handler && outstandingPromiseErrors) {\n            delete outstandingPromiseErrors[id];\n        }\n        return;\n    }\n    // Indicate that this error was originated and needs to be handled\n    outstandingPromiseErrors[id] = details;\n    // The first time the queue fills up this iteration, schedule a timeout to\n    // check if any errors are still unhandled.\n    if (Object.keys(outstandingPromiseErrors).length === 1) {\n        setTimeout(function () {\n            var errors = outstandingPromiseErrors;\n            outstandingPromiseErrors = {};\n            Object.keys(errors).forEach(function (errorId) {\n                var error = errors[errorId];\n                if (error.exception) {\n                    onUnexpectedError(error.exception);\n                }\n                else if (error.error) {\n                    onUnexpectedError(error.error);\n                }\n                console.log('WARNING: Promise with no error callback:' + error.id);\n                console.log(error);\n                if (error.exception) {\n                    console.log(error.exception.stack);\n                }\n            });\n        }, 0);\n    }\n}\n_winjs_base_js__WEBPACK_IMPORTED_MODULE_0__[\"TPromise\"].addEventListener('error', promiseErrorHandler);\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(function () {\n                if (e.stack) {\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    ErrorHandler.prototype.addListener = function (listener) {\n        var _this = this;\n        this.listeners.push(listener);\n        return function () {\n            _this._removeListener(listener);\n        };\n    };\n    ErrorHandler.prototype.emit = function (e) {\n        this.listeners.forEach(function (listener) {\n            listener(e);\n        });\n    };\n    ErrorHandler.prototype._removeListener = function (listener) {\n        this.listeners.splice(this.listeners.indexOf(listener), 1);\n    };\n    ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {\n        this.unexpectedErrorHandler = newUnexpectedErrorHandler;\n    };\n    ErrorHandler.prototype.getUnexpectedErrorHandler = function () {\n        return this.unexpectedErrorHandler;\n    };\n    ErrorHandler.prototype.onUnexpectedError = function (e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    };\n    // For external errors, we don't want the listeners to be called\n    ErrorHandler.prototype.onUnexpectedExternalError = function (e) {\n        this.unexpectedErrorHandler(e);\n    };\n    return ErrorHandler;\n}());\n\nvar errorHandler = new ErrorHandler();\nfunction setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n    errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\nfunction onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nfunction onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isPromiseCanceledError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nfunction transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        var name_1 = error.name, message = error.message;\n        var stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name: name_1,\n            message: message,\n            stack: stack\n        };\n    }\n    // return as is\n    return error;\n}\nvar canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nfunction isPromiseCanceledError(error) {\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\n * Returns an error that signals cancellation.\n */\nfunction canceled() {\n    var error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nfunction illegalArgument(name) {\n    if (name) {\n        return new Error(\"Illegal argument: \" + name);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nfunction illegalState(name) {\n    if (name) {\n        return new Error(\"Illegal state: \" + name);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nfunction readonly(name) {\n    return name\n        ? new Error(\"readonly property '\" + name + \" cannot be changed'\")\n        : new Error('readonly property cannot be changed');\n}\nfunction disposed(what) {\n    var result = new Error(what + \" has been disposed\");\n    result.name = 'DISPOSED';\n    return result;\n}\nfunction isErrorWithActions(obj) {\n    return obj instanceof Error && Array.isArray(obj.actions);\n}\nfunction create(message, options) {\n    if (options === void 0) { options = Object.create(null); }\n    var result = new Error(message);\n    if (options.actions) {\n        result.actions = options.actions;\n    }\n    return result;\n}\nfunction getErrorMessage(err) {\n    if (!err) {\n        return 'Error';\n    }\n    if (err.message) {\n        return err.message;\n    }\n    if (err.stack) {\n        return err.stack.split('\\n')[0];\n    }\n    return String(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXJyb3JzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2Vycm9ycy5qcz9mZGNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgVFByb21pc2UgfSBmcm9tICcuL3dpbmpzLmJhc2UuanMnO1xuLy8gLS0tLS0tIEJFR0lOIEhvb2sgdXAgZXJyb3IgbGlzdGVuZXJzIHRvIHdpbmpzIHByb21pc2VzXG52YXIgb3V0c3RhbmRpbmdQcm9taXNlRXJyb3JzID0ge307XG5mdW5jdGlvbiBwcm9taXNlRXJyb3JIYW5kbGVyKGUpIHtcbiAgICAvL1xuICAgIC8vIGUuZGV0YWlsIGxvb2tzIGxpa2U6IHsgZXhjZXB0aW9uLCBlcnJvciwgcHJvbWlzZSwgaGFuZGxlciwgaWQsIHBhcmVudCB9XG4gICAgLy9cbiAgICB2YXIgZGV0YWlscyA9IGUuZGV0YWlsO1xuICAgIHZhciBpZCA9IGRldGFpbHMuaWQ7XG4gICAgLy8gSWYgdGhlIGVycm9yIGhhcyBhIHBhcmVudCBwcm9taXNlIHRoZW4gdGhpcyBpcyBub3QgdGhlIG9yaWdpbmF0aW9uIG9mIHRoZVxuICAgIC8vICBlcnJvciBzbyB3ZSBjaGVjayBpZiBpdCBoYXMgYSBoYW5kbGVyLCBhbmQgaWYgc28gd2UgbWFyayB0aGF0IHRoZSBlcnJvclxuICAgIC8vICB3YXMgaGFuZGxlZCBieSByZW1vdmluZyBpdCBmcm9tIG91dHN0YW5kaW5nUHJvbWlzZUVycm9yc1xuICAgIC8vXG4gICAgaWYgKGRldGFpbHMucGFyZW50KSB7XG4gICAgICAgIGlmIChkZXRhaWxzLmhhbmRsZXIgJiYgb3V0c3RhbmRpbmdQcm9taXNlRXJyb3JzKSB7XG4gICAgICAgICAgICBkZWxldGUgb3V0c3RhbmRpbmdQcm9taXNlRXJyb3JzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEluZGljYXRlIHRoYXQgdGhpcyBlcnJvciB3YXMgb3JpZ2luYXRlZCBhbmQgbmVlZHMgdG8gYmUgaGFuZGxlZFxuICAgIG91dHN0YW5kaW5nUHJvbWlzZUVycm9yc1tpZF0gPSBkZXRhaWxzO1xuICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBxdWV1ZSBmaWxscyB1cCB0aGlzIGl0ZXJhdGlvbiwgc2NoZWR1bGUgYSB0aW1lb3V0IHRvXG4gICAgLy8gY2hlY2sgaWYgYW55IGVycm9ycyBhcmUgc3RpbGwgdW5oYW5kbGVkLlxuICAgIGlmIChPYmplY3Qua2V5cyhvdXRzdGFuZGluZ1Byb21pc2VFcnJvcnMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBvdXRzdGFuZGluZ1Byb21pc2VFcnJvcnM7XG4gICAgICAgICAgICBvdXRzdGFuZGluZ1Byb21pc2VFcnJvcnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVycm9ycykuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JJZCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yc1tlcnJvcklkXTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVW5leHBlY3RlZEVycm9yKGVycm9yLmV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVW5leHBlY3RlZEVycm9yKGVycm9yLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IFByb21pc2Ugd2l0aCBubyBlcnJvciBjYWxsYmFjazonICsgZXJyb3IuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLmV4Y2VwdGlvbi5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbn1cblRQcm9taXNlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcHJvbWlzZUVycm9ySGFuZGxlcik7XG4vLyBBdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IG9uIEV2ZW50RW1pdHRlciBieSBpbXBsZW1lbnRpbmcgYSBzdWJzZXQgb2YgdGhlIGludGVyZmFjZS5cbnZhciBFcnJvckhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUubWVzc2FnZSArICdcXG5cXG4nICsgZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKHRoaXMubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICB9O1xuICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuc2V0VW5leHBlY3RlZEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdVbmV4cGVjdGVkRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlciA9IG5ld1VuZXhwZWN0ZWRFcnJvckhhbmRsZXI7XG4gICAgfTtcbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmdldFVuZXhwZWN0ZWRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZXhwZWN0ZWRFcnJvckhhbmRsZXI7XG4gICAgfTtcbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLm9uVW5leHBlY3RlZEVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgfTtcbiAgICAvLyBGb3IgZXh0ZXJuYWwgZXJyb3JzLCB3ZSBkb24ndCB3YW50IHRoZSBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkXG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5vblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyKGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9ySGFuZGxlcjtcbn0oKSk7XG5leHBvcnQgeyBFcnJvckhhbmRsZXIgfTtcbmV4cG9ydCB2YXIgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcigpO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFVuZXhwZWN0ZWRFcnJvckhhbmRsZXIobmV3VW5leHBlY3RlZEVycm9ySGFuZGxlcikge1xuICAgIGVycm9ySGFuZGxlci5zZXRVbmV4cGVjdGVkRXJyb3JIYW5kbGVyKG5ld1VuZXhwZWN0ZWRFcnJvckhhbmRsZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXG4gICAgaWYgKCFpc1Byb21pc2VDYW5jZWxlZEVycm9yKGUpKSB7XG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFcnJvcihlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXG4gICAgaWYgKCFpc1Byb21pc2VDYW5jZWxlZEVycm9yKGUpKSB7XG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBlcnJvci5uYW1lLCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2t0cmFjZSB8fCBlcnJvci5zdGFjaztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpc0Vycm9yOiB0cnVlLFxuICAgICAgICAgICAgbmFtZTogbmFtZV8xLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrOiBzdGFja1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyByZXR1cm4gYXMgaXNcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgY2FuY2VsZWROYW1lID0gJ0NhbmNlbGVkJztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhIHByb21pc2UgaW4gY2FuY2VsZWQgc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZUNhbmNlbGVkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBjYW5jZWxlZE5hbWUgJiYgZXJyb3IubWVzc2FnZSA9PT0gY2FuY2VsZWROYW1lO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGVycm9yIHRoYXQgc2lnbmFscyBjYW5jZWxsYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxlZCgpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoY2FuY2VsZWROYW1lKTtcbiAgICBlcnJvci5uYW1lID0gZXJyb3IubWVzc2FnZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnQgZnVuY3Rpb24gaWxsZWdhbEFyZ3VtZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiSWxsZWdhbCBhcmd1bWVudDogXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaWxsZWdhbFN0YXRlKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgc3RhdGUnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZG9ubHkobmFtZSkge1xuICAgIHJldHVybiBuYW1lXG4gICAgICAgID8gbmV3IEVycm9yKFwicmVhZG9ubHkgcHJvcGVydHkgJ1wiICsgbmFtZSArIFwiIGNhbm5vdCBiZSBjaGFuZ2VkJ1wiKVxuICAgICAgICA6IG5ldyBFcnJvcigncmVhZG9ubHkgcHJvcGVydHkgY2Fubm90IGJlIGNoYW5nZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlZCh3aGF0KSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBFcnJvcih3aGF0ICsgXCIgaGFzIGJlZW4gZGlzcG9zZWRcIik7XG4gICAgcmVzdWx0Lm5hbWUgPSAnRElTUE9TRUQnO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcldpdGhBY3Rpb25zKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJiBBcnJheS5pc0FycmF5KG9iai5hY3Rpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGlmIChvcHRpb25zLmFjdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LmFjdGlvbnMgPSBvcHRpb25zLmFjdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycikge1xuICAgIGlmICghZXJyKSB7XG4gICAgICAgIHJldHVybiAnRXJyb3InO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBlcnIuc3RhY2suc3BsaXQoJ1xcbicpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGVycik7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/errors.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/event.js":
/*!****************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/event.js ***!
  \****************************************************************/
/*! exports provided: Event, Emitter, EventMultiplexer, fromCallback, fromPromise, toPromise, once, anyEvent, debounceEvent, EventBufferer, mapEvent, forEach, filterEvent, chain, stopwatch, buffer, echo, Relay, fromNodeEventEmitter, latch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Event\", function() { return Event; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Emitter\", function() { return Emitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventMultiplexer\", function() { return EventMultiplexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCallback\", function() { return fromCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromPromise\", function() { return fromPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toPromise\", function() { return toPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"once\", function() { return once; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anyEvent\", function() { return anyEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debounceEvent\", function() { return debounceEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventBufferer\", function() { return EventBufferer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapEvent\", function() { return mapEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterEvent\", function() { return filterEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chain\", function() { return chain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stopwatch\", function() { return stopwatch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buffer\", function() { return buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"echo\", function() { return echo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Relay\", function() { return Relay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromNodeEventEmitter\", function() { return fromNodeEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"latch\", function() { return latch; });\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./winjs.base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\");\n/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functional.js */ \"./node_modules/monaco-editor/esm/vs/base/common/functional.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _linkedList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./linkedList.js */ \"./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nvar Event;\n(function (Event) {\n    var _disposable = { dispose: function () { } };\n    Event.None = function () { return _disposable; };\n})(Event || (Event = {}));\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nvar Emitter = /** @class */ (function () {\n    function Emitter(_options) {\n        this._options = _options;\n    }\n    Object.defineProperty(Emitter.prototype, \"event\", {\n        /**\n         * For the public to allow to subscribe\n         * to events from this Emitter\n         */\n        get: function () {\n            var _this = this;\n            if (!this._event) {\n                this._event = function (listener, thisArgs, disposables) {\n                    if (!_this._listeners) {\n                        _this._listeners = new _linkedList_js__WEBPACK_IMPORTED_MODULE_4__[\"LinkedList\"]();\n                    }\n                    var firstListener = _this._listeners.isEmpty();\n                    if (firstListener && _this._options && _this._options.onFirstListenerAdd) {\n                        _this._options.onFirstListenerAdd(_this);\n                    }\n                    var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n                    if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {\n                        _this._options.onFirstListenerDidAdd(_this);\n                    }\n                    if (_this._options && _this._options.onListenerDidAdd) {\n                        _this._options.onListenerDidAdd(_this, listener, thisArgs);\n                    }\n                    var result;\n                    result = {\n                        dispose: function () {\n                            result.dispose = Emitter._noop;\n                            if (!_this._disposed) {\n                                remove();\n                                if (_this._options && _this._options.onLastListenerRemove && _this._listeners.isEmpty()) {\n                                    _this._options.onLastListenerRemove(_this);\n                                }\n                            }\n                        }\n                    };\n                    if (Array.isArray(disposables)) {\n                        disposables.push(result);\n                    }\n                    return result;\n                };\n            }\n            return this._event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    Emitter.prototype.fire = function (event) {\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = [];\n            }\n            for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n                this._deliveryQueue.push([e.value, event]);\n            }\n            while (this._deliveryQueue.length > 0) {\n                var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];\n                try {\n                    if (typeof listener === 'function') {\n                        listener.call(undefined, event_1);\n                    }\n                    else {\n                        listener[0].call(listener[1], event_1);\n                    }\n                }\n                catch (e) {\n                    Object(_errors_js__WEBPACK_IMPORTED_MODULE_3__[\"onUnexpectedError\"])(e);\n                }\n            }\n        }\n    };\n    Emitter.prototype.dispose = function () {\n        if (this._listeners) {\n            this._listeners = undefined;\n        }\n        if (this._deliveryQueue) {\n            this._deliveryQueue.length = 0;\n        }\n        this._disposed = true;\n    };\n    Emitter._noop = function () { };\n    return Emitter;\n}());\n\nvar EventMultiplexer = /** @class */ (function () {\n    function EventMultiplexer() {\n        var _this = this;\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },\n            onLastListenerRemove: function () { return _this.onLastListenerRemove(); }\n        });\n    }\n    Object.defineProperty(EventMultiplexer.prototype, \"event\", {\n        get: function () {\n            return this.emitter.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EventMultiplexer.prototype.add = function (event) {\n        var _this = this;\n        var e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        var dispose = function () {\n            if (_this.hasListeners) {\n                _this.unhook(e);\n            }\n            var idx = _this.events.indexOf(e);\n            _this.events.splice(idx, 1);\n        };\n        return Object(_lifecycle_js__WEBPACK_IMPORTED_MODULE_0__[\"toDisposable\"])(Object(_functional_js__WEBPACK_IMPORTED_MODULE_2__[\"once\"])(dispose));\n    };\n    EventMultiplexer.prototype.onFirstListenerAdd = function () {\n        var _this = this;\n        this.hasListeners = true;\n        this.events.forEach(function (e) { return _this.hook(e); });\n    };\n    EventMultiplexer.prototype.onLastListenerRemove = function () {\n        var _this = this;\n        this.hasListeners = false;\n        this.events.forEach(function (e) { return _this.unhook(e); });\n    };\n    EventMultiplexer.prototype.hook = function (e) {\n        var _this = this;\n        e.listener = e.event(function (r) { return _this.emitter.fire(r); });\n    };\n    EventMultiplexer.prototype.unhook = function (e) {\n        e.listener.dispose();\n        e.listener = null;\n    };\n    EventMultiplexer.prototype.dispose = function () {\n        this.emitter.dispose();\n    };\n    return EventMultiplexer;\n}());\n\nfunction fromCallback(fn) {\n    var listener;\n    var emitter = new Emitter({\n        onFirstListenerAdd: function () { return listener = fn(function (e) { return emitter.fire(e); }); },\n        onLastListenerRemove: function () { return listener.dispose(); }\n    });\n    return emitter.event;\n}\nfunction fromPromise(promise) {\n    var emitter = new Emitter();\n    var shouldEmit = false;\n    promise\n        .then(null, function () { return null; })\n        .then(function () {\n        if (!shouldEmit) {\n            setTimeout(function () { return emitter.fire(); }, 0);\n        }\n        else {\n            emitter.fire();\n        }\n    });\n    shouldEmit = true;\n    return emitter.event;\n}\nfunction toPromise(event) {\n    return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (complete) {\n        var sub = event(function (e) {\n            sub.dispose();\n            complete(e);\n        });\n    });\n}\nfunction once(event) {\n    return function (listener, thisArgs, disposables) {\n        if (thisArgs === void 0) { thisArgs = null; }\n        var result = event(function (e) {\n            result.dispose();\n            return listener.call(thisArgs, e);\n        }, null, disposables);\n        return result;\n    };\n}\nfunction anyEvent() {\n    var events = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        events[_i] = arguments[_i];\n    }\n    return function (listener, thisArgs, disposables) {\n        if (thisArgs === void 0) { thisArgs = null; }\n        return Object(_lifecycle_js__WEBPACK_IMPORTED_MODULE_0__[\"combinedDisposable\"])(events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));\n    };\n}\nfunction debounceEvent(event, merger, delay, leading) {\n    if (delay === void 0) { delay = 100; }\n    if (leading === void 0) { leading = false; }\n    var subscription;\n    var output = undefined;\n    var handle = undefined;\n    var numDebouncedCalls = 0;\n    var emitter = new Emitter({\n        onFirstListenerAdd: function () {\n            subscription = event(function (cur) {\n                numDebouncedCalls++;\n                output = merger(output, cur);\n                if (leading && !handle) {\n                    emitter.fire(output);\n                }\n                clearTimeout(handle);\n                handle = setTimeout(function () {\n                    var _output = output;\n                    output = undefined;\n                    handle = undefined;\n                    if (!leading || numDebouncedCalls > 1) {\n                        emitter.fire(_output);\n                    }\n                    numDebouncedCalls = 0;\n                }, delay);\n            });\n        },\n        onLastListenerRemove: function () {\n            subscription.dispose();\n        }\n    });\n    return emitter.event;\n}\n/**\n * The EventDelayer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nvar EventBufferer = /** @class */ (function () {\n    function EventBufferer() {\n        this.buffers = [];\n    }\n    EventBufferer.prototype.wrapEvent = function (event) {\n        var _this = this;\n        return function (listener, thisArgs, disposables) {\n            return event(function (i) {\n                var buffer = _this.buffers[_this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(function () { return listener.call(thisArgs, i); });\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, void 0, disposables);\n        };\n    };\n    EventBufferer.prototype.bufferEvents = function (fn) {\n        var buffer = [];\n        this.buffers.push(buffer);\n        fn();\n        this.buffers.pop();\n        buffer.forEach(function (flush) { return flush(); });\n    };\n    return EventBufferer;\n}());\n\nfunction mapEvent(event, map) {\n    return function (listener, thisArgs, disposables) {\n        if (thisArgs === void 0) { thisArgs = null; }\n        return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);\n    };\n}\nfunction forEach(event, each) {\n    return function (listener, thisArgs, disposables) {\n        if (thisArgs === void 0) { thisArgs = null; }\n        return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);\n    };\n}\nfunction filterEvent(event, filter) {\n    return function (listener, thisArgs, disposables) {\n        if (thisArgs === void 0) { thisArgs = null; }\n        return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);\n    };\n}\nvar ChainableEvent = /** @class */ (function () {\n    function ChainableEvent(_event) {\n        this._event = _event;\n    }\n    Object.defineProperty(ChainableEvent.prototype, \"event\", {\n        get: function () { return this._event; },\n        enumerable: true,\n        configurable: true\n    });\n    ChainableEvent.prototype.map = function (fn) {\n        return new ChainableEvent(mapEvent(this._event, fn));\n    };\n    ChainableEvent.prototype.forEach = function (fn) {\n        return new ChainableEvent(forEach(this._event, fn));\n    };\n    ChainableEvent.prototype.filter = function (fn) {\n        return new ChainableEvent(filterEvent(this._event, fn));\n    };\n    ChainableEvent.prototype.latch = function () {\n        return new ChainableEvent(latch(this._event));\n    };\n    ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {\n        return this._event(listener, thisArgs, disposables);\n    };\n    return ChainableEvent;\n}());\nfunction chain(event) {\n    return new ChainableEvent(event);\n}\nfunction stopwatch(event) {\n    var start = new Date().getTime();\n    return mapEvent(once(event), function (_) { return new Date().getTime() - start; });\n}\n/**\n * Buffers the provided event until a first listener comes\n * along, at which point fire all the events at once and\n * pipe the event from then on.\n *\n * ```typescript\n * const emitter = new Emitter<number>();\n * const event = emitter.event;\n * const bufferedEvent = buffer(event);\n *\n * emitter.fire(1);\n * emitter.fire(2);\n * emitter.fire(3);\n * // nothing...\n *\n * const listener = bufferedEvent(num => console.log(num));\n * // 1, 2, 3\n *\n * emitter.fire(4);\n * // 4\n * ```\n */\nfunction buffer(event, nextTick, buffer) {\n    if (nextTick === void 0) { nextTick = false; }\n    if (buffer === void 0) { buffer = []; }\n    buffer = buffer.slice();\n    var listener = event(function (e) {\n        if (buffer) {\n            buffer.push(e);\n        }\n        else {\n            emitter.fire(e);\n        }\n    });\n    var flush = function () {\n        buffer.forEach(function (e) { return emitter.fire(e); });\n        buffer = null;\n    };\n    var emitter = new Emitter({\n        onFirstListenerAdd: function () {\n            if (!listener) {\n                listener = event(function (e) { return emitter.fire(e); });\n            }\n        },\n        onFirstListenerDidAdd: function () {\n            if (buffer) {\n                if (nextTick) {\n                    setTimeout(flush);\n                }\n                else {\n                    flush();\n                }\n            }\n        },\n        onLastListenerRemove: function () {\n            listener.dispose();\n            listener = null;\n        }\n    });\n    return emitter.event;\n}\n/**\n * Similar to `buffer` but it buffers indefinitely and repeats\n * the buffered events to every new listener.\n */\nfunction echo(event, nextTick, buffer) {\n    if (nextTick === void 0) { nextTick = false; }\n    if (buffer === void 0) { buffer = []; }\n    buffer = buffer.slice();\n    event(function (e) {\n        buffer.push(e);\n        emitter.fire(e);\n    });\n    var flush = function (listener, thisArgs) { return buffer.forEach(function (e) { return listener.call(thisArgs, e); }); };\n    var emitter = new Emitter({\n        onListenerDidAdd: function (emitter, listener, thisArgs) {\n            if (nextTick) {\n                setTimeout(function () { return flush(listener, thisArgs); });\n            }\n            else {\n                flush(listener, thisArgs);\n            }\n        }\n    });\n    return emitter.event;\n}\nvar Relay = /** @class */ (function () {\n    function Relay() {\n        this.emitter = new Emitter();\n        this.event = this.emitter.event;\n        this.disposable = _lifecycle_js__WEBPACK_IMPORTED_MODULE_0__[\"empty\"];\n    }\n    Object.defineProperty(Relay.prototype, \"input\", {\n        set: function (event) {\n            this.disposable.dispose();\n            this.disposable = event(this.emitter.fire, this.emitter);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Relay.prototype.dispose = function () {\n        this.disposable.dispose();\n        this.emitter.dispose();\n    };\n    return Relay;\n}());\n\nfunction fromNodeEventEmitter(emitter, eventName, map) {\n    if (map === void 0) { map = function (id) { return id; }; }\n    var fn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return result.fire(map.apply(void 0, args));\n    };\n    var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };\n    var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };\n    var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });\n    return result.event;\n}\nfunction latch(event) {\n    var firstCall = true;\n    var cache;\n    return filterEvent(event, function (value) {\n        var shouldEmit = firstCall || value !== cache;\n        firstCall = false;\n        cache = value;\n        return shouldEmit;\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXZlbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXZlbnQuanM/MzA4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IHRvRGlzcG9zYWJsZSwgY29tYmluZWREaXNwb3NhYmxlLCBlbXB0eSBhcyBFbXB0eURpc3Bvc2FibGUgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBUUHJvbWlzZSB9IGZyb20gJy4vd2luanMuYmFzZS5qcyc7XG5pbXBvcnQgeyBvbmNlIGFzIG9uY2VGbiB9IGZyb20gJy4vZnVuY3Rpb25hbC5qcyc7XG5pbXBvcnQgeyBvblVuZXhwZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuL2xpbmtlZExpc3QuanMnO1xuZXhwb3J0IHZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICB2YXIgX2Rpc3Bvc2FibGUgPSB7IGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50IHx8IChFdmVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBFbWl0dGVyIGNhbiBiZSB1c2VkIHRvIGV4cG9zZSBhbiBFdmVudCB0byB0aGUgcHVibGljXG4gKiB0byBmaXJlIGl0IGZyb20gdGhlIGluc2lkZXMuXG4gKiBTYW1wbGU6XG4gICAgY2xhc3MgRG9jdW1lbnQge1xuXG4gICAgICAgIHByaXZhdGUgX29uRGlkQ2hhbmdlID0gbmV3IEVtaXR0ZXI8KHZhbHVlOnN0cmluZyk9PmFueT4oKTtcblxuICAgICAgICBwdWJsaWMgb25EaWRDaGFuZ2UgPSB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcblxuICAgICAgICAvLyBnZXR0ZXItc3R5bGVcbiAgICAgICAgLy8gZ2V0IG9uRGlkQ2hhbmdlKCk6IEV2ZW50PCh2YWx1ZTpzdHJpbmcpPT5hbnk+IHtcbiAgICAgICAgLy8gXHRyZXR1cm4gdGhpcy5fb25EaWRDaGFuZ2UuZXZlbnQ7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBwcml2YXRlIF9kb0l0KCkge1xuICAgICAgICAgICAgLy8uLi5cbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICovXG52YXIgRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyKF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXIucHJvdG90eXBlLCBcImV2ZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxuICAgICAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudCA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xpc3RlbmVycyA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0TGlzdGVuZXIgPSBfdGhpcy5fbGlzdGVuZXJzLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0TGlzdGVuZXIgJiYgX3RoaXMuX29wdGlvbnMgJiYgX3RoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmUgPSBfdGhpcy5fbGlzdGVuZXJzLnB1c2goIXRoaXNBcmdzID8gbGlzdGVuZXIgOiBbbGlzdGVuZXIsIHRoaXNBcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdExpc3RlbmVyICYmIF90aGlzLl9vcHRpb25zICYmIF90aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckRpZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyRGlkQWRkKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMgJiYgX3RoaXMuX29wdGlvbnMub25MaXN0ZW5lckRpZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29wdGlvbnMub25MaXN0ZW5lckRpZEFkZChfdGhpcywgbGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UgPSBFbWl0dGVyLl9ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMgJiYgX3RoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgX3RoaXMuX2xpc3RlbmVycy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcG9zYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xuICAgICAqIHN1YnNjcmliZXJzXG4gICAgICovXG4gICAgRW1pdHRlci5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAvLyBwdXQgYWxsIFtsaXN0ZW5lcixldmVudF0tcGFpcnMgaW50byBkZWxpdmVyeSBxdWV1ZVxuICAgICAgICAgICAgLy8gdGhlbiBlbWl0IGFsbCBldmVudC4gYW4gaW5uZXIvbmVzdGVkIGV2ZW50IG1pZ2h0IGJlXG4gICAgICAgICAgICAvLyB0aGUgZHJpdmVyIG9mIHRoaXNcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVsaXZlcnlRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGl0ZXIgPSB0aGlzLl9saXN0ZW5lcnMuaXRlcmF0b3IoKSwgZSA9IGl0ZXIubmV4dCgpOyAhZS5kb25lOyBlID0gaXRlci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxpdmVyeVF1ZXVlLnB1c2goW2UudmFsdWUsIGV2ZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fZGVsaXZlcnlRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5fZGVsaXZlcnlRdWV1ZS5zaGlmdCgpLCBsaXN0ZW5lciA9IF9hWzBdLCBldmVudF8xID0gX2FbMV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh1bmRlZmluZWQsIGV2ZW50XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJbMF0uY2FsbChsaXN0ZW5lclsxXSwgZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlbGl2ZXJ5UXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBFbWl0dGVyLl9ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBFbWl0dGVyO1xufSgpKTtcbmV4cG9ydCB7IEVtaXR0ZXIgfTtcbnZhciBFdmVudE11bHRpcGxleGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50TXVsdGlwbGV4ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaGFzTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckFkZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25GaXJzdExpc3RlbmVyQWRkKCk7IH0sXG4gICAgICAgICAgICBvbkxhc3RMaXN0ZW5lclJlbW92ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25MYXN0TGlzdGVuZXJSZW1vdmUoKTsgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50TXVsdGlwbGV4ZXIucHJvdG90eXBlLCBcImV2ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLmV2ZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFdmVudE11bHRpcGxleGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGUgPSB7IGV2ZW50OiBldmVudCwgbGlzdGVuZXI6IG51bGwgfTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaChlKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudW5ob29rKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkeCA9IF90aGlzLmV2ZW50cy5pbmRleE9mKGUpO1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKG9uY2VGbihkaXNwb3NlKSk7XG4gICAgfTtcbiAgICBFdmVudE11bHRpcGxleGVyLnByb3RvdHlwZS5vbkZpcnN0TGlzdGVuZXJBZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaGFzTGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuaG9vayhlKTsgfSk7XG4gICAgfTtcbiAgICBFdmVudE11bHRpcGxleGVyLnByb3RvdHlwZS5vbkxhc3RMaXN0ZW5lclJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMudW5ob29rKGUpOyB9KTtcbiAgICB9O1xuICAgIEV2ZW50TXVsdGlwbGV4ZXIucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBlLmxpc3RlbmVyID0gZS5ldmVudChmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMuZW1pdHRlci5maXJlKHIpOyB9KTtcbiAgICB9O1xuICAgIEV2ZW50TXVsdGlwbGV4ZXIucHJvdG90eXBlLnVuaG9vayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUubGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICBlLmxpc3RlbmVyID0gbnVsbDtcbiAgICB9O1xuICAgIEV2ZW50TXVsdGlwbGV4ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRNdWx0aXBsZXhlcjtcbn0oKSk7XG5leHBvcnQgeyBFdmVudE11bHRpcGxleGVyIH07XG5leHBvcnQgZnVuY3Rpb24gZnJvbUNhbGxiYWNrKGZuKSB7XG4gICAgdmFyIGxpc3RlbmVyO1xuICAgIHZhciBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICBvbkZpcnN0TGlzdGVuZXJBZGQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpc3RlbmVyID0gZm4oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVtaXR0ZXIuZmlyZShlKTsgfSk7IH0sXG4gICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0ZW5lci5kaXNwb3NlKCk7IH1cbiAgICB9KTtcbiAgICByZXR1cm4gZW1pdHRlci5ldmVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUHJvbWlzZShwcm9taXNlKSB7XG4gICAgdmFyIGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIHZhciBzaG91bGRFbWl0ID0gZmFsc2U7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvdWxkRW1pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBlbWl0dGVyLmZpcmUoKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbWl0dGVyLmZpcmUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNob3VsZEVtaXQgPSB0cnVlO1xuICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbWlzZShldmVudCkge1xuICAgIHJldHVybiBuZXcgVFByb21pc2UoZnVuY3Rpb24gKGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdWIgPSBldmVudChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc3ViLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGNvbXBsZXRlKGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGV2ZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSB7XG4gICAgICAgIGlmICh0aGlzQXJncyA9PT0gdm9pZCAwKSB7IHRoaXNBcmdzID0gbnVsbDsgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZXZlbnQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSk7XG4gICAgICAgIH0sIG51bGwsIGRpc3Bvc2FibGVzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFueUV2ZW50KCkge1xuICAgIHZhciBldmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBldmVudHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSB7XG4gICAgICAgIGlmICh0aGlzQXJncyA9PT0gdm9pZCAwKSB7IHRoaXNBcmdzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gY29tYmluZWREaXNwb3NhYmxlKGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudChmdW5jdGlvbiAoZSkgeyByZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSk7IH0sIG51bGwsIGRpc3Bvc2FibGVzKTsgfSkpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VFdmVudChldmVudCwgbWVyZ2VyLCBkZWxheSwgbGVhZGluZykge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMTAwOyB9XG4gICAgaWYgKGxlYWRpbmcgPT09IHZvaWQgMCkgeyBsZWFkaW5nID0gZmFsc2U7IH1cbiAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgIHZhciBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgbnVtRGVib3VuY2VkQ2FsbHMgPSAwO1xuICAgIHZhciBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICBvbkZpcnN0TGlzdGVuZXJBZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGV2ZW50KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgICAgICAgICAgICBudW1EZWJvdW5jZWRDYWxscysrO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1lcmdlcihvdXRwdXQsIGN1cik7XG4gICAgICAgICAgICAgICAgaWYgKGxlYWRpbmcgJiYgIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmZpcmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfb3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFkaW5nIHx8IG51bURlYm91bmNlZENhbGxzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKF9vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bURlYm91bmNlZENhbGxzID0gMDtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MYXN0TGlzdGVuZXJSZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZW1pdHRlci5ldmVudDtcbn1cbi8qKlxuICogVGhlIEV2ZW50RGVsYXllciBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyBpbiB3aGljaCB5b3Ugd2FudFxuICogdG8gZGVsYXkgZmlyaW5nIHlvdXIgZXZlbnRzIGR1cmluZyBzb21lIGNvZGUuXG4gKiBZb3UgY2FuIHdyYXAgdGhhdCBjb2RlIGFuZCBiZSBzdXJlIHRoYXQgdGhlIGV2ZW50IHdpbGwgbm90XG4gKiBiZSBmaXJlZCBkdXJpbmcgdGhhdCB3cmFwLlxuICpcbiAqIGBgYFxuICogY29uc3QgZW1pdHRlcjogRW1pdHRlcjtcbiAqIGNvbnN0IGRlbGF5ZXIgPSBuZXcgRXZlbnREZWxheWVyKCk7XG4gKiBjb25zdCBkZWxheWVkRXZlbnQgPSBkZWxheWVyLndyYXBFdmVudChlbWl0dGVyLmV2ZW50KTtcbiAqXG4gKiBkZWxheWVkRXZlbnQoY29uc29sZS5sb2cpO1xuICpcbiAqIGRlbGF5ZXIuYnVmZmVyRXZlbnRzKCgpID0+IHtcbiAqICAgZW1pdHRlci5maXJlKCk7IC8vIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIHlldFxuICogfSk7XG4gKlxuICogLy8gZXZlbnQgd2lsbCBvbmx5IGJlIGZpcmVkIGF0IHRoaXMgcG9pbnRcbiAqIGBgYFxuICovXG52YXIgRXZlbnRCdWZmZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEJ1ZmZlcmVyKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG4gICAgRXZlbnRCdWZmZXJlci5wcm90b3R5cGUud3JhcEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50KGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IF90aGlzLmJ1ZmZlcnNbX3RoaXMuYnVmZmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHZvaWQgMCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRXZlbnRCdWZmZXJlci5wcm90b3R5cGUuYnVmZmVyRXZlbnRzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnBvcCgpO1xuICAgICAgICBidWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZmx1c2gpIHsgcmV0dXJuIGZsdXNoKCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50QnVmZmVyZXI7XG59KCkpO1xuZXhwb3J0IHsgRXZlbnRCdWZmZXJlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEV2ZW50KGV2ZW50LCBtYXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXNBcmdzID09PSB2b2lkIDApIHsgdGhpc0FyZ3MgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBldmVudChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgbWFwKGkpKTsgfSwgbnVsbCwgZGlzcG9zYWJsZXMpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChldmVudCwgZWFjaCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykge1xuICAgICAgICBpZiAodGhpc0FyZ3MgPT09IHZvaWQgMCkgeyB0aGlzQXJncyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIGV2ZW50KGZ1bmN0aW9uIChpKSB7IGVhY2goaSk7IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpOyB9LCBudWxsLCBkaXNwb3NhYmxlcyk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJFdmVudChldmVudCwgZmlsdGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSB7XG4gICAgICAgIGlmICh0aGlzQXJncyA9PT0gdm9pZCAwKSB7IHRoaXNBcmdzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gZXZlbnQoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGZpbHRlcihlKSAmJiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKTsgfSwgbnVsbCwgZGlzcG9zYWJsZXMpO1xuICAgIH07XG59XG52YXIgQ2hhaW5hYmxlRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhaW5hYmxlRXZlbnQoX2V2ZW50KSB7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gX2V2ZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhaW5hYmxlRXZlbnQucHJvdG90eXBlLCBcImV2ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ldmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2hhaW5hYmxlRXZlbnQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KG1hcEV2ZW50KHRoaXMuX2V2ZW50LCBmbikpO1xuICAgIH07XG4gICAgQ2hhaW5hYmxlRXZlbnQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChmb3JFYWNoKHRoaXMuX2V2ZW50LCBmbikpO1xuICAgIH07XG4gICAgQ2hhaW5hYmxlRXZlbnQucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGZpbHRlckV2ZW50KHRoaXMuX2V2ZW50LCBmbikpO1xuICAgIH07XG4gICAgQ2hhaW5hYmxlRXZlbnQucHJvdG90eXBlLmxhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGxhdGNoKHRoaXMuX2V2ZW50KSk7XG4gICAgfTtcbiAgICBDaGFpbmFibGVFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhaW5hYmxlRXZlbnQ7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGNoYWluKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChldmVudCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RvcHdhdGNoKGV2ZW50KSB7XG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIG1hcEV2ZW50KG9uY2UoZXZlbnQpLCBmdW5jdGlvbiAoXykgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydDsgfSk7XG59XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHByb3ZpZGVkIGV2ZW50IHVudGlsIGEgZmlyc3QgbGlzdGVuZXIgY29tZXNcbiAqIGFsb25nLCBhdCB3aGljaCBwb2ludCBmaXJlIGFsbCB0aGUgZXZlbnRzIGF0IG9uY2UgYW5kXG4gKiBwaXBlIHRoZSBldmVudCBmcm9tIHRoZW4gb24uXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyPG51bWJlcj4oKTtcbiAqIGNvbnN0IGV2ZW50ID0gZW1pdHRlci5ldmVudDtcbiAqIGNvbnN0IGJ1ZmZlcmVkRXZlbnQgPSBidWZmZXIoZXZlbnQpO1xuICpcbiAqIGVtaXR0ZXIuZmlyZSgxKTtcbiAqIGVtaXR0ZXIuZmlyZSgyKTtcbiAqIGVtaXR0ZXIuZmlyZSgzKTtcbiAqIC8vIG5vdGhpbmcuLi5cbiAqXG4gKiBjb25zdCBsaXN0ZW5lciA9IGJ1ZmZlcmVkRXZlbnQobnVtID0+IGNvbnNvbGUubG9nKG51bSkpO1xuICogLy8gMSwgMiwgM1xuICpcbiAqIGVtaXR0ZXIuZmlyZSg0KTtcbiAqIC8vIDRcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyKGV2ZW50LCBuZXh0VGljaywgYnVmZmVyKSB7XG4gICAgaWYgKG5leHRUaWNrID09PSB2b2lkIDApIHsgbmV4dFRpY2sgPSBmYWxzZTsgfVxuICAgIGlmIChidWZmZXIgPT09IHZvaWQgMCkgeyBidWZmZXIgPSBbXTsgfVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgpO1xuICAgIHZhciBsaXN0ZW5lciA9IGV2ZW50KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW1pdHRlci5maXJlKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBidWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZW1pdHRlci5maXJlKGUpOyB9KTtcbiAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICBvbkZpcnN0TGlzdGVuZXJBZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGZ1bmN0aW9uIChlKSB7IHJldHVybiBlbWl0dGVyLmZpcmUoZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkZpcnN0TGlzdGVuZXJEaWRBZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25MYXN0TGlzdGVuZXJSZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIGBidWZmZXJgIGJ1dCBpdCBidWZmZXJzIGluZGVmaW5pdGVseSBhbmQgcmVwZWF0c1xuICogdGhlIGJ1ZmZlcmVkIGV2ZW50cyB0byBldmVyeSBuZXcgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlY2hvKGV2ZW50LCBuZXh0VGljaywgYnVmZmVyKSB7XG4gICAgaWYgKG5leHRUaWNrID09PSB2b2lkIDApIHsgbmV4dFRpY2sgPSBmYWxzZTsgfVxuICAgIGlmIChidWZmZXIgPT09IHZvaWQgMCkgeyBidWZmZXIgPSBbXTsgfVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgpO1xuICAgIGV2ZW50KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGUpO1xuICAgICAgICBlbWl0dGVyLmZpcmUoZSk7XG4gICAgfSk7XG4gICAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKGxpc3RlbmVyLCB0aGlzQXJncykgeyByZXR1cm4gYnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGUpOyB9KTsgfTtcbiAgICB2YXIgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgb25MaXN0ZW5lckRpZEFkZDogZnVuY3Rpb24gKGVtaXR0ZXIsIGxpc3RlbmVyLCB0aGlzQXJncykge1xuICAgICAgICAgICAgaWYgKG5leHRUaWNrKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBmbHVzaChsaXN0ZW5lciwgdGhpc0FyZ3MpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdXNoKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZW1pdHRlci5ldmVudDtcbn1cbnZhciBSZWxheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWxheSgpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ldmVudCA9IHRoaXMuZW1pdHRlci5ldmVudDtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlID0gRW1wdHlEaXNwb3NhYmxlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVsYXkucHJvdG90eXBlLCBcImlucHV0XCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGUgPSBldmVudCh0aGlzLmVtaXR0ZXIuZmlyZSwgdGhpcy5lbWl0dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUmVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVsYXk7XG59KCkpO1xuZXhwb3J0IHsgUmVsYXkgfTtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tTm9kZUV2ZW50RW1pdHRlcihlbWl0dGVyLCBldmVudE5hbWUsIG1hcCkge1xuICAgIGlmIChtYXAgPT09IHZvaWQgMCkgeyBtYXAgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkOyB9OyB9XG4gICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZmlyZShtYXAuYXBwbHkodm9pZCAwLCBhcmdzKSk7XG4gICAgfTtcbiAgICB2YXIgb25GaXJzdExpc3RlbmVyQWRkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZW1pdHRlci5vbihldmVudE5hbWUsIGZuKTsgfTtcbiAgICB2YXIgb25MYXN0TGlzdGVuZXJSZW1vdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgZm4pOyB9O1xuICAgIHZhciByZXN1bHQgPSBuZXcgRW1pdHRlcih7IG9uRmlyc3RMaXN0ZW5lckFkZDogb25GaXJzdExpc3RlbmVyQWRkLCBvbkxhc3RMaXN0ZW5lclJlbW92ZTogb25MYXN0TGlzdGVuZXJSZW1vdmUgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5ldmVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsYXRjaChldmVudCkge1xuICAgIHZhciBmaXJzdENhbGwgPSB0cnVlO1xuICAgIHZhciBjYWNoZTtcbiAgICByZXR1cm4gZmlsdGVyRXZlbnQoZXZlbnQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2hvdWxkRW1pdCA9IGZpcnN0Q2FsbCB8fCB2YWx1ZSAhPT0gY2FjaGU7XG4gICAgICAgIGZpcnN0Q2FsbCA9IGZhbHNlO1xuICAgICAgICBjYWNoZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gc2hvdWxkRW1pdDtcbiAgICB9KTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/event.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/functional.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/functional.js ***!
  \*********************************************************************/
/*! exports provided: once */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"once\", function() { return once; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nfunction once(fn) {\n    var _this = this;\n    var didCall = false;\n    var result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        result = fn.apply(_this, arguments);\n        return result;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZnVuY3Rpb25hbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9mdW5jdGlvbmFsLmpzPzBiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGRpZENhbGwgPSBmYWxzZTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkaWRDYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/functional.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js ***!
  \*******************************************************************/
/*! exports provided: KeyCodeUtils, KeyChord, createKeybinding, createSimpleKeybinding, SimpleKeybinding, ChordKeybinding, ResolvedKeybindingPart, ResolvedKeybinding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyCodeUtils\", function() { return KeyCodeUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyChord\", function() { return KeyChord; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createKeybinding\", function() { return createKeybinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createSimpleKeybinding\", function() { return createSimpleKeybinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleKeybinding\", function() { return SimpleKeybinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChordKeybinding\", function() { return ChordKeybinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolvedKeybindingPart\", function() { return ResolvedKeybindingPart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolvedKeybinding\", function() { return ResolvedKeybinding; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar KeyCodeStrMap = /** @class */ (function () {\n    function KeyCodeStrMap() {\n        this._keyCodeToStr = [];\n        this._strToKeyCode = Object.create(null);\n    }\n    KeyCodeStrMap.prototype.define = function (keyCode, str) {\n        this._keyCodeToStr[keyCode] = str;\n        this._strToKeyCode[str.toLowerCase()] = keyCode;\n    };\n    KeyCodeStrMap.prototype.keyCodeToStr = function (keyCode) {\n        return this._keyCodeToStr[keyCode];\n    };\n    KeyCodeStrMap.prototype.strToKeyCode = function (str) {\n        return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;\n    };\n    return KeyCodeStrMap;\n}());\nvar uiMap = new KeyCodeStrMap();\nvar userSettingsUSMap = new KeyCodeStrMap();\nvar userSettingsGeneralMap = new KeyCodeStrMap();\n(function () {\n    function define(keyCode, uiLabel, usUserSettingsLabel, generalUserSettingsLabel) {\n        if (usUserSettingsLabel === void 0) { usUserSettingsLabel = uiLabel; }\n        if (generalUserSettingsLabel === void 0) { generalUserSettingsLabel = usUserSettingsLabel; }\n        uiMap.define(keyCode, uiLabel);\n        userSettingsUSMap.define(keyCode, usUserSettingsLabel);\n        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);\n    }\n    define(0 /* Unknown */, 'unknown');\n    define(1 /* Backspace */, 'Backspace');\n    define(2 /* Tab */, 'Tab');\n    define(3 /* Enter */, 'Enter');\n    define(4 /* Shift */, 'Shift');\n    define(5 /* Ctrl */, 'Ctrl');\n    define(6 /* Alt */, 'Alt');\n    define(7 /* PauseBreak */, 'PauseBreak');\n    define(8 /* CapsLock */, 'CapsLock');\n    define(9 /* Escape */, 'Escape');\n    define(10 /* Space */, 'Space');\n    define(11 /* PageUp */, 'PageUp');\n    define(12 /* PageDown */, 'PageDown');\n    define(13 /* End */, 'End');\n    define(14 /* Home */, 'Home');\n    define(15 /* LeftArrow */, 'LeftArrow', 'Left');\n    define(16 /* UpArrow */, 'UpArrow', 'Up');\n    define(17 /* RightArrow */, 'RightArrow', 'Right');\n    define(18 /* DownArrow */, 'DownArrow', 'Down');\n    define(19 /* Insert */, 'Insert');\n    define(20 /* Delete */, 'Delete');\n    define(21 /* KEY_0 */, '0');\n    define(22 /* KEY_1 */, '1');\n    define(23 /* KEY_2 */, '2');\n    define(24 /* KEY_3 */, '3');\n    define(25 /* KEY_4 */, '4');\n    define(26 /* KEY_5 */, '5');\n    define(27 /* KEY_6 */, '6');\n    define(28 /* KEY_7 */, '7');\n    define(29 /* KEY_8 */, '8');\n    define(30 /* KEY_9 */, '9');\n    define(31 /* KEY_A */, 'A');\n    define(32 /* KEY_B */, 'B');\n    define(33 /* KEY_C */, 'C');\n    define(34 /* KEY_D */, 'D');\n    define(35 /* KEY_E */, 'E');\n    define(36 /* KEY_F */, 'F');\n    define(37 /* KEY_G */, 'G');\n    define(38 /* KEY_H */, 'H');\n    define(39 /* KEY_I */, 'I');\n    define(40 /* KEY_J */, 'J');\n    define(41 /* KEY_K */, 'K');\n    define(42 /* KEY_L */, 'L');\n    define(43 /* KEY_M */, 'M');\n    define(44 /* KEY_N */, 'N');\n    define(45 /* KEY_O */, 'O');\n    define(46 /* KEY_P */, 'P');\n    define(47 /* KEY_Q */, 'Q');\n    define(48 /* KEY_R */, 'R');\n    define(49 /* KEY_S */, 'S');\n    define(50 /* KEY_T */, 'T');\n    define(51 /* KEY_U */, 'U');\n    define(52 /* KEY_V */, 'V');\n    define(53 /* KEY_W */, 'W');\n    define(54 /* KEY_X */, 'X');\n    define(55 /* KEY_Y */, 'Y');\n    define(56 /* KEY_Z */, 'Z');\n    define(57 /* Meta */, 'Meta');\n    define(58 /* ContextMenu */, 'ContextMenu');\n    define(59 /* F1 */, 'F1');\n    define(60 /* F2 */, 'F2');\n    define(61 /* F3 */, 'F3');\n    define(62 /* F4 */, 'F4');\n    define(63 /* F5 */, 'F5');\n    define(64 /* F6 */, 'F6');\n    define(65 /* F7 */, 'F7');\n    define(66 /* F8 */, 'F8');\n    define(67 /* F9 */, 'F9');\n    define(68 /* F10 */, 'F10');\n    define(69 /* F11 */, 'F11');\n    define(70 /* F12 */, 'F12');\n    define(71 /* F13 */, 'F13');\n    define(72 /* F14 */, 'F14');\n    define(73 /* F15 */, 'F15');\n    define(74 /* F16 */, 'F16');\n    define(75 /* F17 */, 'F17');\n    define(76 /* F18 */, 'F18');\n    define(77 /* F19 */, 'F19');\n    define(78 /* NumLock */, 'NumLock');\n    define(79 /* ScrollLock */, 'ScrollLock');\n    define(80 /* US_SEMICOLON */, ';', ';', 'OEM_1');\n    define(81 /* US_EQUAL */, '=', '=', 'OEM_PLUS');\n    define(82 /* US_COMMA */, ',', ',', 'OEM_COMMA');\n    define(83 /* US_MINUS */, '-', '-', 'OEM_MINUS');\n    define(84 /* US_DOT */, '.', '.', 'OEM_PERIOD');\n    define(85 /* US_SLASH */, '/', '/', 'OEM_2');\n    define(86 /* US_BACKTICK */, '`', '`', 'OEM_3');\n    define(110 /* ABNT_C1 */, 'ABNT_C1');\n    define(111 /* ABNT_C2 */, 'ABNT_C2');\n    define(87 /* US_OPEN_SQUARE_BRACKET */, '[', '[', 'OEM_4');\n    define(88 /* US_BACKSLASH */, '\\\\', '\\\\', 'OEM_5');\n    define(89 /* US_CLOSE_SQUARE_BRACKET */, ']', ']', 'OEM_6');\n    define(90 /* US_QUOTE */, '\\'', '\\'', 'OEM_7');\n    define(91 /* OEM_8 */, 'OEM_8');\n    define(92 /* OEM_102 */, 'OEM_102');\n    define(93 /* NUMPAD_0 */, 'NumPad0');\n    define(94 /* NUMPAD_1 */, 'NumPad1');\n    define(95 /* NUMPAD_2 */, 'NumPad2');\n    define(96 /* NUMPAD_3 */, 'NumPad3');\n    define(97 /* NUMPAD_4 */, 'NumPad4');\n    define(98 /* NUMPAD_5 */, 'NumPad5');\n    define(99 /* NUMPAD_6 */, 'NumPad6');\n    define(100 /* NUMPAD_7 */, 'NumPad7');\n    define(101 /* NUMPAD_8 */, 'NumPad8');\n    define(102 /* NUMPAD_9 */, 'NumPad9');\n    define(103 /* NUMPAD_MULTIPLY */, 'NumPad_Multiply');\n    define(104 /* NUMPAD_ADD */, 'NumPad_Add');\n    define(105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator');\n    define(106 /* NUMPAD_SUBTRACT */, 'NumPad_Subtract');\n    define(107 /* NUMPAD_DECIMAL */, 'NumPad_Decimal');\n    define(108 /* NUMPAD_DIVIDE */, 'NumPad_Divide');\n})();\nvar KeyCodeUtils;\n(function (KeyCodeUtils) {\n    function toString(keyCode) {\n        return uiMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toString = toString;\n    function fromString(key) {\n        return uiMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromString = fromString;\n    function toUserSettingsUS(keyCode) {\n        return userSettingsUSMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;\n    function toUserSettingsGeneral(keyCode) {\n        return userSettingsGeneralMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;\n    function fromUserSettings(key) {\n        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromUserSettings = fromUserSettings;\n})(KeyCodeUtils || (KeyCodeUtils = {}));\nfunction KeyChord(firstPart, secondPart) {\n    var chordPart = ((secondPart & 0x0000ffff) << 16) >>> 0;\n    return (firstPart | chordPart) >>> 0;\n}\nfunction createKeybinding(keybinding, OS) {\n    if (keybinding === 0) {\n        return null;\n    }\n    var firstPart = (keybinding & 0x0000ffff) >>> 0;\n    var chordPart = (keybinding & 0xffff0000) >>> 16;\n    if (chordPart !== 0) {\n        return new ChordKeybinding(createSimpleKeybinding(firstPart, OS), createSimpleKeybinding(chordPart, OS));\n    }\n    return createSimpleKeybinding(firstPart, OS);\n}\nfunction createSimpleKeybinding(keybinding, OS) {\n    var ctrlCmd = (keybinding & 2048 /* CtrlCmd */ ? true : false);\n    var winCtrl = (keybinding & 256 /* WinCtrl */ ? true : false);\n    var ctrlKey = (OS === 2 /* Macintosh */ ? winCtrl : ctrlCmd);\n    var shiftKey = (keybinding & 1024 /* Shift */ ? true : false);\n    var altKey = (keybinding & 512 /* Alt */ ? true : false);\n    var metaKey = (OS === 2 /* Macintosh */ ? ctrlCmd : winCtrl);\n    var keyCode = (keybinding & 255 /* KeyCode */);\n    return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);\n}\nvar SimpleKeybinding = /** @class */ (function () {\n    function SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode) {\n        this.type = 1 /* Simple */;\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.keyCode = keyCode;\n    }\n    SimpleKeybinding.prototype.equals = function (other) {\n        if (other.type !== 1 /* Simple */) {\n            return false;\n        }\n        return (this.ctrlKey === other.ctrlKey\n            && this.shiftKey === other.shiftKey\n            && this.altKey === other.altKey\n            && this.metaKey === other.metaKey\n            && this.keyCode === other.keyCode);\n    };\n    SimpleKeybinding.prototype.getHashCode = function () {\n        var ctrl = this.ctrlKey ? '1' : '0';\n        var shift = this.shiftKey ? '1' : '0';\n        var alt = this.altKey ? '1' : '0';\n        var meta = this.metaKey ? '1' : '0';\n        return \"\" + ctrl + shift + alt + meta + this.keyCode;\n    };\n    SimpleKeybinding.prototype.isModifierKey = function () {\n        return (this.keyCode === 0 /* Unknown */\n            || this.keyCode === 5 /* Ctrl */\n            || this.keyCode === 57 /* Meta */\n            || this.keyCode === 6 /* Alt */\n            || this.keyCode === 4 /* Shift */);\n    };\n    /**\n     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\n     */\n    SimpleKeybinding.prototype.isDuplicateModifierCase = function () {\n        return ((this.ctrlKey && this.keyCode === 5 /* Ctrl */)\n            || (this.shiftKey && this.keyCode === 4 /* Shift */)\n            || (this.altKey && this.keyCode === 6 /* Alt */)\n            || (this.metaKey && this.keyCode === 57 /* Meta */));\n    };\n    return SimpleKeybinding;\n}());\n\nvar ChordKeybinding = /** @class */ (function () {\n    function ChordKeybinding(firstPart, chordPart) {\n        this.type = 2 /* Chord */;\n        this.firstPart = firstPart;\n        this.chordPart = chordPart;\n    }\n    ChordKeybinding.prototype.getHashCode = function () {\n        return this.firstPart.getHashCode() + \";\" + this.chordPart.getHashCode();\n    };\n    return ChordKeybinding;\n}());\n\nvar ResolvedKeybindingPart = /** @class */ (function () {\n    function ResolvedKeybindingPart(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.metaKey = metaKey;\n        this.keyLabel = kbLabel;\n        this.keyAriaLabel = kbAriaLabel;\n    }\n    return ResolvedKeybindingPart;\n}());\n\n/**\n * A resolved keybinding. Can be a simple keybinding or a chord keybinding.\n */\nvar ResolvedKeybinding = /** @class */ (function () {\n    function ResolvedKeybinding() {\n    }\n    return ResolvedKeybinding;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24va2V5Q29kZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24va2V5Q29kZXMuanM/ZmU0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbnZhciBLZXlDb2RlU3RyTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleUNvZGVTdHJNYXAoKSB7XG4gICAgICAgIHRoaXMuX2tleUNvZGVUb1N0ciA9IFtdO1xuICAgICAgICB0aGlzLl9zdHJUb0tleUNvZGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBLZXlDb2RlU3RyTWFwLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAoa2V5Q29kZSwgc3RyKSB7XG4gICAgICAgIHRoaXMuX2tleUNvZGVUb1N0cltrZXlDb2RlXSA9IHN0cjtcbiAgICAgICAgdGhpcy5fc3RyVG9LZXlDb2RlW3N0ci50b0xvd2VyQ2FzZSgpXSA9IGtleUNvZGU7XG4gICAgfTtcbiAgICBLZXlDb2RlU3RyTWFwLnByb3RvdHlwZS5rZXlDb2RlVG9TdHIgPSBmdW5jdGlvbiAoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdO1xuICAgIH07XG4gICAgS2V5Q29kZVN0ck1hcC5wcm90b3R5cGUuc3RyVG9LZXlDb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyVG9LZXlDb2RlW3N0ci50b0xvd2VyQ2FzZSgpXSB8fCAwIC8qIFVua25vd24gKi87XG4gICAgfTtcbiAgICByZXR1cm4gS2V5Q29kZVN0ck1hcDtcbn0oKSk7XG52YXIgdWlNYXAgPSBuZXcgS2V5Q29kZVN0ck1hcCgpO1xudmFyIHVzZXJTZXR0aW5nc1VTTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcbnZhciB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lKGtleUNvZGUsIHVpTGFiZWwsIHVzVXNlclNldHRpbmdzTGFiZWwsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbCkge1xuICAgICAgICBpZiAodXNVc2VyU2V0dGluZ3NMYWJlbCA9PT0gdm9pZCAwKSB7IHVzVXNlclNldHRpbmdzTGFiZWwgPSB1aUxhYmVsOyB9XG4gICAgICAgIGlmIChnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwgPT09IHZvaWQgMCkgeyBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwgPSB1c1VzZXJTZXR0aW5nc0xhYmVsOyB9XG4gICAgICAgIHVpTWFwLmRlZmluZShrZXlDb2RlLCB1aUxhYmVsKTtcbiAgICAgICAgdXNlclNldHRpbmdzVVNNYXAuZGVmaW5lKGtleUNvZGUsIHVzVXNlclNldHRpbmdzTGFiZWwpO1xuICAgICAgICB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmRlZmluZShrZXlDb2RlLCBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwpO1xuICAgIH1cbiAgICBkZWZpbmUoMCAvKiBVbmtub3duICovLCAndW5rbm93bicpO1xuICAgIGRlZmluZSgxIC8qIEJhY2tzcGFjZSAqLywgJ0JhY2tzcGFjZScpO1xuICAgIGRlZmluZSgyIC8qIFRhYiAqLywgJ1RhYicpO1xuICAgIGRlZmluZSgzIC8qIEVudGVyICovLCAnRW50ZXInKTtcbiAgICBkZWZpbmUoNCAvKiBTaGlmdCAqLywgJ1NoaWZ0Jyk7XG4gICAgZGVmaW5lKDUgLyogQ3RybCAqLywgJ0N0cmwnKTtcbiAgICBkZWZpbmUoNiAvKiBBbHQgKi8sICdBbHQnKTtcbiAgICBkZWZpbmUoNyAvKiBQYXVzZUJyZWFrICovLCAnUGF1c2VCcmVhaycpO1xuICAgIGRlZmluZSg4IC8qIENhcHNMb2NrICovLCAnQ2Fwc0xvY2snKTtcbiAgICBkZWZpbmUoOSAvKiBFc2NhcGUgKi8sICdFc2NhcGUnKTtcbiAgICBkZWZpbmUoMTAgLyogU3BhY2UgKi8sICdTcGFjZScpO1xuICAgIGRlZmluZSgxMSAvKiBQYWdlVXAgKi8sICdQYWdlVXAnKTtcbiAgICBkZWZpbmUoMTIgLyogUGFnZURvd24gKi8sICdQYWdlRG93bicpO1xuICAgIGRlZmluZSgxMyAvKiBFbmQgKi8sICdFbmQnKTtcbiAgICBkZWZpbmUoMTQgLyogSG9tZSAqLywgJ0hvbWUnKTtcbiAgICBkZWZpbmUoMTUgLyogTGVmdEFycm93ICovLCAnTGVmdEFycm93JywgJ0xlZnQnKTtcbiAgICBkZWZpbmUoMTYgLyogVXBBcnJvdyAqLywgJ1VwQXJyb3cnLCAnVXAnKTtcbiAgICBkZWZpbmUoMTcgLyogUmlnaHRBcnJvdyAqLywgJ1JpZ2h0QXJyb3cnLCAnUmlnaHQnKTtcbiAgICBkZWZpbmUoMTggLyogRG93bkFycm93ICovLCAnRG93bkFycm93JywgJ0Rvd24nKTtcbiAgICBkZWZpbmUoMTkgLyogSW5zZXJ0ICovLCAnSW5zZXJ0Jyk7XG4gICAgZGVmaW5lKDIwIC8qIERlbGV0ZSAqLywgJ0RlbGV0ZScpO1xuICAgIGRlZmluZSgyMSAvKiBLRVlfMCAqLywgJzAnKTtcbiAgICBkZWZpbmUoMjIgLyogS0VZXzEgKi8sICcxJyk7XG4gICAgZGVmaW5lKDIzIC8qIEtFWV8yICovLCAnMicpO1xuICAgIGRlZmluZSgyNCAvKiBLRVlfMyAqLywgJzMnKTtcbiAgICBkZWZpbmUoMjUgLyogS0VZXzQgKi8sICc0Jyk7XG4gICAgZGVmaW5lKDI2IC8qIEtFWV81ICovLCAnNScpO1xuICAgIGRlZmluZSgyNyAvKiBLRVlfNiAqLywgJzYnKTtcbiAgICBkZWZpbmUoMjggLyogS0VZXzcgKi8sICc3Jyk7XG4gICAgZGVmaW5lKDI5IC8qIEtFWV84ICovLCAnOCcpO1xuICAgIGRlZmluZSgzMCAvKiBLRVlfOSAqLywgJzknKTtcbiAgICBkZWZpbmUoMzEgLyogS0VZX0EgKi8sICdBJyk7XG4gICAgZGVmaW5lKDMyIC8qIEtFWV9CICovLCAnQicpO1xuICAgIGRlZmluZSgzMyAvKiBLRVlfQyAqLywgJ0MnKTtcbiAgICBkZWZpbmUoMzQgLyogS0VZX0QgKi8sICdEJyk7XG4gICAgZGVmaW5lKDM1IC8qIEtFWV9FICovLCAnRScpO1xuICAgIGRlZmluZSgzNiAvKiBLRVlfRiAqLywgJ0YnKTtcbiAgICBkZWZpbmUoMzcgLyogS0VZX0cgKi8sICdHJyk7XG4gICAgZGVmaW5lKDM4IC8qIEtFWV9IICovLCAnSCcpO1xuICAgIGRlZmluZSgzOSAvKiBLRVlfSSAqLywgJ0knKTtcbiAgICBkZWZpbmUoNDAgLyogS0VZX0ogKi8sICdKJyk7XG4gICAgZGVmaW5lKDQxIC8qIEtFWV9LICovLCAnSycpO1xuICAgIGRlZmluZSg0MiAvKiBLRVlfTCAqLywgJ0wnKTtcbiAgICBkZWZpbmUoNDMgLyogS0VZX00gKi8sICdNJyk7XG4gICAgZGVmaW5lKDQ0IC8qIEtFWV9OICovLCAnTicpO1xuICAgIGRlZmluZSg0NSAvKiBLRVlfTyAqLywgJ08nKTtcbiAgICBkZWZpbmUoNDYgLyogS0VZX1AgKi8sICdQJyk7XG4gICAgZGVmaW5lKDQ3IC8qIEtFWV9RICovLCAnUScpO1xuICAgIGRlZmluZSg0OCAvKiBLRVlfUiAqLywgJ1InKTtcbiAgICBkZWZpbmUoNDkgLyogS0VZX1MgKi8sICdTJyk7XG4gICAgZGVmaW5lKDUwIC8qIEtFWV9UICovLCAnVCcpO1xuICAgIGRlZmluZSg1MSAvKiBLRVlfVSAqLywgJ1UnKTtcbiAgICBkZWZpbmUoNTIgLyogS0VZX1YgKi8sICdWJyk7XG4gICAgZGVmaW5lKDUzIC8qIEtFWV9XICovLCAnVycpO1xuICAgIGRlZmluZSg1NCAvKiBLRVlfWCAqLywgJ1gnKTtcbiAgICBkZWZpbmUoNTUgLyogS0VZX1kgKi8sICdZJyk7XG4gICAgZGVmaW5lKDU2IC8qIEtFWV9aICovLCAnWicpO1xuICAgIGRlZmluZSg1NyAvKiBNZXRhICovLCAnTWV0YScpO1xuICAgIGRlZmluZSg1OCAvKiBDb250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51Jyk7XG4gICAgZGVmaW5lKDU5IC8qIEYxICovLCAnRjEnKTtcbiAgICBkZWZpbmUoNjAgLyogRjIgKi8sICdGMicpO1xuICAgIGRlZmluZSg2MSAvKiBGMyAqLywgJ0YzJyk7XG4gICAgZGVmaW5lKDYyIC8qIEY0ICovLCAnRjQnKTtcbiAgICBkZWZpbmUoNjMgLyogRjUgKi8sICdGNScpO1xuICAgIGRlZmluZSg2NCAvKiBGNiAqLywgJ0Y2Jyk7XG4gICAgZGVmaW5lKDY1IC8qIEY3ICovLCAnRjcnKTtcbiAgICBkZWZpbmUoNjYgLyogRjggKi8sICdGOCcpO1xuICAgIGRlZmluZSg2NyAvKiBGOSAqLywgJ0Y5Jyk7XG4gICAgZGVmaW5lKDY4IC8qIEYxMCAqLywgJ0YxMCcpO1xuICAgIGRlZmluZSg2OSAvKiBGMTEgKi8sICdGMTEnKTtcbiAgICBkZWZpbmUoNzAgLyogRjEyICovLCAnRjEyJyk7XG4gICAgZGVmaW5lKDcxIC8qIEYxMyAqLywgJ0YxMycpO1xuICAgIGRlZmluZSg3MiAvKiBGMTQgKi8sICdGMTQnKTtcbiAgICBkZWZpbmUoNzMgLyogRjE1ICovLCAnRjE1Jyk7XG4gICAgZGVmaW5lKDc0IC8qIEYxNiAqLywgJ0YxNicpO1xuICAgIGRlZmluZSg3NSAvKiBGMTcgKi8sICdGMTcnKTtcbiAgICBkZWZpbmUoNzYgLyogRjE4ICovLCAnRjE4Jyk7XG4gICAgZGVmaW5lKDc3IC8qIEYxOSAqLywgJ0YxOScpO1xuICAgIGRlZmluZSg3OCAvKiBOdW1Mb2NrICovLCAnTnVtTG9jaycpO1xuICAgIGRlZmluZSg3OSAvKiBTY3JvbGxMb2NrICovLCAnU2Nyb2xsTG9jaycpO1xuICAgIGRlZmluZSg4MCAvKiBVU19TRU1JQ09MT04gKi8sICc7JywgJzsnLCAnT0VNXzEnKTtcbiAgICBkZWZpbmUoODEgLyogVVNfRVFVQUwgKi8sICc9JywgJz0nLCAnT0VNX1BMVVMnKTtcbiAgICBkZWZpbmUoODIgLyogVVNfQ09NTUEgKi8sICcsJywgJywnLCAnT0VNX0NPTU1BJyk7XG4gICAgZGVmaW5lKDgzIC8qIFVTX01JTlVTICovLCAnLScsICctJywgJ09FTV9NSU5VUycpO1xuICAgIGRlZmluZSg4NCAvKiBVU19ET1QgKi8sICcuJywgJy4nLCAnT0VNX1BFUklPRCcpO1xuICAgIGRlZmluZSg4NSAvKiBVU19TTEFTSCAqLywgJy8nLCAnLycsICdPRU1fMicpO1xuICAgIGRlZmluZSg4NiAvKiBVU19CQUNLVElDSyAqLywgJ2AnLCAnYCcsICdPRU1fMycpO1xuICAgIGRlZmluZSgxMTAgLyogQUJOVF9DMSAqLywgJ0FCTlRfQzEnKTtcbiAgICBkZWZpbmUoMTExIC8qIEFCTlRfQzIgKi8sICdBQk5UX0MyJyk7XG4gICAgZGVmaW5lKDg3IC8qIFVTX09QRU5fU1FVQVJFX0JSQUNLRVQgKi8sICdbJywgJ1snLCAnT0VNXzQnKTtcbiAgICBkZWZpbmUoODggLyogVVNfQkFDS1NMQVNIICovLCAnXFxcXCcsICdcXFxcJywgJ09FTV81Jyk7XG4gICAgZGVmaW5lKDg5IC8qIFVTX0NMT1NFX1NRVUFSRV9CUkFDS0VUICovLCAnXScsICddJywgJ09FTV82Jyk7XG4gICAgZGVmaW5lKDkwIC8qIFVTX1FVT1RFICovLCAnXFwnJywgJ1xcJycsICdPRU1fNycpO1xuICAgIGRlZmluZSg5MSAvKiBPRU1fOCAqLywgJ09FTV84Jyk7XG4gICAgZGVmaW5lKDkyIC8qIE9FTV8xMDIgKi8sICdPRU1fMTAyJyk7XG4gICAgZGVmaW5lKDkzIC8qIE5VTVBBRF8wICovLCAnTnVtUGFkMCcpO1xuICAgIGRlZmluZSg5NCAvKiBOVU1QQURfMSAqLywgJ051bVBhZDEnKTtcbiAgICBkZWZpbmUoOTUgLyogTlVNUEFEXzIgKi8sICdOdW1QYWQyJyk7XG4gICAgZGVmaW5lKDk2IC8qIE5VTVBBRF8zICovLCAnTnVtUGFkMycpO1xuICAgIGRlZmluZSg5NyAvKiBOVU1QQURfNCAqLywgJ051bVBhZDQnKTtcbiAgICBkZWZpbmUoOTggLyogTlVNUEFEXzUgKi8sICdOdW1QYWQ1Jyk7XG4gICAgZGVmaW5lKDk5IC8qIE5VTVBBRF82ICovLCAnTnVtUGFkNicpO1xuICAgIGRlZmluZSgxMDAgLyogTlVNUEFEXzcgKi8sICdOdW1QYWQ3Jyk7XG4gICAgZGVmaW5lKDEwMSAvKiBOVU1QQURfOCAqLywgJ051bVBhZDgnKTtcbiAgICBkZWZpbmUoMTAyIC8qIE5VTVBBRF85ICovLCAnTnVtUGFkOScpO1xuICAgIGRlZmluZSgxMDMgLyogTlVNUEFEX01VTFRJUExZICovLCAnTnVtUGFkX011bHRpcGx5Jyk7XG4gICAgZGVmaW5lKDEwNCAvKiBOVU1QQURfQUREICovLCAnTnVtUGFkX0FkZCcpO1xuICAgIGRlZmluZSgxMDUgLyogTlVNUEFEX1NFUEFSQVRPUiAqLywgJ051bVBhZF9TZXBhcmF0b3InKTtcbiAgICBkZWZpbmUoMTA2IC8qIE5VTVBBRF9TVUJUUkFDVCAqLywgJ051bVBhZF9TdWJ0cmFjdCcpO1xuICAgIGRlZmluZSgxMDcgLyogTlVNUEFEX0RFQ0lNQUwgKi8sICdOdW1QYWRfRGVjaW1hbCcpO1xuICAgIGRlZmluZSgxMDggLyogTlVNUEFEX0RJVklERSAqLywgJ051bVBhZF9EaXZpZGUnKTtcbn0pKCk7XG5leHBvcnQgdmFyIEtleUNvZGVVdGlscztcbihmdW5jdGlvbiAoS2V5Q29kZVV0aWxzKSB7XG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdWlNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKGtleSkge1xuICAgICAgICByZXR1cm4gdWlNYXAuc3RyVG9LZXlDb2RlKGtleSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1VzZXJTZXR0aW5nc1VTKGtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc1VTTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLnRvVXNlclNldHRpbmdzVVMgPSB0b1VzZXJTZXR0aW5nc1VTO1xuICAgIGZ1bmN0aW9uIHRvVXNlclNldHRpbmdzR2VuZXJhbChrZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLnRvVXNlclNldHRpbmdzR2VuZXJhbCA9IHRvVXNlclNldHRpbmdzR2VuZXJhbDtcbiAgICBmdW5jdGlvbiBmcm9tVXNlclNldHRpbmdzKGtleSkge1xuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzVVNNYXAuc3RyVG9LZXlDb2RlKGtleSkgfHwgdXNlclNldHRpbmdzR2VuZXJhbE1hcC5zdHJUb0tleUNvZGUoa2V5KTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLmZyb21Vc2VyU2V0dGluZ3MgPSBmcm9tVXNlclNldHRpbmdzO1xufSkoS2V5Q29kZVV0aWxzIHx8IChLZXlDb2RlVXRpbHMgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCkge1xuICAgIHZhciBjaG9yZFBhcnQgPSAoKHNlY29uZFBhcnQgJiAweDAwMDBmZmZmKSA8PCAxNikgPj4+IDA7XG4gICAgcmV0dXJuIChmaXJzdFBhcnQgfCBjaG9yZFBhcnQpID4+PiAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleWJpbmRpbmcoa2V5YmluZGluZywgT1MpIHtcbiAgICBpZiAoa2V5YmluZGluZyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZpcnN0UGFydCA9IChrZXliaW5kaW5nICYgMHgwMDAwZmZmZikgPj4+IDA7XG4gICAgdmFyIGNob3JkUGFydCA9IChrZXliaW5kaW5nICYgMHhmZmZmMDAwMCkgPj4+IDE2O1xuICAgIGlmIChjaG9yZFBhcnQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaG9yZEtleWJpbmRpbmcoY3JlYXRlU2ltcGxlS2V5YmluZGluZyhmaXJzdFBhcnQsIE9TKSwgY3JlYXRlU2ltcGxlS2V5YmluZGluZyhjaG9yZFBhcnQsIE9TKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVTaW1wbGVLZXliaW5kaW5nKGZpcnN0UGFydCwgT1MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUtleWJpbmRpbmcoa2V5YmluZGluZywgT1MpIHtcbiAgICB2YXIgY3RybENtZCA9IChrZXliaW5kaW5nICYgMjA0OCAvKiBDdHJsQ21kICovID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICB2YXIgd2luQ3RybCA9IChrZXliaW5kaW5nICYgMjU2IC8qIFdpbkN0cmwgKi8gPyB0cnVlIDogZmFsc2UpO1xuICAgIHZhciBjdHJsS2V5ID0gKE9TID09PSAyIC8qIE1hY2ludG9zaCAqLyA/IHdpbkN0cmwgOiBjdHJsQ21kKTtcbiAgICB2YXIgc2hpZnRLZXkgPSAoa2V5YmluZGluZyAmIDEwMjQgLyogU2hpZnQgKi8gPyB0cnVlIDogZmFsc2UpO1xuICAgIHZhciBhbHRLZXkgPSAoa2V5YmluZGluZyAmIDUxMiAvKiBBbHQgKi8gPyB0cnVlIDogZmFsc2UpO1xuICAgIHZhciBtZXRhS2V5ID0gKE9TID09PSAyIC8qIE1hY2ludG9zaCAqLyA/IGN0cmxDbWQgOiB3aW5DdHJsKTtcbiAgICB2YXIga2V5Q29kZSA9IChrZXliaW5kaW5nICYgMjU1IC8qIEtleUNvZGUgKi8pO1xuICAgIHJldHVybiBuZXcgU2ltcGxlS2V5YmluZGluZyhjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5LCBrZXlDb2RlKTtcbn1cbnZhciBTaW1wbGVLZXliaW5kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZUtleWJpbmRpbmcoY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSwga2V5Q29kZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAxIC8qIFNpbXBsZSAqLztcbiAgICAgICAgdGhpcy5jdHJsS2V5ID0gY3RybEtleTtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IHNoaWZ0S2V5O1xuICAgICAgICB0aGlzLmFsdEtleSA9IGFsdEtleTtcbiAgICAgICAgdGhpcy5tZXRhS2V5ID0gbWV0YUtleTtcbiAgICAgICAgdGhpcy5rZXlDb2RlID0ga2V5Q29kZTtcbiAgICB9XG4gICAgU2ltcGxlS2V5YmluZGluZy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci50eXBlICE9PSAxIC8qIFNpbXBsZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5jdHJsS2V5ID09PSBvdGhlci5jdHJsS2V5XG4gICAgICAgICAgICAmJiB0aGlzLnNoaWZ0S2V5ID09PSBvdGhlci5zaGlmdEtleVxuICAgICAgICAgICAgJiYgdGhpcy5hbHRLZXkgPT09IG90aGVyLmFsdEtleVxuICAgICAgICAgICAgJiYgdGhpcy5tZXRhS2V5ID09PSBvdGhlci5tZXRhS2V5XG4gICAgICAgICAgICAmJiB0aGlzLmtleUNvZGUgPT09IG90aGVyLmtleUNvZGUpO1xuICAgIH07XG4gICAgU2ltcGxlS2V5YmluZGluZy5wcm90b3R5cGUuZ2V0SGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHJsID0gdGhpcy5jdHJsS2V5ID8gJzEnIDogJzAnO1xuICAgICAgICB2YXIgc2hpZnQgPSB0aGlzLnNoaWZ0S2V5ID8gJzEnIDogJzAnO1xuICAgICAgICB2YXIgYWx0ID0gdGhpcy5hbHRLZXkgPyAnMScgOiAnMCc7XG4gICAgICAgIHZhciBtZXRhID0gdGhpcy5tZXRhS2V5ID8gJzEnIDogJzAnO1xuICAgICAgICByZXR1cm4gXCJcIiArIGN0cmwgKyBzaGlmdCArIGFsdCArIG1ldGEgKyB0aGlzLmtleUNvZGU7XG4gICAgfTtcbiAgICBTaW1wbGVLZXliaW5kaW5nLnByb3RvdHlwZS5pc01vZGlmaWVyS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMua2V5Q29kZSA9PT0gMCAvKiBVbmtub3duICovXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDUgLyogQ3RybCAqL1xuICAgICAgICAgICAgfHwgdGhpcy5rZXlDb2RlID09PSA1NyAvKiBNZXRhICovXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDYgLyogQWx0ICovXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDQgLyogU2hpZnQgKi8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIGtleWJpbmRpbmcgcmVmZXIgdG8gdGhlIGtleSBjb2RlIG9mIGEgbW9kaWZpZXIgYW5kIGl0IGFsc28gaGFzIHRoZSBtb2RpZmllciBmbGFnP1xuICAgICAqL1xuICAgIFNpbXBsZUtleWJpbmRpbmcucHJvdG90eXBlLmlzRHVwbGljYXRlTW9kaWZpZXJDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmN0cmxLZXkgJiYgdGhpcy5rZXlDb2RlID09PSA1IC8qIEN0cmwgKi8pXG4gICAgICAgICAgICB8fCAodGhpcy5zaGlmdEtleSAmJiB0aGlzLmtleUNvZGUgPT09IDQgLyogU2hpZnQgKi8pXG4gICAgICAgICAgICB8fCAodGhpcy5hbHRLZXkgJiYgdGhpcy5rZXlDb2RlID09PSA2IC8qIEFsdCAqLylcbiAgICAgICAgICAgIHx8ICh0aGlzLm1ldGFLZXkgJiYgdGhpcy5rZXlDb2RlID09PSA1NyAvKiBNZXRhICovKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlS2V5YmluZGluZztcbn0oKSk7XG5leHBvcnQgeyBTaW1wbGVLZXliaW5kaW5nIH07XG52YXIgQ2hvcmRLZXliaW5kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENob3JkS2V5YmluZGluZyhmaXJzdFBhcnQsIGNob3JkUGFydCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIENob3JkICovO1xuICAgICAgICB0aGlzLmZpcnN0UGFydCA9IGZpcnN0UGFydDtcbiAgICAgICAgdGhpcy5jaG9yZFBhcnQgPSBjaG9yZFBhcnQ7XG4gICAgfVxuICAgIENob3JkS2V5YmluZGluZy5wcm90b3R5cGUuZ2V0SGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0UGFydC5nZXRIYXNoQ29kZSgpICsgXCI7XCIgKyB0aGlzLmNob3JkUGFydC5nZXRIYXNoQ29kZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENob3JkS2V5YmluZGluZztcbn0oKSk7XG5leHBvcnQgeyBDaG9yZEtleWJpbmRpbmcgfTtcbnZhciBSZXNvbHZlZEtleWJpbmRpbmdQYXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmVkS2V5YmluZGluZ1BhcnQoY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSwga2JMYWJlbCwga2JBcmlhTGFiZWwpIHtcbiAgICAgICAgdGhpcy5jdHJsS2V5ID0gY3RybEtleTtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IHNoaWZ0S2V5O1xuICAgICAgICB0aGlzLmFsdEtleSA9IGFsdEtleTtcbiAgICAgICAgdGhpcy5tZXRhS2V5ID0gbWV0YUtleTtcbiAgICAgICAgdGhpcy5rZXlMYWJlbCA9IGtiTGFiZWw7XG4gICAgICAgIHRoaXMua2V5QXJpYUxhYmVsID0ga2JBcmlhTGFiZWw7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZEtleWJpbmRpbmdQYXJ0O1xufSgpKTtcbmV4cG9ydCB7IFJlc29sdmVkS2V5YmluZGluZ1BhcnQgfTtcbi8qKlxuICogQSByZXNvbHZlZCBrZXliaW5kaW5nLiBDYW4gYmUgYSBzaW1wbGUga2V5YmluZGluZyBvciBhIGNob3JkIGtleWJpbmRpbmcuXG4gKi9cbnZhciBSZXNvbHZlZEtleWJpbmRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb2x2ZWRLZXliaW5kaW5nKCkge1xuICAgIH1cbiAgICByZXR1cm4gUmVzb2x2ZWRLZXliaW5kaW5nO1xufSgpKTtcbmV4cG9ydCB7IFJlc29sdmVkS2V5YmluZGluZyB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js":
/*!********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js ***!
  \********************************************************************/
/*! exports provided: empty, isDisposable, dispose, combinedDisposable, toDisposable, Disposable, ReferenceCollection, ImmortalReference */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDisposable\", function() { return isDisposable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dispose\", function() { return dispose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combinedDisposable\", function() { return combinedDisposable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toDisposable\", function() { return toDisposable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Disposable\", function() { return Disposable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReferenceCollection\", function() { return ReferenceCollection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImmortalReference\", function() { return ImmortalReference; });\n/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional.js */ \"./node_modules/monaco-editor/esm/vs/base/common/functional.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar empty = Object.freeze({\n    dispose: function () { }\n});\nfunction isDisposable(thing) {\n    return typeof thing.dispose === 'function'\n        && thing.dispose.length === 0;\n}\nfunction dispose(first) {\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        rest[_i - 1] = arguments[_i];\n    }\n    if (Array.isArray(first)) {\n        first.forEach(function (d) { return d && d.dispose(); });\n        return [];\n    }\n    else if (rest.length === 0) {\n        if (first) {\n            first.dispose();\n            return first;\n        }\n        return undefined;\n    }\n    else {\n        dispose(first);\n        dispose(rest);\n        return [];\n    }\n}\nfunction combinedDisposable(disposables) {\n    return { dispose: function () { return dispose(disposables); } };\n}\nfunction toDisposable() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return {\n        dispose: function () {\n            for (var _i = 0, fns_1 = fns; _i < fns_1.length; _i++) {\n                var fn = fns_1[_i];\n                fn();\n            }\n        }\n    };\n}\nvar Disposable = /** @class */ (function () {\n    function Disposable() {\n        this._toDispose = [];\n    }\n    Disposable.prototype.dispose = function () {\n        this._toDispose = dispose(this._toDispose);\n    };\n    Disposable.prototype._register = function (t) {\n        this._toDispose.push(t);\n        return t;\n    };\n    return Disposable;\n}());\n\nvar ReferenceCollection = /** @class */ (function () {\n    function ReferenceCollection() {\n        this.references = Object.create(null);\n    }\n    ReferenceCollection.prototype.acquire = function (key) {\n        var _this = this;\n        var reference = this.references[key];\n        if (!reference) {\n            reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n        }\n        var object = reference.object;\n        var dispose = Object(_functional_js__WEBPACK_IMPORTED_MODULE_0__[\"once\"])(function () {\n            if (--reference.counter === 0) {\n                _this.destroyReferencedObject(reference.object);\n                delete _this.references[key];\n            }\n        });\n        reference.counter++;\n        return { object: object, dispose: dispose };\n    };\n    return ReferenceCollection;\n}());\n\nvar ImmortalReference = /** @class */ (function () {\n    function ImmortalReference(object) {\n        this.object = object;\n    }\n    ImmortalReference.prototype.dispose = function () { };\n    return ImmortalReference;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcz9hNjY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgb25jZSB9IGZyb20gJy4vZnVuY3Rpb25hbC5qcyc7XG5leHBvcnQgdmFyIGVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkgeyB9XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc3Bvc2FibGUodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmRpc3Bvc2UgPT09ICdmdW5jdGlvbidcbiAgICAgICAgJiYgdGhpbmcuZGlzcG9zZS5sZW5ndGggPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZShmaXJzdCkge1xuICAgIHZhciByZXN0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICAgIGZpcnN0LmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQgJiYgZC5kaXNwb3NlKCk7IH0pO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgZmlyc3QuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkaXNwb3NlKGZpcnN0KTtcbiAgICAgICAgZGlzcG9zZShyZXN0KTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lZERpc3Bvc2FibGUoZGlzcG9zYWJsZXMpIHtcbiAgICByZXR1cm4geyBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NlKGRpc3Bvc2FibGVzKTsgfSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvRGlzcG9zYWJsZSgpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZm5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZm5zXzEgPSBmbnM7IF9pIDwgZm5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZm5zXzFbX2ldO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIERpc3Bvc2FibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fdG9EaXNwb3NlID0gW107XG4gICAgfVxuICAgIERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RvRGlzcG9zZSA9IGRpc3Bvc2UodGhpcy5fdG9EaXNwb3NlKTtcbiAgICB9O1xuICAgIERpc3Bvc2FibGUucHJvdG90eXBlLl9yZWdpc3RlciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3RvRGlzcG9zZS5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBEaXNwb3NhYmxlO1xufSgpKTtcbmV4cG9ydCB7IERpc3Bvc2FibGUgfTtcbnZhciBSZWZlcmVuY2VDb2xsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFJlZmVyZW5jZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZWZlcmVuY2UgPSB0aGlzLnJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgaWYgKCFyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlc1trZXldID0geyBjb3VudGVyOiAwLCBvYmplY3Q6IHRoaXMuY3JlYXRlUmVmZXJlbmNlZE9iamVjdChrZXkpIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iamVjdCA9IHJlZmVyZW5jZS5vYmplY3Q7XG4gICAgICAgIHZhciBkaXNwb3NlID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoLS1yZWZlcmVuY2UuY291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlc3Ryb3lSZWZlcmVuY2VkT2JqZWN0KHJlZmVyZW5jZS5vYmplY3QpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZWZlcmVuY2VzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZWZlcmVuY2UuY291bnRlcisrO1xuICAgICAgICByZXR1cm4geyBvYmplY3Q6IG9iamVjdCwgZGlzcG9zZTogZGlzcG9zZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZUNvbGxlY3Rpb247XG59KCkpO1xuZXhwb3J0IHsgUmVmZXJlbmNlQ29sbGVjdGlvbiB9O1xudmFyIEltbW9ydGFsUmVmZXJlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltbW9ydGFsUmVmZXJlbmNlKG9iamVjdCkge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB9XG4gICAgSW1tb3J0YWxSZWZlcmVuY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIEltbW9ydGFsUmVmZXJlbmNlO1xufSgpKTtcbmV4cG9ydCB7IEltbW9ydGFsUmVmZXJlbmNlIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/linkedList.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js ***!
  \*********************************************************************/
/*! exports provided: LinkedList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkedList\", function() { return LinkedList; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar Node = /** @class */ (function () {\n    function Node(element) {\n        this.element = element;\n    }\n    return Node;\n}());\nvar LinkedList = /** @class */ (function () {\n    function LinkedList() {\n    }\n    LinkedList.prototype.isEmpty = function () {\n        return !this._first;\n    };\n    LinkedList.prototype.clear = function () {\n        this._first = undefined;\n        this._last = undefined;\n    };\n    LinkedList.prototype.unshift = function (element) {\n        return this.insert(element, false);\n    };\n    LinkedList.prototype.push = function (element) {\n        return this.insert(element, true);\n    };\n    LinkedList.prototype.insert = function (element, atTheEnd) {\n        var _this = this;\n        var newNode = new Node(element);\n        if (!this._first) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            var oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            var oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        return function () {\n            for (var candidate = _this._first; candidate instanceof Node; candidate = candidate.next) {\n                if (candidate !== newNode) {\n                    continue;\n                }\n                if (candidate.prev && candidate.next) {\n                    // middle\n                    var anchor = candidate.prev;\n                    anchor.next = candidate.next;\n                    candidate.next.prev = anchor;\n                }\n                else if (!candidate.prev && !candidate.next) {\n                    // only node\n                    _this._first = undefined;\n                    _this._last = undefined;\n                }\n                else if (!candidate.next) {\n                    // last\n                    _this._last = _this._last.prev;\n                    _this._last.next = undefined;\n                }\n                else if (!candidate.prev) {\n                    // first\n                    _this._first = _this._first.next;\n                    _this._first.prev = undefined;\n                }\n                // done\n                break;\n            }\n        };\n    };\n    LinkedList.prototype.iterator = function () {\n        var element = {\n            done: undefined,\n            value: undefined,\n        };\n        var node = this._first;\n        return {\n            next: function () {\n                if (!node) {\n                    element.done = true;\n                    element.value = undefined;\n                }\n                else {\n                    element.done = false;\n                    element.value = node.element;\n                    node = node.next;\n                }\n                return element;\n            }\n        };\n    };\n    LinkedList.prototype.toArray = function () {\n        var result = [];\n        for (var node = this._first; node instanceof Node; node = node.next) {\n            result.push(node.element);\n        }\n        return result;\n    };\n    return LinkedList;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9saW5rZWRMaXN0LmpzP2RiODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xudmFyIExpbmtlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdCgpIHtcbiAgICB9XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9maXJzdDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9maXJzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbGFzdCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnQoZWxlbWVudCwgZmFsc2UpO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0cnVlKTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdFRoZUVuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ldyBOb2RlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX2ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdFRoZUVuZCkge1xuICAgICAgICAgICAgLy8gcHVzaFxuICAgICAgICAgICAgdmFyIG9sZExhc3QgPSB0aGlzLl9sYXN0O1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICBuZXdOb2RlLnByZXYgPSBvbGRMYXN0O1xuICAgICAgICAgICAgb2xkTGFzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVuc2hpZnRcbiAgICAgICAgICAgIHZhciBvbGRGaXJzdCA9IHRoaXMuX2ZpcnN0O1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBuZXdOb2RlO1xuICAgICAgICAgICAgbmV3Tm9kZS5uZXh0ID0gb2xkRmlyc3Q7XG4gICAgICAgICAgICBvbGRGaXJzdC5wcmV2ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgY2FuZGlkYXRlID0gX3RoaXMuX2ZpcnN0OyBjYW5kaWRhdGUgaW5zdGFuY2VvZiBOb2RlOyBjYW5kaWRhdGUgPSBjYW5kaWRhdGUubmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgIT09IG5ld05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUucHJldiAmJiBjYW5kaWRhdGUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IGNhbmRpZGF0ZS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICBhbmNob3IubmV4dCA9IGNhbmRpZGF0ZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUubmV4dC5wcmV2ID0gYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2FuZGlkYXRlLnByZXYgJiYgIWNhbmRpZGF0ZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbm9kZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZmlyc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2FuZGlkYXRlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbGFzdCA9IF90aGlzLl9sYXN0LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0Lm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjYW5kaWRhdGUucHJldikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZmlyc3QgPSBfdGhpcy5fZmlyc3QubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ZpcnN0LnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIGRvbmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5vZGUuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIG5vZGUgPSB0aGlzLl9maXJzdDsgbm9kZSBpbnN0YW5jZW9mIE5vZGU7IG5vZGUgPSBub2RlLm5leHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTtcbmV4cG9ydCB7IExpbmtlZExpc3QgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/map.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/map.js ***!
  \**************************************************************/
/*! exports provided: values, keys, getOrSet, StringIterator, PathIterator, TernarySearchTree, ResourceMap, StrictResourceMap, Touch, LinkedMap, LRUCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"values\", function() { return values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOrSet\", function() { return getOrSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringIterator\", function() { return StringIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PathIterator\", function() { return PathIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TernarySearchTree\", function() { return TernarySearchTree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResourceMap\", function() { return ResourceMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StrictResourceMap\", function() { return StrictResourceMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Touch\", function() { return Touch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkedMap\", function() { return LinkedMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LRUCache\", function() { return LRUCache; });\n/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uri.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uri.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nfunction values(forEachable) {\n    var result = [];\n    forEachable.forEach(function (value) { return result.push(value); });\n    return result;\n}\nfunction keys(map) {\n    var result = [];\n    map.forEach(function (value, key) { return result.push(key); });\n    return result;\n}\nfunction getOrSet(map, key, value) {\n    var result = map.get(key);\n    if (result === void 0) {\n        result = value;\n        map.set(key, result);\n    }\n    return result;\n}\nvar StringIterator = /** @class */ (function () {\n    function StringIterator() {\n        this._value = '';\n        this._pos = 0;\n    }\n    StringIterator.prototype.reset = function (key) {\n        this._value = key;\n        this._pos = 0;\n        return this;\n    };\n    StringIterator.prototype.next = function () {\n        this._pos += 1;\n        return this;\n    };\n    StringIterator.prototype.join = function (parts) {\n        return parts.join('');\n    };\n    StringIterator.prototype.hasNext = function () {\n        return this._pos < this._value.length - 1;\n    };\n    StringIterator.prototype.cmp = function (a) {\n        var aCode = a.charCodeAt(0);\n        var thisCode = this._value.charCodeAt(this._pos);\n        return aCode - thisCode;\n    };\n    StringIterator.prototype.value = function () {\n        return this._value[this._pos];\n    };\n    return StringIterator;\n}());\n\nvar PathIterator = /** @class */ (function () {\n    function PathIterator() {\n    }\n    PathIterator.prototype.reset = function (key) {\n        this._value = key.replace(/\\\\$|\\/$/, '');\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    };\n    PathIterator.prototype.hasNext = function () {\n        return this._to < this._value.length;\n    };\n    PathIterator.prototype.join = function (parts) {\n        return parts.join('/');\n    };\n    PathIterator.prototype.next = function () {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        var justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            var ch = this._value.charCodeAt(this._to);\n            if (ch === PathIterator._fwd || ch === PathIterator._bwd) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    };\n    PathIterator.prototype.cmp = function (a) {\n        var aPos = 0;\n        var aLen = a.length;\n        var thisPos = this._from;\n        while (aPos < aLen && thisPos < this._to) {\n            var cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n            if (cmp !== 0) {\n                return cmp;\n            }\n            aPos += 1;\n            thisPos += 1;\n        }\n        if (aLen === this._to - this._from) {\n            return 0;\n        }\n        else if (aPos < aLen) {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    };\n    PathIterator.prototype.value = function () {\n        return this._value.substring(this._from, this._to);\n    };\n    PathIterator._fwd = '/'.charCodeAt(0);\n    PathIterator._bwd = '\\\\'.charCodeAt(0);\n    return PathIterator;\n}());\n\nvar TernarySearchTreeNode = /** @class */ (function () {\n    function TernarySearchTreeNode() {\n    }\n    TernarySearchTreeNode.prototype.isEmpty = function () {\n        return !this.left && !this.mid && !this.right && !this.element;\n    };\n    return TernarySearchTreeNode;\n}());\nvar TernarySearchTree = /** @class */ (function () {\n    function TernarySearchTree(segments) {\n        this._iter = segments;\n    }\n    TernarySearchTree.forPaths = function () {\n        return new TernarySearchTree(new PathIterator());\n    };\n    TernarySearchTree.forStrings = function () {\n        return new TernarySearchTree(new StringIterator());\n    };\n    TernarySearchTree.prototype.clear = function () {\n        this._root = undefined;\n    };\n    TernarySearchTree.prototype.set = function (key, element) {\n        var iter = this._iter.reset(key);\n        var node;\n        if (!this._root) {\n            this._root = new TernarySearchTreeNode();\n            this._root.str = iter.value();\n        }\n        node = this._root;\n        while (true) {\n            var val = iter.cmp(node.str);\n            if (val > 0) {\n                // left\n                if (!node.left) {\n                    node.left = new TernarySearchTreeNode();\n                    node.left.str = iter.value();\n                }\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                if (!node.right) {\n                    node.right = new TernarySearchTreeNode();\n                    node.right.str = iter.value();\n                }\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                if (!node.mid) {\n                    node.mid = new TernarySearchTreeNode();\n                    node.mid.str = iter.value();\n                }\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        var oldElement = node.element;\n        node.element = element;\n        return oldElement;\n    };\n    TernarySearchTree.prototype.get = function (key) {\n        var iter = this._iter.reset(key);\n        var node = this._root;\n        while (node) {\n            var val = iter.cmp(node.str);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node ? node.element : undefined;\n    };\n    TernarySearchTree.prototype.delete = function (key) {\n        var iter = this._iter.reset(key);\n        var stack = [];\n        var node = this._root;\n        // find and unset node\n        while (node) {\n            var val = iter.cmp(node.str);\n            if (val > 0) {\n                // left\n                stack.push([1, node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                stack.push([-1, node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                stack.push([0, node]);\n                node = node.mid;\n            }\n            else {\n                // remove element\n                node.element = undefined;\n                // clean up empty nodes\n                while (stack.length > 0 && node.isEmpty()) {\n                    var _a = stack.pop(), dir = _a[0], parent_1 = _a[1];\n                    switch (dir) {\n                        case 1:\n                            parent_1.left = undefined;\n                            break;\n                        case 0:\n                            parent_1.mid = undefined;\n                            break;\n                        case -1:\n                            parent_1.right = undefined;\n                            break;\n                    }\n                    node = parent_1;\n                }\n                break;\n            }\n        }\n    };\n    TernarySearchTree.prototype.findSubstr = function (key) {\n        var iter = this._iter.reset(key);\n        var node = this._root;\n        var candidate;\n        while (node) {\n            var val = iter.cmp(node.str);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                candidate = node.element || candidate;\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node && node.element || candidate;\n    };\n    TernarySearchTree.prototype.findSuperstr = function (key) {\n        var iter = this._iter.reset(key);\n        var node = this._root;\n        while (node) {\n            var val = iter.cmp(node.str);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                // collect\n                if (!node.mid) {\n                    return undefined;\n                }\n                var ret = new TernarySearchTree(this._iter);\n                ret._root = node.mid;\n                return ret;\n            }\n        }\n        return undefined;\n    };\n    TernarySearchTree.prototype.forEach = function (callback) {\n        this._forEach(this._root, [], callback);\n    };\n    TernarySearchTree.prototype._forEach = function (node, parts, callback) {\n        if (node) {\n            // left\n            this._forEach(node.left, parts, callback);\n            // node\n            parts.push(node.str);\n            if (node.element) {\n                callback(node.element, this._iter.join(parts));\n            }\n            // mid\n            this._forEach(node.mid, parts, callback);\n            parts.pop();\n            // right\n            this._forEach(node.right, parts, callback);\n        }\n    };\n    return TernarySearchTree;\n}());\n\nvar ResourceMap = /** @class */ (function () {\n    function ResourceMap(ignoreCase) {\n        this.ignoreCase = ignoreCase;\n        this.map = new Map();\n    }\n    ResourceMap.prototype.set = function (resource, value) {\n        this.map.set(this.toKey(resource), value);\n    };\n    ResourceMap.prototype.get = function (resource) {\n        return this.map.get(this.toKey(resource));\n    };\n    ResourceMap.prototype.has = function (resource) {\n        return this.map.has(this.toKey(resource));\n    };\n    Object.defineProperty(ResourceMap.prototype, \"size\", {\n        get: function () {\n            return this.map.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResourceMap.prototype.clear = function () {\n        this.map.clear();\n    };\n    ResourceMap.prototype.delete = function (resource) {\n        return this.map.delete(this.toKey(resource));\n    };\n    ResourceMap.prototype.forEach = function (clb) {\n        this.map.forEach(clb);\n    };\n    ResourceMap.prototype.values = function () {\n        return values(this.map);\n    };\n    ResourceMap.prototype.toKey = function (resource) {\n        var key = resource.toString();\n        if (this.ignoreCase) {\n            key = key.toLowerCase();\n        }\n        return key;\n    };\n    return ResourceMap;\n}());\n\nvar StrictResourceMap = /** @class */ (function (_super) {\n    __extends(StrictResourceMap, _super);\n    function StrictResourceMap() {\n        return _super.call(this) || this;\n    }\n    StrictResourceMap.prototype.keys = function () {\n        return keys(this.map).map(function (key) { return _uri_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(key); });\n    };\n    return StrictResourceMap;\n}(ResourceMap));\n\nvar Touch;\n(function (Touch) {\n    Touch[Touch[\"None\"] = 0] = \"None\";\n    Touch[Touch[\"AsOld\"] = 1] = \"AsOld\";\n    Touch[Touch[\"AsNew\"] = 2] = \"AsNew\";\n})(Touch || (Touch = {}));\nvar LinkedMap = /** @class */ (function () {\n    function LinkedMap() {\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n    }\n    LinkedMap.prototype.clear = function () {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n    };\n    LinkedMap.prototype.isEmpty = function () {\n        return !this._head && !this._tail;\n    };\n    Object.defineProperty(LinkedMap.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LinkedMap.prototype.has = function (key) {\n        return this._map.has(key);\n    };\n    LinkedMap.prototype.get = function (key, touch) {\n        if (touch === void 0) { touch = Touch.None; }\n        var item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== Touch.None) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    };\n    LinkedMap.prototype.set = function (key, value, touch) {\n        if (touch === void 0) { touch = Touch.None; }\n        var item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key: key, value: value, next: undefined, previous: undefined };\n            switch (touch) {\n                case Touch.None:\n                    this.addItemLast(item);\n                    break;\n                case Touch.AsOld:\n                    this.addItemFirst(item);\n                    break;\n                case Touch.AsNew:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n    };\n    LinkedMap.prototype.delete = function (key) {\n        return !!this.remove(key);\n    };\n    LinkedMap.prototype.remove = function (key) {\n        var item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    };\n    LinkedMap.prototype.shift = function () {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        var item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    };\n    LinkedMap.prototype.forEach = function (callbackfn, thisArg) {\n        var current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            current = current.next;\n        }\n    };\n    LinkedMap.prototype.values = function () {\n        var result = [];\n        var current = this._head;\n        while (current) {\n            result.push(current.value);\n            current = current.next;\n        }\n        return result;\n    };\n    LinkedMap.prototype.keys = function () {\n        var result = [];\n        var current = this._head;\n        while (current) {\n            result.push(current.key);\n            current = current.next;\n        }\n        return result;\n    };\n    /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n    public keys(): IterableIterator<K> {\n        let current = this._head;\n        let iterator: IterableIterator<K> = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next():IteratorResult<K> {\n                if (current) {\n                    let result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                } else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n\n    public values(): IterableIterator<V> {\n        let current = this._head;\n        let iterator: IterableIterator<V> = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next():IteratorResult<V> {\n                if (current) {\n                    let result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                } else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    */\n    LinkedMap.prototype.trimOld = function (newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        var current = this._head;\n        var currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        current.previous = void 0;\n    };\n    LinkedMap.prototype.addItemFirst = function (item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n    };\n    LinkedMap.prototype.addItemLast = function (item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n    };\n    LinkedMap.prototype.removeItem = function (item) {\n        if (item === this._head && item === this._tail) {\n            this._head = void 0;\n            this._tail = void 0;\n        }\n        else if (item === this._head) {\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            this._tail = item.previous;\n        }\n        else {\n            var next = item.next;\n            var previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n    };\n    LinkedMap.prototype.touch = function (item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n            return;\n        }\n        if (touch === Touch.AsOld) {\n            if (item === this._head) {\n                return;\n            }\n            var next = item.next;\n            var previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = void 0;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = void 0;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n        }\n        else if (touch === Touch.AsNew) {\n            if (item === this._tail) {\n                return;\n            }\n            var next = item.next;\n            var previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = void 0;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = void 0;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n        }\n    };\n    return LinkedMap;\n}());\n\nvar LRUCache = /** @class */ (function (_super) {\n    __extends(LRUCache, _super);\n    function LRUCache(limit, ratio) {\n        if (ratio === void 0) { ratio = 1; }\n        var _this = _super.call(this) || this;\n        _this._limit = limit;\n        _this._ratio = Math.min(Math.max(0, ratio), 1);\n        return _this;\n    }\n    Object.defineProperty(LRUCache.prototype, \"limit\", {\n        get: function () {\n            return this._limit;\n        },\n        set: function (limit) {\n            this._limit = limit;\n            this.checkTrim();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LRUCache.prototype, \"ratio\", {\n        get: function () {\n            return this._ratio;\n        },\n        set: function (ratio) {\n            this._ratio = Math.min(Math.max(0, ratio), 1);\n            this.checkTrim();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LRUCache.prototype.get = function (key) {\n        return _super.prototype.get.call(this, key, Touch.AsNew);\n    };\n    LRUCache.prototype.peek = function (key) {\n        return _super.prototype.get.call(this, key, Touch.None);\n    };\n    LRUCache.prototype.set = function (key, value) {\n        _super.prototype.set.call(this, key, value, Touch.AsNew);\n        this.checkTrim();\n    };\n    LRUCache.prototype.checkTrim = function () {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    };\n    return LRUCache;\n}(LinkedMap));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbWFwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL21hcC5qcz80MDM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgVVJJIGZyb20gJy4vdXJpLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZXMoZm9yRWFjaGFibGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yRWFjaGFibGUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKHZhbHVlKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBrZXlzKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXR1cm4gcmVzdWx0LnB1c2goa2V5KTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPclNldChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWFwLmdldChrZXkpO1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgbWFwLnNldChrZXksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgU3RyaW5nSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nSXRlcmF0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuX3BvcyA9IDA7XG4gICAgfVxuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBrZXk7XG4gICAgICAgIHRoaXMuX3BvcyA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BvcyArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zIDwgdGhpcy5fdmFsdWUubGVuZ3RoIC0gMTtcbiAgICB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYUNvZGUgPSBhLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciB0aGlzQ29kZSA9IHRoaXMuX3ZhbHVlLmNoYXJDb2RlQXQodGhpcy5fcG9zKTtcbiAgICAgICAgcmV0dXJuIGFDb2RlIC0gdGhpc0NvZGU7XG4gICAgfTtcbiAgICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZVt0aGlzLl9wb3NdO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmluZ0l0ZXJhdG9yO1xufSgpKTtcbmV4cG9ydCB7IFN0cmluZ0l0ZXJhdG9yIH07XG52YXIgUGF0aEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGhJdGVyYXRvcigpIHtcbiAgICB9XG4gICAgUGF0aEl0ZXJhdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBrZXkucmVwbGFjZSgvXFxcXCR8XFwvJC8sICcnKTtcbiAgICAgICAgdGhpcy5fZnJvbSA9IDA7XG4gICAgICAgIHRoaXMuX3RvID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgIH07XG4gICAgUGF0aEl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG8gPCB0aGlzLl92YWx1ZS5sZW5ndGg7XG4gICAgfTtcbiAgICBQYXRoSXRlcmF0b3IucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcbiAgICB9O1xuICAgIFBhdGhJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhpcy5fZGF0YSA9IGtleS5zcGxpdCgvW1xcXFwvXS8pLmZpbHRlcihzID0+ICEhcyk7XG4gICAgICAgIHRoaXMuX2Zyb20gPSB0aGlzLl90bztcbiAgICAgICAgdmFyIGp1c3RTZXBzID0gdHJ1ZTtcbiAgICAgICAgZm9yICg7IHRoaXMuX3RvIDwgdGhpcy5fdmFsdWUubGVuZ3RoOyB0aGlzLl90bysrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzLl92YWx1ZS5jaGFyQ29kZUF0KHRoaXMuX3RvKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gUGF0aEl0ZXJhdG9yLl9md2QgfHwgY2ggPT09IFBhdGhJdGVyYXRvci5fYndkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1c3RTZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb20rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGp1c3RTZXBzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQYXRoSXRlcmF0b3IucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBhUG9zID0gMDtcbiAgICAgICAgdmFyIGFMZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIHRoaXNQb3MgPSB0aGlzLl9mcm9tO1xuICAgICAgICB3aGlsZSAoYVBvcyA8IGFMZW4gJiYgdGhpc1BvcyA8IHRoaXMuX3RvKSB7XG4gICAgICAgICAgICB2YXIgY21wID0gYS5jaGFyQ29kZUF0KGFQb3MpIC0gdGhpcy5fdmFsdWUuY2hhckNvZGVBdCh0aGlzUG9zKTtcbiAgICAgICAgICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVBvcyArPSAxO1xuICAgICAgICAgICAgdGhpc1BvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhTGVuID09PSB0aGlzLl90byAtIHRoaXMuX2Zyb20pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFQb3MgPCBhTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGF0aEl0ZXJhdG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlLnN1YnN0cmluZyh0aGlzLl9mcm9tLCB0aGlzLl90byk7XG4gICAgfTtcbiAgICBQYXRoSXRlcmF0b3IuX2Z3ZCA9ICcvJy5jaGFyQ29kZUF0KDApO1xuICAgIFBhdGhJdGVyYXRvci5fYndkID0gJ1xcXFwnLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIFBhdGhJdGVyYXRvcjtcbn0oKSk7XG5leHBvcnQgeyBQYXRoSXRlcmF0b3IgfTtcbnZhciBUZXJuYXJ5U2VhcmNoVHJlZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVybmFyeVNlYXJjaFRyZWVOb2RlKCkge1xuICAgIH1cbiAgICBUZXJuYXJ5U2VhcmNoVHJlZU5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5sZWZ0ICYmICF0aGlzLm1pZCAmJiAhdGhpcy5yaWdodCAmJiAhdGhpcy5lbGVtZW50O1xuICAgIH07XG4gICAgcmV0dXJuIFRlcm5hcnlTZWFyY2hUcmVlTm9kZTtcbn0oKSk7XG52YXIgVGVybmFyeVNlYXJjaFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVybmFyeVNlYXJjaFRyZWUoc2VnbWVudHMpIHtcbiAgICAgICAgdGhpcy5faXRlciA9IHNlZ21lbnRzO1xuICAgIH1cbiAgICBUZXJuYXJ5U2VhcmNoVHJlZS5mb3JQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJuYXJ5U2VhcmNoVHJlZShuZXcgUGF0aEl0ZXJhdG9yKCkpO1xuICAgIH07XG4gICAgVGVybmFyeVNlYXJjaFRyZWUuZm9yU3RyaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJuYXJ5U2VhcmNoVHJlZShuZXcgU3RyaW5nSXRlcmF0b3IoKSk7XG4gICAgfTtcbiAgICBUZXJuYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBUZXJuYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgaXRlciA9IHRoaXMuX2l0ZXIucmVzZXQoa2V5KTtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5ldyBUZXJuYXJ5U2VhcmNoVHJlZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Quc3RyID0gaXRlci52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSB0aGlzLl9yb290O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGl0ZXIuY21wKG5vZGUuc3RyKTtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbGVmdFxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUZXJuYXJ5U2VhcmNoVHJlZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWZ0LnN0ciA9IGl0ZXIudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodFxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gbmV3IFRlcm5hcnlTZWFyY2hUcmVlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0LnN0ciA9IGl0ZXIudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgIC8vIG1pZFxuICAgICAgICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5taWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5taWQgPSBuZXcgVGVybmFyeVNlYXJjaFRyZWVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWlkLnN0ciA9IGl0ZXIudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEVsZW1lbnQgPSBub2RlLmVsZW1lbnQ7XG4gICAgICAgIG5vZGUuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBvbGRFbGVtZW50O1xuICAgIH07XG4gICAgVGVybmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGl0ZXIgPSB0aGlzLl9pdGVyLnJlc2V0KGtleSk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBpdGVyLmNtcChub2RlLnN0cik7XG4gICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGxlZnRcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIHJpZ2h0XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgIC8vIG1pZFxuICAgICAgICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5lbGVtZW50IDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgVGVybmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGl0ZXIgPSB0aGlzLl9pdGVyLnJlc2V0KGtleSk7XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIC8vIGZpbmQgYW5kIHVuc2V0IG5vZGVcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBpdGVyLmNtcChub2RlLnN0cik7XG4gICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGxlZnRcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFsxLCBub2RlXSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodFxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goWy0xLCBub2RlXSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgIC8vIG1pZFxuICAgICAgICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goWzAsIG5vZGVdKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5taWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBlbXB0eSBub2Rlc1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIG5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHN0YWNrLnBvcCgpLCBkaXIgPSBfYVswXSwgcGFyZW50XzEgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF8xLm1pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudF8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVybmFyeVNlYXJjaFRyZWUucHJvdG90eXBlLmZpbmRTdWJzdHIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpdGVyID0gdGhpcy5faXRlci5yZXNldChrZXkpO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIHZhciBjYW5kaWRhdGU7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gaXRlci5jbXAobm9kZS5zdHIpO1xuICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodFxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBtaWRcbiAgICAgICAgICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlLmVsZW1lbnQgfHwgY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuZWxlbWVudCB8fCBjYW5kaWRhdGU7XG4gICAgfTtcbiAgICBUZXJuYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZmluZFN1cGVyc3RyID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaXRlciA9IHRoaXMuX2l0ZXIucmVzZXQoa2V5KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9yb290O1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGl0ZXIuY21wKG5vZGUuc3RyKTtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbGVmdFxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmlnaHRcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWlkXG4gICAgICAgICAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdFxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5taWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUZXJuYXJ5U2VhcmNoVHJlZSh0aGlzLl9pdGVyKTtcbiAgICAgICAgICAgICAgICByZXQuX3Jvb3QgPSBub2RlLm1pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBUZXJuYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9mb3JFYWNoKHRoaXMuX3Jvb3QsIFtdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBUZXJuYXJ5U2VhcmNoVHJlZS5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAobm9kZSwgcGFydHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAvLyBsZWZ0XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoKG5vZGUubGVmdCwgcGFydHMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIG5vZGVcbiAgICAgICAgICAgIHBhcnRzLnB1c2gobm9kZS5zdHIpO1xuICAgICAgICAgICAgaWYgKG5vZGUuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUuZWxlbWVudCwgdGhpcy5faXRlci5qb2luKHBhcnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtaWRcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2gobm9kZS5taWQsIHBhcnRzLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIC8vIHJpZ2h0XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoKG5vZGUucmlnaHQsIHBhcnRzLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXJuYXJ5U2VhcmNoVHJlZTtcbn0oKSk7XG5leHBvcnQgeyBUZXJuYXJ5U2VhcmNoVHJlZSB9O1xudmFyIFJlc291cmNlTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlTWFwKGlnbm9yZUNhc2UpIHtcbiAgICAgICAgdGhpcy5pZ25vcmVDYXNlID0gaWdub3JlQ2FzZTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFJlc291cmNlTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocmVzb3VyY2UsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFwLnNldCh0aGlzLnRvS2V5KHJlc291cmNlKSwgdmFsdWUpO1xuICAgIH07XG4gICAgUmVzb3VyY2VNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KHRoaXMudG9LZXkocmVzb3VyY2UpKTtcbiAgICB9O1xuICAgIFJlc291cmNlTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyh0aGlzLnRvS2V5KHJlc291cmNlKSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzb3VyY2VNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSZXNvdXJjZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwLmNsZWFyKCk7XG4gICAgfTtcbiAgICBSZXNvdXJjZU1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUodGhpcy50b0tleShyZXNvdXJjZSkpO1xuICAgIH07XG4gICAgUmVzb3VyY2VNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2xiKSB7XG4gICAgICAgIHRoaXMubWFwLmZvckVhY2goY2xiKTtcbiAgICB9O1xuICAgIFJlc291cmNlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModGhpcy5tYXApO1xuICAgIH07XG4gICAgUmVzb3VyY2VNYXAucHJvdG90eXBlLnRvS2V5ID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXNvdXJjZS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgcmV0dXJuIFJlc291cmNlTWFwO1xufSgpKTtcbmV4cG9ydCB7IFJlc291cmNlTWFwIH07XG52YXIgU3RyaWN0UmVzb3VyY2VNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmljdFJlc291cmNlTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmljdFJlc291cmNlTWFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB9XG4gICAgU3RyaWN0UmVzb3VyY2VNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKHRoaXMubWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gVVJJLnBhcnNlKGtleSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmljdFJlc291cmNlTWFwO1xufShSZXNvdXJjZU1hcCkpO1xuZXhwb3J0IHsgU3RyaWN0UmVzb3VyY2VNYXAgfTtcbmV4cG9ydCB2YXIgVG91Y2g7XG4oZnVuY3Rpb24gKFRvdWNoKSB7XG4gICAgVG91Y2hbVG91Y2hbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBUb3VjaFtUb3VjaFtcIkFzT2xkXCJdID0gMV0gPSBcIkFzT2xkXCI7XG4gICAgVG91Y2hbVG91Y2hbXCJBc05ld1wiXSA9IDJdID0gXCJBc05ld1wiO1xufSkoVG91Y2ggfHwgKFRvdWNoID0ge30pKTtcbnZhciBMaW5rZWRNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTWFwKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rZWRNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9O1xuICAgIExpbmtlZE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKHRvdWNoID09PSB2b2lkIDApIHsgdG91Y2ggPSBUb3VjaC5Ob25lOyB9XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9O1xuICAgIExpbmtlZE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHRvdWNoKSB7XG4gICAgICAgIGlmICh0b3VjaCA9PT0gdm9pZCAwKSB7IHRvdWNoID0gVG91Y2guTm9uZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgbmV4dDogdW5kZWZpbmVkLCBwcmV2aW91czogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBzd2l0Y2ggKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5Ob25lOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkFzT2xkOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1GaXJzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5Bc05ldzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtlZE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZShrZXkpO1xuICAgIH07XG4gICAgTGlua2VkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9O1xuICAgIExpbmtlZE1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlua2VkTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudC5rZXkpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyogVlMgQ29kZSAvIE1vbmFjbyBlZGl0b3IgcnVucyBvbiBlczUgd2hpY2ggaGFzIG5vIFN5bWJvbC5pdGVyYXRvclxuICAgIHB1YmxpYyBrZXlzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Sz4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBpdGVyYXRvcjogSXRlcmFibGVJdGVyYXRvcjxLPiA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0KCk6SXRlcmF0b3JSZXN1bHQ8Sz4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbHVlcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFY+IHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBsZXQgaXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8Vj4gPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dCgpOkl0ZXJhdG9yUmVzdWx0PFY+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgICovXG4gICAgTGlua2VkTWFwLnByb3RvdHlwZS50cmltT2xkID0gZnVuY3Rpb24gKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHZhciBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSB2b2lkIDA7XG4gICAgfTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLmFkZEl0ZW1GaXJzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgfTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLmFkZEl0ZW1MYXN0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICB9O1xuICAgIExpbmtlZE1hcC5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rZWRNYXAucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24gKGl0ZW0sIHRvdWNoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRvdWNoICE9PSBUb3VjaC5Bc09sZCAmJiB0b3VjaCAhPT0gVG91Y2guQXNOZXcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoID09PSBUb3VjaC5Bc09sZCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW1cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCBoZWFkIGJ1dCBpcyB0YWlsXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCBoZWFkXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdm9pZCAwO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkFzTmV3KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExpbmtlZE1hcDtcbn0oKSk7XG5leHBvcnQgeyBMaW5rZWRNYXAgfTtcbnZhciBMUlVDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTFJVQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTFJVQ2FjaGUobGltaXQsIHJhdGlvKSB7XG4gICAgICAgIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7IHJhdGlvID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgX3RoaXMuX3JhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcmF0aW8pLCAxKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxpbWl0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJyYXRpb1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhdGlvO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywga2V5LCBUb3VjaC5Bc05ldyk7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywga2V5LCBUb3VjaC5Ob25lKTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUsIFRvdWNoLkFzTmV3KTtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5jaGVja1RyaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTFJVQ2FjaGU7XG59KExpbmtlZE1hcCkpO1xuZXhwb3J0IHsgTFJVQ2FjaGUgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/map.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/platform.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/platform.js ***!
  \*******************************************************************/
/*! exports provided: LANGUAGE_DEFAULT, Platform, isWindows, isMacintosh, isLinux, isNative, isWeb, platform, isRootUser, language, locale, translationsConfigFile, globals, setImmediate, OS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LANGUAGE_DEFAULT\", function() { return LANGUAGE_DEFAULT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform\", function() { return Platform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWindows\", function() { return isWindows; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isMacintosh\", function() { return isMacintosh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isLinux\", function() { return isLinux; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNative\", function() { return isNative; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWeb\", function() { return isWeb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"platform\", function() { return platform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRootUser\", function() { return isRootUser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"language\", function() { return language; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"locale\", function() { return locale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translationsConfigFile\", function() { return translationsConfigFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globals\", function() { return globals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setImmediate\", function() { return setImmediate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OS\", function() { return OS; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar _isWindows = false;\nvar _isMacintosh = false;\nvar _isLinux = false;\nvar _isNative = false;\nvar _isWeb = false;\nvar _locale = undefined;\nvar _language = undefined;\nvar _translationsConfigFile = undefined;\nvar LANGUAGE_DEFAULT = 'en';\n// OS detection\nif (typeof process === 'object' && typeof process.nextTick === 'function' && typeof process.platform === 'string') {\n    _isWindows = (process.platform === 'win32');\n    _isMacintosh = (process.platform === 'darwin');\n    _isLinux = (process.platform === 'linux');\n    var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];\n    if (rawNlsConfig) {\n        try {\n            var nlsConfig = JSON.parse(rawNlsConfig);\n            var resolved = nlsConfig.availableLanguages['*'];\n            _locale = nlsConfig.locale;\n            // VSCode's default language is 'en'\n            _language = resolved ? resolved : LANGUAGE_DEFAULT;\n            _translationsConfigFile = nlsConfig._translationsConfigFile;\n        }\n        catch (e) {\n        }\n    }\n    _isNative = true;\n}\nelse if (typeof navigator === 'object') {\n    var userAgent = navigator.userAgent;\n    _isWindows = userAgent.indexOf('Windows') >= 0;\n    _isMacintosh = userAgent.indexOf('Macintosh') >= 0;\n    _isLinux = userAgent.indexOf('Linux') >= 0;\n    _isWeb = true;\n    _locale = navigator.language;\n    _language = _locale;\n}\nvar Platform;\n(function (Platform) {\n    Platform[Platform[\"Web\"] = 0] = \"Web\";\n    Platform[Platform[\"Mac\"] = 1] = \"Mac\";\n    Platform[Platform[\"Linux\"] = 2] = \"Linux\";\n    Platform[Platform[\"Windows\"] = 3] = \"Windows\";\n})(Platform || (Platform = {}));\nvar _platform = Platform.Web;\nif (_isNative) {\n    if (_isMacintosh) {\n        _platform = Platform.Mac;\n    }\n    else if (_isWindows) {\n        _platform = Platform.Windows;\n    }\n    else if (_isLinux) {\n        _platform = Platform.Linux;\n    }\n}\nvar isWindows = _isWindows;\nvar isMacintosh = _isMacintosh;\nvar isLinux = _isLinux;\nvar isNative = _isNative;\nvar isWeb = _isWeb;\nvar platform = _platform;\nfunction isRootUser() {\n    return _isNative && !_isWindows && (process.getuid() === 0);\n}\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nvar language = _language;\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nvar locale = _locale;\n/**\n * The translatios that are available through language packs.\n */\nvar translationsConfigFile = _translationsConfigFile;\nvar _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});\nvar globals = _globals;\nvar _setImmediate = null;\nfunction setImmediate(callback) {\n    if (_setImmediate === null) {\n        if (globals.setImmediate) {\n            _setImmediate = globals.setImmediate.bind(globals);\n        }\n        else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n            _setImmediate = process.nextTick.bind(process);\n        }\n        else {\n            _setImmediate = globals.setTimeout.bind(globals);\n        }\n    }\n    return _setImmediate(callback);\n}\nvar OS = (_isMacintosh ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcGxhdGZvcm0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcGxhdGZvcm0uanM/MzBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfaXNXaW5kb3dzID0gZmFsc2U7XG52YXIgX2lzTWFjaW50b3NoID0gZmFsc2U7XG52YXIgX2lzTGludXggPSBmYWxzZTtcbnZhciBfaXNOYXRpdmUgPSBmYWxzZTtcbnZhciBfaXNXZWIgPSBmYWxzZTtcbnZhciBfbG9jYWxlID0gdW5kZWZpbmVkO1xudmFyIF9sYW5ndWFnZSA9IHVuZGVmaW5lZDtcbnZhciBfdHJhbnNsYXRpb25zQ29uZmlnRmlsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCB2YXIgTEFOR1VBR0VfREVGQVVMVCA9ICdlbic7XG4vLyBPUyBkZXRlY3Rpb25cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb2Nlc3MucGxhdGZvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgX2lzV2luZG93cyA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKTtcbiAgICBfaXNNYWNpbnRvc2ggPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuICAgIF9pc0xpbnV4ID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpO1xuICAgIHZhciByYXdObHNDb25maWcgPSBwcm9jZXNzLmVudlsnVlNDT0RFX05MU19DT05GSUcnXTtcbiAgICBpZiAocmF3TmxzQ29uZmlnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbmxzQ29uZmlnID0gSlNPTi5wYXJzZShyYXdObHNDb25maWcpO1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gbmxzQ29uZmlnLmF2YWlsYWJsZUxhbmd1YWdlc1snKiddO1xuICAgICAgICAgICAgX2xvY2FsZSA9IG5sc0NvbmZpZy5sb2NhbGU7XG4gICAgICAgICAgICAvLyBWU0NvZGUncyBkZWZhdWx0IGxhbmd1YWdlIGlzICdlbidcbiAgICAgICAgICAgIF9sYW5ndWFnZSA9IHJlc29sdmVkID8gcmVzb2x2ZWQgOiBMQU5HVUFHRV9ERUZBVUxUO1xuICAgICAgICAgICAgX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGUgPSBubHNDb25maWcuX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNOYXRpdmUgPSB0cnVlO1xufVxuZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBfaXNXaW5kb3dzID0gdXNlckFnZW50LmluZGV4T2YoJ1dpbmRvd3MnKSA+PSAwO1xuICAgIF9pc01hY2ludG9zaCA9IHVzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwO1xuICAgIF9pc0xpbnV4ID0gdXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgPj0gMDtcbiAgICBfaXNXZWIgPSB0cnVlO1xuICAgIF9sb2NhbGUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gICAgX2xhbmd1YWdlID0gX2xvY2FsZTtcbn1cbmV4cG9ydCB2YXIgUGxhdGZvcm07XG4oZnVuY3Rpb24gKFBsYXRmb3JtKSB7XG4gICAgUGxhdGZvcm1bUGxhdGZvcm1bXCJXZWJcIl0gPSAwXSA9IFwiV2ViXCI7XG4gICAgUGxhdGZvcm1bUGxhdGZvcm1bXCJNYWNcIl0gPSAxXSA9IFwiTWFjXCI7XG4gICAgUGxhdGZvcm1bUGxhdGZvcm1bXCJMaW51eFwiXSA9IDJdID0gXCJMaW51eFwiO1xuICAgIFBsYXRmb3JtW1BsYXRmb3JtW1wiV2luZG93c1wiXSA9IDNdID0gXCJXaW5kb3dzXCI7XG59KShQbGF0Zm9ybSB8fCAoUGxhdGZvcm0gPSB7fSkpO1xudmFyIF9wbGF0Zm9ybSA9IFBsYXRmb3JtLldlYjtcbmlmIChfaXNOYXRpdmUpIHtcbiAgICBpZiAoX2lzTWFjaW50b3NoKSB7XG4gICAgICAgIF9wbGF0Zm9ybSA9IFBsYXRmb3JtLk1hYztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzV2luZG93cykge1xuICAgICAgICBfcGxhdGZvcm0gPSBQbGF0Zm9ybS5XaW5kb3dzO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNMaW51eCkge1xuICAgICAgICBfcGxhdGZvcm0gPSBQbGF0Zm9ybS5MaW51eDtcbiAgICB9XG59XG5leHBvcnQgdmFyIGlzV2luZG93cyA9IF9pc1dpbmRvd3M7XG5leHBvcnQgdmFyIGlzTWFjaW50b3NoID0gX2lzTWFjaW50b3NoO1xuZXhwb3J0IHZhciBpc0xpbnV4ID0gX2lzTGludXg7XG5leHBvcnQgdmFyIGlzTmF0aXZlID0gX2lzTmF0aXZlO1xuZXhwb3J0IHZhciBpc1dlYiA9IF9pc1dlYjtcbmV4cG9ydCB2YXIgcGxhdGZvcm0gPSBfcGxhdGZvcm07XG5leHBvcnQgZnVuY3Rpb24gaXNSb290VXNlcigpIHtcbiAgICByZXR1cm4gX2lzTmF0aXZlICYmICFfaXNXaW5kb3dzICYmIChwcm9jZXNzLmdldHVpZCgpID09PSAwKTtcbn1cbi8qKlxuICogVGhlIGxhbmd1YWdlIHVzZWQgZm9yIHRoZSB1c2VyIGludGVyZmFjZS4gVGhlIGZvcm1hdCBvZlxuICogdGhlIHN0cmluZyBpcyBhbGwgbG93ZXIgY2FzZSAoZS5nLiB6aC10dyBmb3IgVHJhZGl0aW9uYWxcbiAqIENoaW5lc2UpXG4gKi9cbmV4cG9ydCB2YXIgbGFuZ3VhZ2UgPSBfbGFuZ3VhZ2U7XG4vKipcbiAqIFRoZSBPUyBsb2NhbGUgb3IgdGhlIGxvY2FsZSBzcGVjaWZpZWQgYnkgLS1sb2NhbGUuIFRoZSBmb3JtYXQgb2ZcbiAqIHRoZSBzdHJpbmcgaXMgYWxsIGxvd2VyIGNhc2UgKGUuZy4gemgtdHcgZm9yIFRyYWRpdGlvbmFsXG4gKiBDaGluZXNlKS4gVGhlIFVJIGlzIG5vdCBuZWNlc3NhcmlseSBzaG93biBpbiB0aGUgcHJvdmlkZWQgbG9jYWxlLlxuICovXG5leHBvcnQgdmFyIGxvY2FsZSA9IF9sb2NhbGU7XG4vKipcbiAqIFRoZSB0cmFuc2xhdGlvcyB0aGF0IGFyZSBhdmFpbGFibGUgdGhyb3VnaCBsYW5ndWFnZSBwYWNrcy5cbiAqL1xuZXhwb3J0IHZhciB0cmFuc2xhdGlvbnNDb25maWdGaWxlID0gX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGU7XG52YXIgX2dsb2JhbHMgPSAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnID8gc2VsZiA6IHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnID8gZ2xvYmFsIDoge30pO1xuZXhwb3J0IHZhciBnbG9iYWxzID0gX2dsb2JhbHM7XG52YXIgX3NldEltbWVkaWF0ZSA9IG51bGw7XG5leHBvcnQgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgaWYgKF9zZXRJbW1lZGlhdGUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGdsb2JhbHMuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgICAgICBfc2V0SW1tZWRpYXRlID0gZ2xvYmFscy5zZXRJbW1lZGlhdGUuYmluZChnbG9iYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9zZXRJbW1lZGlhdGUgPSBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc2V0SW1tZWRpYXRlID0gZ2xvYmFscy5zZXRUaW1lb3V0LmJpbmQoZ2xvYmFscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9zZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xufVxuZXhwb3J0IHZhciBPUyA9IChfaXNNYWNpbnRvc2ggPyAyIC8qIE1hY2ludG9zaCAqLyA6IChfaXNXaW5kb3dzID8gMSAvKiBXaW5kb3dzICovIDogMyAvKiBMaW51eCAqLykpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/platform.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/strings.js":
/*!******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/strings.js ***!
  \******************************************************************/
/*! exports provided: empty, isFalsyOrWhitespace, pad, format, escape, escapeRegExpCharacters, trim, ltrim, rtrim, convertSimple2RegExpPattern, stripWildcards, startsWith, endsWith, createRegExp, regExpLeadsToEndlessLoop, regExpContainsBackreference, canNormalize, normalizeNFC, normalizeNFD, firstNonWhitespaceIndex, getLeadingWhitespace, lastNonWhitespaceIndex, compare, compareIgnoreCase, equalsIgnoreCase, startsWithIgnoreCase, commonPrefixLength, commonSuffixLength, overlap, isHighSurrogate, isLowSurrogate, containsRTL, containsEmoji, isBasicASCII, containsFullWidthCharacter, isFullWidthCharacter, lcut, removeAnsiEscapeCodes, UTF8_BOM_CHARACTER, startsWithUTF8BOM, stripUTF8BOM, safeBtoa, repeat, fuzzyContains, containsUppercaseCharacter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFalsyOrWhitespace\", function() { return isFalsyOrWhitespace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pad\", function() { return pad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"escape\", function() { return escape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"escapeRegExpCharacters\", function() { return escapeRegExpCharacters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trim\", function() { return trim; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ltrim\", function() { return ltrim; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rtrim\", function() { return rtrim; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertSimple2RegExpPattern\", function() { return convertSimple2RegExpPattern; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripWildcards\", function() { return stripWildcards; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRegExp\", function() { return createRegExp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regExpLeadsToEndlessLoop\", function() { return regExpLeadsToEndlessLoop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regExpContainsBackreference\", function() { return regExpContainsBackreference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canNormalize\", function() { return canNormalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeNFC\", function() { return normalizeNFC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeNFD\", function() { return normalizeNFD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstNonWhitespaceIndex\", function() { return firstNonWhitespaceIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLeadingWhitespace\", function() { return getLeadingWhitespace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lastNonWhitespaceIndex\", function() { return lastNonWhitespaceIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compare\", function() { return compare; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareIgnoreCase\", function() { return compareIgnoreCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equalsIgnoreCase\", function() { return equalsIgnoreCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWithIgnoreCase\", function() { return startsWithIgnoreCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"commonPrefixLength\", function() { return commonPrefixLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"commonSuffixLength\", function() { return commonSuffixLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"overlap\", function() { return overlap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isHighSurrogate\", function() { return isHighSurrogate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isLowSurrogate\", function() { return isLowSurrogate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"containsRTL\", function() { return containsRTL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"containsEmoji\", function() { return containsEmoji; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBasicASCII\", function() { return isBasicASCII; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"containsFullWidthCharacter\", function() { return containsFullWidthCharacter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFullWidthCharacter\", function() { return isFullWidthCharacter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lcut\", function() { return lcut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeAnsiEscapeCodes\", function() { return removeAnsiEscapeCodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UTF8_BOM_CHARACTER\", function() { return UTF8_BOM_CHARACTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWithUTF8BOM\", function() { return startsWithUTF8BOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripUTF8BOM\", function() { return stripUTF8BOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"safeBtoa\", function() { return safeBtoa; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"repeat\", function() { return repeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fuzzyContains\", function() { return fuzzyContains; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"containsUppercaseCharacter\", function() { return containsUppercaseCharacter; });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"./node_modules/monaco-editor/esm/vs/base/common/map.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/**\n * The empty string.\n */\nvar empty = '';\nfunction isFalsyOrWhitespace(str) {\n    if (!str || typeof str !== 'string') {\n        return true;\n    }\n    return str.trim().length === 0;\n}\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nfunction pad(n, l, char) {\n    if (char === void 0) { char = '0'; }\n    var str = '' + n;\n    var r = [str];\n    for (var i = str.length; i < l; i++) {\n        r.push(char);\n    }\n    return r.reverse().join('');\n}\nvar _formatRegexp = /{(\\d+)}/g;\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nfunction format(value) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (args.length === 0) {\n        return value;\n    }\n    return value.replace(_formatRegexp, function (match, group) {\n        var idx = parseInt(group, 10);\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\n            match :\n            args[idx];\n    });\n}\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nfunction escape(html) {\n    return html.replace(/[<|>|&]/g, function (match) {\n        switch (match) {\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '&': return '&amp;';\n            default: return match;\n        }\n    });\n}\n/**\n * Escapes regular expression characters in a given string\n */\nfunction escapeRegExpCharacters(value) {\n    return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nfunction trim(haystack, needle) {\n    if (needle === void 0) { needle = ' '; }\n    var trimmed = ltrim(haystack, needle);\n    return rtrim(trimmed, needle);\n}\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nfunction ltrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    var needleLen = needle.length;\n    if (needleLen === 0 || haystack.length === 0) {\n        return haystack;\n    }\n    var offset = 0, idx = -1;\n    while ((idx = haystack.indexOf(needle, offset)) === offset) {\n        offset = offset + needleLen;\n    }\n    return haystack.substring(offset);\n}\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nfunction rtrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    var needleLen = needle.length, haystackLen = haystack.length;\n    if (needleLen === 0 || haystackLen === 0) {\n        return haystack;\n    }\n    var offset = haystackLen, idx = -1;\n    while (true) {\n        idx = haystack.lastIndexOf(needle, offset - 1);\n        if (idx === -1 || idx + needleLen !== offset) {\n            break;\n        }\n        if (idx === 0) {\n            return '';\n        }\n        offset = idx;\n    }\n    return haystack.substring(0, offset);\n}\nfunction convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nfunction stripWildcards(pattern) {\n    return pattern.replace(/\\*/g, '');\n}\n/**\n * Determines if haystack starts with needle.\n */\nfunction startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    if (haystack === needle) {\n        return true;\n    }\n    for (var i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\nfunction endsWith(haystack, needle) {\n    var diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.indexOf(needle, diff) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\nfunction createRegExp(searchString, isRegex, options) {\n    if (options === void 0) { options = {}; }\n    if (!searchString) {\n        throw new Error('Cannot create regex from empty string');\n    }\n    if (!isRegex) {\n        searchString = escapeRegExpCharacters(searchString);\n    }\n    if (options.wholeWord) {\n        if (!/\\B/.test(searchString.charAt(0))) {\n            searchString = '\\\\b' + searchString;\n        }\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n            searchString = searchString + '\\\\b';\n        }\n    }\n    var modifiers = '';\n    if (options.global) {\n        modifiers += 'g';\n    }\n    if (!options.matchCase) {\n        modifiers += 'i';\n    }\n    if (options.multiline) {\n        modifiers += 'm';\n    }\n    return new RegExp(searchString, modifiers);\n}\nfunction regExpLeadsToEndlessLoop(regexp) {\n    // Exit early if it's one of these special cases which are meant to match\n    // against an empty string\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n        return false;\n    }\n    // We check against an empty string. If the regular expression doesn't advance\n    // (e.g. ends in an endless loop) it will match an empty string.\n    var match = regexp.exec('');\n    return (match && regexp.lastIndex === 0);\n}\nfunction regExpContainsBackreference(regexpValue) {\n    return !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n/**\n * The normalize() method returns the Unicode Normalization Form of a given string. The form will be\n * the Normalization Form Canonical Composition.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}\n */\nvar canNormalize = typeof (''.normalize) === 'function';\nvar nfcCache = new _map_js__WEBPACK_IMPORTED_MODULE_0__[\"LRUCache\"](10000); // bounded to 10000 elements\nfunction normalizeNFC(str) {\n    return normalize(str, 'NFC', nfcCache);\n}\nvar nfdCache = new _map_js__WEBPACK_IMPORTED_MODULE_0__[\"LRUCache\"](10000); // bounded to 10000 elements\nfunction normalizeNFD(str) {\n    return normalize(str, 'NFD', nfdCache);\n}\nvar nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str, form, normalizedCache) {\n    if (!canNormalize || !str) {\n        return str;\n    }\n    var cached = normalizedCache.get(str);\n    if (cached) {\n        return cached;\n    }\n    var res;\n    if (nonAsciiCharactersPattern.test(str)) {\n        res = str.normalize(form);\n    }\n    else {\n        res = str;\n    }\n    // Use the cache for fast lookup\n    normalizedCache.set(str, res);\n    return res;\n}\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction firstNonWhitespaceIndex(str) {\n    for (var i = 0, len = str.length; i < len; i++) {\n        var chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nfunction getLeadingWhitespace(str, start, end) {\n    if (start === void 0) { start = 0; }\n    if (end === void 0) { end = str.length; }\n    for (var i = start; i < end; i++) {\n        var chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return str.substring(start, i);\n        }\n    }\n    return str.substring(start, end);\n}\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction lastNonWhitespaceIndex(str, startIndex) {\n    if (startIndex === void 0) { startIndex = str.length - 1; }\n    for (var i = startIndex; i >= 0; i--) {\n        var chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction compare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction compareIgnoreCase(a, b) {\n    var len = Math.min(a.length, b.length);\n    for (var i = 0; i < len; i++) {\n        var codeA = a.charCodeAt(i);\n        var codeB = b.charCodeAt(i);\n        if (codeA === codeB) {\n            // equal\n            continue;\n        }\n        if (isUpperAsciiLetter(codeA)) {\n            codeA += 32;\n        }\n        if (isUpperAsciiLetter(codeB)) {\n            codeB += 32;\n        }\n        var diff = codeA - codeB;\n        if (diff === 0) {\n            // equal -> ignoreCase\n            continue;\n        }\n        else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n            //\n            return diff;\n        }\n        else {\n            return compare(a.toLowerCase(), b.toLowerCase());\n        }\n    }\n    if (a.length < b.length) {\n        return -1;\n    }\n    else if (a.length > b.length) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction isLowerAsciiLetter(code) {\n    return code >= 97 /* a */ && code <= 122 /* z */;\n}\nfunction isUpperAsciiLetter(code) {\n    return code >= 65 /* A */ && code <= 90 /* Z */;\n}\nfunction isAsciiLetter(code) {\n    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\nfunction equalsIgnoreCase(a, b) {\n    var len1 = a ? a.length : 0;\n    var len2 = b ? b.length : 0;\n    if (len1 !== len2) {\n        return false;\n    }\n    return doEqualsIgnoreCase(a, b);\n}\nfunction doEqualsIgnoreCase(a, b, stopAt) {\n    if (stopAt === void 0) { stopAt = a.length; }\n    if (typeof a !== 'string' || typeof b !== 'string') {\n        return false;\n    }\n    for (var i = 0; i < stopAt; i++) {\n        var codeA = a.charCodeAt(i);\n        var codeB = b.charCodeAt(i);\n        if (codeA === codeB) {\n            continue;\n        }\n        // a-z A-Z\n        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n            var diff = Math.abs(codeA - codeB);\n            if (diff !== 0 && diff !== 32) {\n                return false;\n            }\n        }\n        else {\n            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction startsWithIgnoreCase(str, candidate) {\n    var candidateLength = candidate.length;\n    if (candidate.length > str.length) {\n        return false;\n    }\n    return doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n/**\n * @returns the length of the common prefix of the two strings.\n */\nfunction commonPrefixLength(a, b) {\n    var i, len = Math.min(a.length, b.length);\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * @returns the length of the common suffix of the two strings.\n */\nfunction commonSuffixLength(a, b) {\n    var i, len = Math.min(a.length, b.length);\n    var aLastIndex = a.length - 1;\n    var bLastIndex = b.length - 1;\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n            return i;\n        }\n    }\n    return len;\n}\nfunction substrEquals(a, aStart, aEnd, b, bStart, bEnd) {\n    while (aStart < aEnd && bStart < bEnd) {\n        if (a[aStart] !== b[bStart]) {\n            return false;\n        }\n        aStart += 1;\n        bStart += 1;\n    }\n    return true;\n}\n/**\n * Return the overlap between the suffix of `a` and the prefix of `b`.\n * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n */\nfunction overlap(a, b) {\n    var aEnd = a.length;\n    var bEnd = b.length;\n    var aStart = aEnd - bEnd;\n    if (aStart === 0) {\n        return a === b ? aEnd : 0;\n    }\n    else if (aStart < 0) {\n        bEnd += aStart;\n        aStart = 0;\n    }\n    while (aStart < aEnd && bEnd > 0) {\n        if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n            return bEnd;\n        }\n        bEnd -= 1;\n        aStart += 1;\n    }\n    return 0;\n}\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tlet chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tlet nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\nfunction isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\nfunction isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nvar CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nfunction containsRTL(str) {\n    return CONTAINS_RTL.test(str);\n}\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nvar CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\nfunction containsEmoji(str) {\n    return CONTAINS_EMOJI.test(str);\n}\nvar IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nfunction isBasicASCII(str) {\n    return IS_BASIC_ASCII.test(str);\n}\nfunction containsFullWidthCharacter(str) {\n    for (var i = 0, len = str.length; i < len; i++) {\n        if (isFullWidthCharacter(str.charCodeAt(i))) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isFullWidthCharacter(charCode) {\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n    // http://jrgraphix.net/research/unicode_blocks.php\n    //          2E80 — 2EFF   CJK Radicals Supplement\n    //          2F00 — 2FDF   Kangxi Radicals\n    //          2FF0 — 2FFF   Ideographic Description Characters\n    //          3000 — 303F   CJK Symbols and Punctuation\n    //          3040 — 309F   Hiragana\n    //          30A0 — 30FF   Katakana\n    //          3100 — 312F   Bopomofo\n    //          3130 — 318F   Hangul Compatibility Jamo\n    //          3190 — 319F   Kanbun\n    //          31A0 — 31BF   Bopomofo Extended\n    //          31F0 — 31FF   Katakana Phonetic Extensions\n    //          3200 — 32FF   Enclosed CJK Letters and Months\n    //          3300 — 33FF   CJK Compatibility\n    //          3400 — 4DBF   CJK Unified Ideographs Extension A\n    //          4DC0 — 4DFF   Yijing Hexagram Symbols\n    //          4E00 — 9FFF   CJK Unified Ideographs\n    //          A000 — A48F   Yi Syllables\n    //          A490 — A4CF   Yi Radicals\n    //          AC00 — D7AF   Hangul Syllables\n    // [IGNORE] D800 — DB7F   High Surrogates\n    // [IGNORE] DB80 — DBFF   High Private Use Surrogates\n    // [IGNORE] DC00 — DFFF   Low Surrogates\n    // [IGNORE] E000 — F8FF   Private Use Area\n    //          F900 — FAFF   CJK Compatibility Ideographs\n    // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n    // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n    // [IGNORE] FE00 — FE0F   Variation Selectors\n    // [IGNORE] FE20 — FE2F   Combining Half Marks\n    // [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n    // [IGNORE] FE50 — FE6F   Small Form Variants\n    // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n    //          FF00 — FFEF   Halfwidth and Fullwidth Forms\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n    // [IGNORE] FFF0 — FFFF   Specials\n    charCode = +charCode; // @perf\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\n}\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nfunction lcut(text, n) {\n    if (text.length < n) {\n        return text;\n    }\n    var re = /\\b/g;\n    var i = 0;\n    while (re.test(text)) {\n        if (text.length - re.lastIndex < n) {\n            break;\n        }\n        i = re.lastIndex;\n        re.lastIndex += 1;\n    }\n    return text.substring(i).replace(/^\\s/, empty);\n}\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nvar EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nvar COLOR_START = /\\x1b\\[\\d+m/g; // Color\nvar COLOR_END = /\\x1b\\[0?m/g; // Color\nfunction removeAnsiEscapeCodes(str) {\n    if (str) {\n        str = str.replace(EL, '');\n        str = str.replace(COLOR_START, '');\n        str = str.replace(COLOR_END, '');\n    }\n    return str;\n}\n// -- UTF-8 BOM\nvar UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);\nfunction startsWithUTF8BOM(str) {\n    return (str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);\n}\nfunction stripUTF8BOM(str) {\n    return startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\nfunction safeBtoa(str) {\n    return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nfunction fuzzyContains(target, query) {\n    if (!target || !query) {\n        return false; // return early if target or query are undefined\n    }\n    if (target.length < query.length) {\n        return false; // impossible for query to be contained in target\n    }\n    var queryLen = query.length;\n    var targetLower = target.toLowerCase();\n    var index = 0;\n    var lastIndexOf = -1;\n    while (index < queryLen) {\n        var indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n        if (indexOf < 0) {\n            return false;\n        }\n        lastIndexOf = indexOf;\n        index++;\n    }\n    return true;\n}\nfunction containsUppercaseCharacter(target, ignoreEscapedChars) {\n    if (ignoreEscapedChars === void 0) { ignoreEscapedChars = false; }\n    if (!target) {\n        return false;\n    }\n    if (ignoreEscapedChars) {\n        target = target.replace(/\\\\./g, '');\n    }\n    return target.toLowerCase() !== target;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3RyaW5ncy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzPzM3NDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBMUlVDYWNoZSB9IGZyb20gJy4vbWFwLmpzJztcbi8qKlxuICogVGhlIGVtcHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0IHZhciBlbXB0eSA9ICcnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPcldoaXRlc3BhY2Uoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdHIudHJpbSgpLmxlbmd0aCA9PT0gMDtcbn1cbi8qKlxuICogQHJldHVybnMgdGhlIHByb3ZpZGVkIG51bWJlciB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2YgcHJlY2VkaW5nIHplcm9zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKG4sIGwsIGNoYXIpIHtcbiAgICBpZiAoY2hhciA9PT0gdm9pZCAwKSB7IGNoYXIgPSAnMCc7IH1cbiAgICB2YXIgc3RyID0gJycgKyBuO1xuICAgIHZhciByID0gW3N0cl07XG4gICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgci5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gci5yZXZlcnNlKCkuam9pbignJyk7XG59XG52YXIgX2Zvcm1hdFJlZ2V4cCA9IC97KFxcZCspfS9nO1xuLyoqXG4gKiBIZWxwZXIgdG8gcHJvZHVjZSBhIHN0cmluZyB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cy4gSW5zZXJ0IHZhcmlhYmxlIHNlZ21lbnRzXG4gKiBpbnRvIHRoZSBzdHJpbmcgdXNpbmcgdGhlIHtufSBub3RhdGlvbiB3aGVyZSBOIGlzIHRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgZm9sbG93aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHRvIHdoaWNoIGZvcm1hdHRpbmcgaXMgYXBwbGllZFxuICogQHBhcmFtIGFyZ3MgcmVwbGFjZW1lbnRzIGZvciB7bn0tZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShfZm9ybWF0UmVnZXhwLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwKSB7XG4gICAgICAgIHZhciBpZHggPSBwYXJzZUludChncm91cCwgMTApO1xuICAgICAgICByZXR1cm4gaXNOYU4oaWR4KSB8fCBpZHggPCAwIHx8IGlkeCA+PSBhcmdzLmxlbmd0aCA/XG4gICAgICAgICAgICBtYXRjaCA6XG4gICAgICAgICAgICBhcmdzW2lkeF07XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIEhUTUwgY2hhcmFjdGVycyBpbnNpZGUgdGhlIHN0cmluZyB0byB1c2UgZW50aXRpZXMgaW5zdGVhZC4gTWFrZXMgdGhlIHN0cmluZyBzYWZlIGZyb21cbiAqIGJlaW5nIHVzZWQgZS5nLiBpbiBIVE1MRWxlbWVudC5pbm5lckhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUoaHRtbCkge1xuICAgIHJldHVybiBodG1sLnJlcGxhY2UoL1s8fD58Jl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgJzwnOiByZXR1cm4gJyZsdDsnO1xuICAgICAgICAgICAgY2FzZSAnPic6IHJldHVybiAnJmd0Oyc7XG4gICAgICAgICAgICBjYXNlICcmJzogcmV0dXJuICcmYW1wOyc7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogRXNjYXBlcyByZWd1bGFyIGV4cHJlc3Npb24gY2hhcmFjdGVycyBpbiBhIGdpdmVuIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxcXFxce1xcfVxcKlxcK1xcP1xcfFxcXlxcJFxcLlxcW1xcXVxcKFxcKVxcI10vZywgJ1xcXFwkJicpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgaGF5c3RhY2suXG4gKiBAcGFyYW0gaGF5c3RhY2sgc3RyaW5nIHRvIHRyaW1cbiAqIEBwYXJhbSBuZWVkbGUgdGhlIHRoaW5nIHRvIHRyaW0gKGRlZmF1bHQgaXMgYSBibGFuaylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmIChuZWVkbGUgPT09IHZvaWQgMCkgeyBuZWVkbGUgPSAnICc7IH1cbiAgICB2YXIgdHJpbW1lZCA9IGx0cmltKGhheXN0YWNrLCBuZWVkbGUpO1xuICAgIHJldHVybiBydHJpbSh0cmltbWVkLCBuZWVkbGUpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGhheXN0YWNrLlxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsdHJpbShoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgdmFyIG5lZWRsZUxlbiA9IG5lZWRsZS5sZW5ndGg7XG4gICAgaWYgKG5lZWRsZUxlbiA9PT0gMCB8fCBoYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gMCwgaWR4ID0gLTE7XG4gICAgd2hpbGUgKChpZHggPSBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgb2Zmc2V0KSkgPT09IG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBuZWVkbGVMZW47XG4gICAgfVxuICAgIHJldHVybiBoYXlzdGFjay5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgb2NjdXJyZW5jZXMgb2YgbmVlZGxlIGZyb20gdGhlIGVuZCBvZiBoYXlzdGFjay5cbiAqIEBwYXJhbSBoYXlzdGFjayBzdHJpbmcgdG8gdHJpbVxuICogQHBhcmFtIG5lZWRsZSB0aGUgdGhpbmcgdG8gdHJpbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnRyaW0oaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmICghaGF5c3RhY2sgfHwgIW5lZWRsZSkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XG4gICAgfVxuICAgIHZhciBuZWVkbGVMZW4gPSBuZWVkbGUubGVuZ3RoLCBoYXlzdGFja0xlbiA9IGhheXN0YWNrLmxlbmd0aDtcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrTGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGhheXN0YWNrTGVuLCBpZHggPSAtMTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZHggPSBoYXlzdGFjay5sYXN0SW5kZXhPZihuZWVkbGUsIG9mZnNldCAtIDEpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSB8fCBpZHggKyBuZWVkbGVMZW4gIT09IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLnN1YnN0cmluZygwLCBvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9bXFwqXS9nLCAnLionKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFdpbGRjYXJkcyhwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvXFwqL2csICcnKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBoYXlzdGFjayBzdGFydHMgd2l0aCBuZWVkbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICBpZiAoaGF5c3RhY2subGVuZ3RoIDwgbmVlZGxlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChoYXlzdGFjayA9PT0gbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lZWRsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGF5c3RhY2tbaV0gIT09IG5lZWRsZVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGhheXN0YWNrIGVuZHMgd2l0aCBuZWVkbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgdmFyIGRpZmYgPSBoYXlzdGFjay5sZW5ndGggLSBuZWVkbGUubGVuZ3RoO1xuICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUsIGRpZmYpID09PSBkaWZmO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjayA9PT0gbmVlZGxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWdFeHAoc2VhcmNoU3RyaW5nLCBpc1JlZ2V4LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBpZiAoIXNlYXJjaFN0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcmVnZXggZnJvbSBlbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCFpc1JlZ2V4KSB7XG4gICAgICAgIHNlYXJjaFN0cmluZyA9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc2VhcmNoU3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2hvbGVXb3JkKSB7XG4gICAgICAgIGlmICghL1xcQi8udGVzdChzZWFyY2hTdHJpbmcuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgc2VhcmNoU3RyaW5nID0gJ1xcXFxiJyArIHNlYXJjaFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdChzZWFyY2hTdHJpbmcubGVuZ3RoIC0gMSkpKSB7XG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmcgKyAnXFxcXGInO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtb2RpZmllcnMgPSAnJztcbiAgICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICdnJztcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLm1hdGNoQ2FzZSkge1xuICAgICAgICBtb2RpZmllcnMgKz0gJ2knO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tdWx0aWxpbmUpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICdtJztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoU3RyaW5nLCBtb2RpZmllcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ0V4cExlYWRzVG9FbmRsZXNzTG9vcChyZWdleHApIHtcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGl0J3Mgb25lIG9mIHRoZXNlIHNwZWNpYWwgY2FzZXMgd2hpY2ggYXJlIG1lYW50IHRvIG1hdGNoXG4gICAgLy8gYWdhaW5zdCBhbiBlbXB0eSBzdHJpbmdcbiAgICBpZiAocmVnZXhwLnNvdXJjZSA9PT0gJ14nIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICdeJCcgfHwgcmVnZXhwLnNvdXJjZSA9PT0gJyQnIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICdeXFxcXHMqJCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBjaGVjayBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IGFkdmFuY2VcbiAgICAvLyAoZS5nLiBlbmRzIGluIGFuIGVuZGxlc3MgbG9vcCkgaXQgd2lsbCBtYXRjaCBhbiBlbXB0eSBzdHJpbmcuXG4gICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMoJycpO1xuICAgIHJldHVybiAobWF0Y2ggJiYgcmVnZXhwLmxhc3RJbmRleCA9PT0gMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVnRXhwQ29udGFpbnNCYWNrcmVmZXJlbmNlKHJlZ2V4cFZhbHVlKSB7XG4gICAgcmV0dXJuICEhcmVnZXhwVmFsdWUubWF0Y2goLyhbXlxcXFxdfF4pKFxcXFxcXFxcKSpcXFxcXFxkKy8pO1xufVxuLyoqXG4gKiBUaGUgbm9ybWFsaXplKCkgbWV0aG9kIHJldHVybnMgdGhlIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIG9mIGEgZ2l2ZW4gc3RyaW5nLiBUaGUgZm9ybSB3aWxsIGJlXG4gKiB0aGUgTm9ybWFsaXphdGlvbiBGb3JtIENhbm9uaWNhbCBDb21wb3NpdGlvbi5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplfVxuICovXG5leHBvcnQgdmFyIGNhbk5vcm1hbGl6ZSA9IHR5cGVvZiAoJycubm9ybWFsaXplKSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBuZmNDYWNoZSA9IG5ldyBMUlVDYWNoZSgxMDAwMCk7IC8vIGJvdW5kZWQgdG8gMTAwMDAgZWxlbWVudHNcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVORkMoc3RyKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShzdHIsICdORkMnLCBuZmNDYWNoZSk7XG59XG52YXIgbmZkQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMTAwMDApOyAvLyBib3VuZGVkIHRvIDEwMDAwIGVsZW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTkZEKHN0cikge1xuICAgIHJldHVybiBub3JtYWxpemUoc3RyLCAnTkZEJywgbmZkQ2FjaGUpO1xufVxudmFyIG5vbkFzY2lpQ2hhcmFjdGVyc1BhdHRlcm4gPSAvW15cXHUwMDAwLVxcdTAwODBdLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIsIGZvcm0sIG5vcm1hbGl6ZWRDYWNoZSkge1xuICAgIGlmICghY2FuTm9ybWFsaXplIHx8ICFzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIGNhY2hlZCA9IG5vcm1hbGl6ZWRDYWNoZS5nZXQoc3RyKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIHZhciByZXM7XG4gICAgaWYgKG5vbkFzY2lpQ2hhcmFjdGVyc1BhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIHJlcyA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSBzdHI7XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgY2FjaGUgZm9yIGZhc3QgbG9va3VwXG4gICAgbm9ybWFsaXplZENhY2hlLnNldChzdHIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogUmV0dXJucyBmaXJzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY2hDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaENvZGUgIT09IDMyIC8qIFNwYWNlICovICYmIGNoQ29kZSAhPT0gOSAvKiBUYWIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIG9mIHRoZSBzdHJpbmcuXG4gKiBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZXMsIHJldHVybnMgZW50aXJlIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVhZGluZ1doaXRlc3BhY2Uoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHN0ci5sZW5ndGg7IH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB2YXIgY2hDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaENvZGUgIT09IDMyIC8qIFNwYWNlICovICYmIGNoQ29kZSAhPT0gOSAvKiBUYWIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUmV0dXJucyBsYXN0IGluZGV4IG9mIHRoZSBzdHJpbmcgdGhhdCBpcyBub3Qgd2hpdGVzcGFjZS5cbiAqIElmIHN0cmluZyBpcyBlbXB0eSBvciBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLCByZXR1cm5zIC0xXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXN0Tm9uV2hpdGVzcGFjZUluZGV4KHN0ciwgc3RhcnRJbmRleCkge1xuICAgIGlmIChzdGFydEluZGV4ID09PSB2b2lkIDApIHsgc3RhcnRJbmRleCA9IHN0ci5sZW5ndGggLSAxOyB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIFRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVJZ25vcmVDYXNlKGEsIGIpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlQSA9IGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNvZGVCID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZUEgPT09IGNvZGVCKSB7XG4gICAgICAgICAgICAvLyBlcXVhbFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVXBwZXJBc2NpaUxldHRlcihjb2RlQSkpIHtcbiAgICAgICAgICAgIGNvZGVBICs9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZUIpKSB7XG4gICAgICAgICAgICBjb2RlQiArPSAzMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZiA9IGNvZGVBIC0gY29kZUI7XG4gICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAvLyBlcXVhbCAtPiBpZ25vcmVDYXNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZUEpICYmIGlzTG93ZXJBc2NpaUxldHRlcihjb2RlQikpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGEudG9Mb3dlckNhc2UoKSwgYi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDk3IC8qIGEgKi8gJiYgY29kZSA8PSAxMjIgLyogeiAqLztcbn1cbmZ1bmN0aW9uIGlzVXBwZXJBc2NpaUxldHRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gNjUgLyogQSAqLyAmJiBjb2RlIDw9IDkwIC8qIFogKi87XG59XG5mdW5jdGlvbiBpc0FzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gaXNMb3dlckFzY2lpTGV0dGVyKGNvZGUpIHx8IGlzVXBwZXJBc2NpaUxldHRlcihjb2RlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHNJZ25vcmVDYXNlKGEsIGIpIHtcbiAgICB2YXIgbGVuMSA9IGEgPyBhLmxlbmd0aCA6IDA7XG4gICAgdmFyIGxlbjIgPSBiID8gYi5sZW5ndGggOiAwO1xuICAgIGlmIChsZW4xICE9PSBsZW4yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRvRXF1YWxzSWdub3JlQ2FzZShhLCBiKTtcbn1cbmZ1bmN0aW9uIGRvRXF1YWxzSWdub3JlQ2FzZShhLCBiLCBzdG9wQXQpIHtcbiAgICBpZiAoc3RvcEF0ID09PSB2b2lkIDApIHsgc3RvcEF0ID0gYS5sZW5ndGg7IH1cbiAgICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcEF0OyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVBID0gYS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY29kZUIgPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlQSA9PT0gY29kZUIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEteiBBLVpcbiAgICAgICAgaWYgKGlzQXNjaWlMZXR0ZXIoY29kZUEpICYmIGlzQXNjaWlMZXR0ZXIoY29kZUIpKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGNvZGVBIC0gY29kZUIpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IDAgJiYgZGlmZiAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlQSkudG9Mb3dlckNhc2UoKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlQikudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoSWdub3JlQ2FzZShzdHIsIGNhbmRpZGF0ZSkge1xuICAgIHZhciBjYW5kaWRhdGVMZW5ndGggPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkb0VxdWFsc0lnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZUxlbmd0aCk7XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBwcmVmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uUHJlZml4TGVuZ3RoKGEsIGIpIHtcbiAgICB2YXIgaSwgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGEuY2hhckNvZGVBdChpKSAhPT0gYi5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBAcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBjb21tb24gc3VmZml4IG9mIHRoZSB0d28gc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblN1ZmZpeExlbmd0aChhLCBiKSB7XG4gICAgdmFyIGksIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgdmFyIGFMYXN0SW5kZXggPSBhLmxlbmd0aCAtIDE7XG4gICAgdmFyIGJMYXN0SW5kZXggPSBiLmxlbmd0aCAtIDE7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChhLmNoYXJDb2RlQXQoYUxhc3RJbmRleCAtIGkpICE9PSBiLmNoYXJDb2RlQXQoYkxhc3RJbmRleCAtIGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gc3Vic3RyRXF1YWxzKGEsIGFTdGFydCwgYUVuZCwgYiwgYlN0YXJ0LCBiRW5kKSB7XG4gICAgd2hpbGUgKGFTdGFydCA8IGFFbmQgJiYgYlN0YXJ0IDwgYkVuZCkge1xuICAgICAgICBpZiAoYVthU3RhcnRdICE9PSBiW2JTdGFydF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhU3RhcnQgKz0gMTtcbiAgICAgICAgYlN0YXJ0ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGUgc3VmZml4IG9mIGBhYCBhbmQgdGhlIHByZWZpeCBvZiBgYmAuXG4gKiBGb3IgaW5zdGFuY2UgYG92ZXJsYXAoXCJmb29iYXJcIiwgXCJhcnIsIEknbSBhIHBpcmF0ZVwiKSA9PT0gMmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdmVybGFwKGEsIGIpIHtcbiAgICB2YXIgYUVuZCA9IGEubGVuZ3RoO1xuICAgIHZhciBiRW5kID0gYi5sZW5ndGg7XG4gICAgdmFyIGFTdGFydCA9IGFFbmQgLSBiRW5kO1xuICAgIGlmIChhU3RhcnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyBhRW5kIDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVN0YXJ0IDwgMCkge1xuICAgICAgICBiRW5kICs9IGFTdGFydDtcbiAgICAgICAgYVN0YXJ0ID0gMDtcbiAgICB9XG4gICAgd2hpbGUgKGFTdGFydCA8IGFFbmQgJiYgYkVuZCA+IDApIHtcbiAgICAgICAgaWYgKHN1YnN0ckVxdWFscyhhLCBhU3RhcnQsIGFFbmQsIGIsIDAsIGJFbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gYkVuZDtcbiAgICAgICAgfVxuICAgICAgICBiRW5kIC09IDE7XG4gICAgICAgIGFTdGFydCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIC0tLSB1bmljb2RlXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cnJvZ2F0ZV9wYWlyXG4vLyBSZXR1cm5zIHRoZSBjb2RlIHBvaW50IHN0YXJ0aW5nIGF0IGEgc3BlY2lmaWVkIGluZGV4IGluIGEgc3RyaW5nXG4vLyBDb2RlIHBvaW50cyBVKzAwMDAgdG8gVStEN0ZGIGFuZCBVK0UwMDAgdG8gVStGRkZGIGFyZSByZXByZXNlbnRlZCBvbiBhIHNpbmdsZSBjaGFyYWN0ZXJcbi8vIENvZGUgcG9pbnRzIFUrMTAwMDAgdG8gVSsxMEZGRkYgYXJlIHJlcHJlc2VudGVkIG9uIHR3byBjb25zZWN1dGl2ZSBjaGFyYWN0ZXJzXG4vL2V4cG9ydCBmdW5jdGlvbiBnZXRVbmljb2RlUG9pbnQoc3RyOnN0cmluZywgaW5kZXg6bnVtYmVyLCBsZW46bnVtYmVyKTpudW1iZXIge1xuLy9cdGxldCBjaHJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuLy9cdGlmICgweEQ4MDAgPD0gY2hyQ29kZSAmJiBjaHJDb2RlIDw9IDB4REJGRiAmJiBpbmRleCArIDEgPCBsZW4pIHtcbi8vXHRcdGxldCBuZXh0Q2hyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4vL1x0XHRpZiAoMHhEQzAwIDw9IG5leHRDaHJDb2RlICYmIG5leHRDaHJDb2RlIDw9IDB4REZGRikge1xuLy9cdFx0XHRyZXR1cm4gKGNockNvZGUgLSAweEQ4MDApIDw8IDEwICsgKG5leHRDaHJDb2RlIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4vL1x0XHR9XG4vL1x0fVxuLy9cdHJldHVybiBjaHJDb2RlO1xuLy99XG5leHBvcnQgZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgweEQ4MDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhEQkZGKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkge1xuICAgIHJldHVybiAoMHhEQzAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDB4REZGRik7XG59XG4vKipcbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGFuZHJ1ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFzdGVyL2dlbmVyYXRlLXJ0bC10ZXN0LmpzXG4gKi9cbnZhciBDT05UQUlOU19SVEwgPSAvKD86W1xcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUQwLVxcdTA1RjRcXHUwNjA4XFx1MDYwQlxcdTA2MERcXHUwNjFCLVxcdTA2NEFcXHUwNjZELVxcdTA2NkZcXHUwNjcxLVxcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODMwLVxcdTA4NThcXHUwODVFLVxcdTA4QkRcXHUyMDBGXFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkQzRFxcdUZENTAtXFx1RkRGQ1xcdUZFNzAtXFx1RkVGQ118XFx1RDgwMltcXHVEQzAwLVxcdUREMUJcXHVERDIwLVxcdURFMDBcXHVERTEwLVxcdURFMzNcXHVERTQwLVxcdURFRTRcXHVERUVCLVxcdURGMzVcXHVERjQwLVxcdURGRkZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQ0ZGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENTAtXFx1REZGRl18XFx1RDgzQltcXHVEQzAwLVxcdURFQkJdKS87XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBjb250YWlucyBhbnkgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBpcyBjbGFzc2lmaWVkIGFzIFwiUlwiIG9yIFwiQUxcIi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUlRMKHN0cikge1xuICAgIHJldHVybiBDT05UQUlOU19SVEwudGVzdChzdHIpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhhbmRydWRpbWEvdW5pY29kZS11dGlscy9ibG9iL21hc3Rlci9nZW5lcmF0ZS1lbW9qaS10ZXN0LmpzXG4gKi9cbnZhciBDT05UQUlOU19FTU9KSSA9IC8oPzpbXFx1MjMxQVxcdTIzMUJcXHUyM0YwXFx1MjNGM1xcdTI2MDAtXFx1MjdCRlxcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURERTYtXFx1RERGRlxcdURGMDAtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURFNEZcXHVERTgwLVxcdURFRjhdfFxcdUQ4M0VbXFx1REQwMC1cXHVEREU2XSkvO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRW1vamkoc3RyKSB7XG4gICAgcmV0dXJuIENPTlRBSU5TX0VNT0pJLnRlc3Qoc3RyKTtcbn1cbnZhciBJU19CQVNJQ19BU0NJSSA9IC9eW1xcdFxcblxcclxceDIwLVxceDdFXSokLztcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIG9ubHkgYmFzaWMgQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgMzIgLSAxMjYgKGluY2x1ZGluZyAzMiBhbmQgMTI2KSBvciBcXG4sIFxcciwgXFx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2ljQVNDSUkoc3RyKSB7XG4gICAgcmV0dXJuIElTX0JBU0lDX0FTQ0lJLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Z1bGxXaWR0aENoYXJhY3RlcihzdHIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpc0Z1bGxXaWR0aENoYXJhY3RlcihzdHIuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGxXaWR0aENoYXJhY3RlcihjaGFyQ29kZSkge1xuICAgIC8vIERvIGEgY2hlYXAgdHJpY2sgdG8gYmV0dGVyIHN1cHBvcnQgd3JhcHBpbmcgb2Ygd2lkZSBjaGFyYWN0ZXJzLCB0cmVhdCB0aGVtIGFzIDIgY29sdW1uc1xuICAgIC8vIGh0dHA6Ly9qcmdyYXBoaXgubmV0L3Jlc2VhcmNoL3VuaWNvZGVfYmxvY2tzLnBocFxuICAgIC8vICAgICAgICAgIDJFODAg4oCUIDJFRkYgICBDSksgUmFkaWNhbHMgU3VwcGxlbWVudFxuICAgIC8vICAgICAgICAgIDJGMDAg4oCUIDJGREYgICBLYW5neGkgUmFkaWNhbHNcbiAgICAvLyAgICAgICAgICAyRkYwIOKAlCAyRkZGICAgSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1xuICAgIC8vICAgICAgICAgIDMwMDAg4oCUIDMwM0YgICBDSksgU3ltYm9scyBhbmQgUHVuY3R1YXRpb25cbiAgICAvLyAgICAgICAgICAzMDQwIOKAlCAzMDlGICAgSGlyYWdhbmFcbiAgICAvLyAgICAgICAgICAzMEEwIOKAlCAzMEZGICAgS2F0YWthbmFcbiAgICAvLyAgICAgICAgICAzMTAwIOKAlCAzMTJGICAgQm9wb21vZm9cbiAgICAvLyAgICAgICAgICAzMTMwIOKAlCAzMThGICAgSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xuICAgIC8vICAgICAgICAgIDMxOTAg4oCUIDMxOUYgICBLYW5idW5cbiAgICAvLyAgICAgICAgICAzMUEwIOKAlCAzMUJGICAgQm9wb21vZm8gRXh0ZW5kZWRcbiAgICAvLyAgICAgICAgICAzMUYwIOKAlCAzMUZGICAgS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1xuICAgIC8vICAgICAgICAgIDMyMDAg4oCUIDMyRkYgICBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXG4gICAgLy8gICAgICAgICAgMzMwMCDigJQgMzNGRiAgIENKSyBDb21wYXRpYmlsaXR5XG4gICAgLy8gICAgICAgICAgMzQwMCDigJQgNERCRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcbiAgICAvLyAgICAgICAgICA0REMwIOKAlCA0REZGICAgWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICAvLyAgICAgICAgICA0RTAwIOKAlCA5RkZGICAgQ0pLIFVuaWZpZWQgSWRlb2dyYXBoc1xuICAgIC8vICAgICAgICAgIEEwMDAg4oCUIEE0OEYgICBZaSBTeWxsYWJsZXNcbiAgICAvLyAgICAgICAgICBBNDkwIOKAlCBBNENGICAgWWkgUmFkaWNhbHNcbiAgICAvLyAgICAgICAgICBBQzAwIOKAlCBEN0FGICAgSGFuZ3VsIFN5bGxhYmxlc1xuICAgIC8vIFtJR05PUkVdIEQ4MDAg4oCUIERCN0YgICBIaWdoIFN1cnJvZ2F0ZXNcbiAgICAvLyBbSUdOT1JFXSBEQjgwIOKAlCBEQkZGICAgSGlnaCBQcml2YXRlIFVzZSBTdXJyb2dhdGVzXG4gICAgLy8gW0lHTk9SRV0gREMwMCDigJQgREZGRiAgIExvdyBTdXJyb2dhdGVzXG4gICAgLy8gW0lHTk9SRV0gRTAwMCDigJQgRjhGRiAgIFByaXZhdGUgVXNlIEFyZWFcbiAgICAvLyAgICAgICAgICBGOTAwIOKAlCBGQUZGICAgQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuICAgIC8vIFtJR05PUkVdIEZCMDAg4oCUIEZCNEYgICBBbHBoYWJldGljIFByZXNlbnRhdGlvbiBGb3Jtc1xuICAgIC8vIFtJR05PUkVdIEZCNTAg4oCUIEZERkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcbiAgICAvLyBbSUdOT1JFXSBGRTAwIOKAlCBGRTBGICAgVmFyaWF0aW9uIFNlbGVjdG9yc1xuICAgIC8vIFtJR05PUkVdIEZFMjAg4oCUIEZFMkYgICBDb21iaW5pbmcgSGFsZiBNYXJrc1xuICAgIC8vIFtJR05PUkVdIEZFMzAg4oCUIEZFNEYgICBDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1xuICAgIC8vIFtJR05PUkVdIEZFNTAg4oCUIEZFNkYgICBTbWFsbCBGb3JtIFZhcmlhbnRzXG4gICAgLy8gW0lHTk9SRV0gRkU3MCDigJQgRkVGRiAgIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlxuICAgIC8vICAgICAgICAgIEZGMDAg4oCUIEZGRUYgICBIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1xuICAgIC8vICAgICAgICAgICAgICAgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbGZ3aWR0aF9hbmRfZnVsbHdpZHRoX2Zvcm1zXVxuICAgIC8vICAgICAgICAgICAgICAgb2Ygd2hpY2ggRkYwMSAtIEZGNUUgZnVsbHdpZHRoIEFTQ0lJIG9mIDIxIHRvIDdFXG4gICAgLy8gW0lHTk9SRV0gICAgYW5kIEZGNjUgLSBGRkRDIGhhbGZ3aWR0aCBvZiBLYXRha2FuYSBhbmQgSGFuZ3VsXG4gICAgLy8gW0lHTk9SRV0gRkZGMCDigJQgRkZGRiAgIFNwZWNpYWxzXG4gICAgY2hhckNvZGUgPSArY2hhckNvZGU7IC8vIEBwZXJmXG4gICAgcmV0dXJuICgoY2hhckNvZGUgPj0gMHgyRTgwICYmIGNoYXJDb2RlIDw9IDB4RDdBRilcbiAgICAgICAgfHwgKGNoYXJDb2RlID49IDB4RjkwMCAmJiBjaGFyQ29kZSA8PSAweEZBRkYpXG4gICAgICAgIHx8IChjaGFyQ29kZSA+PSAweEZGMDEgJiYgY2hhckNvZGUgPD0gMHhGRjVFKSk7XG59XG4vKipcbiAqIEdpdmVuIGEgc3RyaW5nIGFuZCBhIG1heCBsZW5ndGggcmV0dXJucyBhIHNob3J0ZWQgdmVyc2lvbi4gU2hvcnRpbmdcbiAqIGhhcHBlbnMgYXQgZmF2b3JhYmxlIHBvc2l0aW9ucyAtIHN1Y2ggYXMgd2hpdGVzcGFjZSBvciBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGN1dCh0ZXh0LCBuKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoIDwgbikge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgdmFyIHJlID0gL1xcYi9nO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocmUudGVzdCh0ZXh0KSkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggLSByZS5sYXN0SW5kZXggPCBuKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGkpLnJlcGxhY2UoL15cXHMvLCBlbXB0eSk7XG59XG4vLyBFc2NhcGUgY29kZXNcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZVxudmFyIEVMID0gL1xceDFCXFx4NUJbMTJdP0svZzsgLy8gRXJhc2UgaW4gbGluZVxudmFyIENPTE9SX1NUQVJUID0gL1xceDFiXFxbXFxkK20vZzsgLy8gQ29sb3JcbnZhciBDT0xPUl9FTkQgPSAvXFx4MWJcXFswP20vZzsgLy8gQ29sb3JcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbnNpRXNjYXBlQ29kZXMoc3RyKSB7XG4gICAgaWYgKHN0cikge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShFTCwgJycpO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShDT0xPUl9TVEFSVCwgJycpO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShDT0xPUl9FTkQsICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8vIC0tIFVURi04IEJPTVxuZXhwb3J0IHZhciBVVEY4X0JPTV9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1Mjc5IC8qIFVURjhfQk9NICovKTtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoVVRGOEJPTShzdHIpIHtcbiAgICByZXR1cm4gKHN0ciAmJiBzdHIubGVuZ3RoID4gMCAmJiBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkgLyogVVRGOF9CT00gKi8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVVRGOEJPTShzdHIpIHtcbiAgICByZXR1cm4gc3RhcnRzV2l0aFVURjhCT00oc3RyKSA/IHN0ci5zdWJzdHIoMSkgOiBzdHI7XG59XG5leHBvcnQgZnVuY3Rpb24gc2FmZUJ0b2Eoc3RyKSB7XG4gICAgcmV0dXJuIGJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyB3ZSB1c2UgZW5jb2RlVVJJQ29tcG9uZW50IGJlY2F1c2UgYnRvYSBmYWlscyBmb3Igbm9uIExhdGluIDEgdmFsdWVzXG59XG5leHBvcnQgZnVuY3Rpb24gcmVwZWF0KHMsIGNvdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSBwcm92aWRlZCBxdWVyeSBzdHJpbmcgYXJlIGluY2x1ZGVkIGluIHRoZVxuICogdGFyZ2V0IHN0cmluZy4gVGhlIGNoYXJhY3RlcnMgZG8gbm90IGhhdmUgdG8gYmUgY29udGlndW91cyB3aXRoaW4gdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZ1enp5Q29udGFpbnModGFyZ2V0LCBxdWVyeSkge1xuICAgIGlmICghdGFyZ2V0IHx8ICFxdWVyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJldHVybiBlYXJseSBpZiB0YXJnZXQgb3IgcXVlcnkgYXJlIHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA8IHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGltcG9zc2libGUgZm9yIHF1ZXJ5IHRvIGJlIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICB9XG4gICAgdmFyIHF1ZXJ5TGVuID0gcXVlcnkubGVuZ3RoO1xuICAgIHZhciB0YXJnZXRMb3dlciA9IHRhcmdldC50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3RJbmRleE9mID0gLTE7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVlcnlMZW4pIHtcbiAgICAgICAgdmFyIGluZGV4T2YgPSB0YXJnZXRMb3dlci5pbmRleE9mKHF1ZXJ5W2luZGV4XSwgbGFzdEluZGV4T2YgKyAxKTtcbiAgICAgICAgaWYgKGluZGV4T2YgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4T2YgPSBpbmRleE9mO1xuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcih0YXJnZXQsIGlnbm9yZUVzY2FwZWRDaGFycykge1xuICAgIGlmIChpZ25vcmVFc2NhcGVkQ2hhcnMgPT09IHZvaWQgMCkgeyBpZ25vcmVFc2NhcGVkQ2hhcnMgPSBmYWxzZTsgfVxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlnbm9yZUVzY2FwZWRDaGFycykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZSgvXFxcXC4vZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LnRvTG93ZXJDYXNlKCkgIT09IHRhcmdldDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/strings.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/uri.js":
/*!**************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/uri.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ \"./node_modules/monaco-editor/esm/vs/base/common/platform.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nfunction _encode(ch) {\n    return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n}\n// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\nfunction encodeURIComponent2(str) {\n    return encodeURIComponent(str).replace(/[!'()*]/g, _encode);\n}\nfunction encodeNoop(str) {\n    return str.replace(/[#?]/, _encode);\n}\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret) {\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\nvar _empty = '';\nvar _slash = '/';\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nvar _driveLetterPath = /^\\/[a-zA-Z]:/;\nvar _upperCaseDrive = /^(\\/)?([A-Z]:)/;\nvar _driveLetter = /^[a-zA-Z]:/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component paths\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n *\n *\n */\nvar URI = /** @class */ (function () {\n    /**\n     * @internal\n     */\n    function URI(schemeOrData, authority, path, query, fragment) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = schemeOrData || _empty;\n            this.authority = authority || _empty;\n            this.path = path || _empty;\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this);\n        }\n    }\n    URI.isUri = function (thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string';\n    };\n    Object.defineProperty(URI.prototype, \"fsPath\", {\n        // ---- filesystem path -----------------------\n        /**\n         * Returns a string representing the corresponding file system path of this URI.\n         * Will handle UNC paths and normalize windows drive letters to lower-case. Also\n         * uses the platform specific path separator. Will *not* validate the path for\n         * invalid characters and semantics. Will *not* look at the scheme of this URI.\n         */\n        get: function () {\n            return _makeFsPath(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // ---- modify to new -------------------------\n    URI.prototype.with = function (change) {\n        if (!change) {\n            return this;\n        }\n        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;\n        if (scheme === void 0) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === void 0) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === void 0) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === void 0) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === void 0) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    };\n    // ---- parse & validate ------------------------\n    URI.parse = function (value) {\n        var match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, decodeURIComponent(match[4] || _empty), decodeURIComponent(match[5] || _empty), decodeURIComponent(match[7] || _empty), decodeURIComponent(match[9] || _empty));\n    };\n    URI.file = function (path) {\n        var authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (_platform_js__WEBPACK_IMPORTED_MODULE_0__[\"isWindows\"]) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            var idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        // Ensure that path starts with a slash\n        // or that it is at least a slash\n        if (_driveLetter.test(path)) {\n            path = _slash + path;\n        }\n        else if (path[0] !== _slash) {\n            // tricky -> makes invalid paths\n            // but otherwise we have to stop\n            // allowing relative paths...\n            path = _slash + path;\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    };\n    URI.from = function (components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    };\n    // ---- printing/externalize ---------------------------\n    /**\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    URI.prototype.toString = function (skipEncoding) {\n        if (skipEncoding === void 0) { skipEncoding = false; }\n        return _asFormatted(this, skipEncoding);\n    };\n    URI.prototype.toJSON = function () {\n        var res = {\n            $mid: 1,\n            fsPath: this.fsPath,\n            external: this.toString(),\n        };\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    };\n    URI.revive = function (data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            var result = new _URI(data);\n            result._fsPath = data.fsPath;\n            result._formatted = data.external;\n            return result;\n        }\n    };\n    return URI;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (URI);\n// tslint:disable-next-line:class-name\nvar _URI = /** @class */ (function (_super) {\n    __extends(_URI, _super);\n    function _URI() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._formatted = null;\n        _this._fsPath = null;\n        return _this;\n    }\n    Object.defineProperty(_URI.prototype, \"fsPath\", {\n        get: function () {\n            if (!this._fsPath) {\n                this._fsPath = _makeFsPath(this);\n            }\n            return this._fsPath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    _URI.prototype.toString = function (skipEncoding) {\n        if (skipEncoding === void 0) { skipEncoding = false; }\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    };\n    return _URI;\n}(URI));\n/**\n * Compute `fsPath` for the given uri\n * @param uri\n */\nfunction _makeFsPath(uri) {\n    var value;\n    if (uri.authority && uri.path && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = \"//\" + uri.authority + uri.path;\n    }\n    else if (_driveLetterPath.test(uri.path)) {\n        // windows drive letter: file:///c:/far/boo\n        value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (_platform_js__WEBPACK_IMPORTED_MODULE_0__[\"isWindows\"]) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    var encoder = !skipEncoding\n        ? encodeURIComponent2\n        : encodeNoop;\n    var parts = [];\n    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\n    if (scheme) {\n        parts.push(scheme, ':');\n    }\n    if (authority || scheme === 'file') {\n        parts.push('//');\n    }\n    if (authority) {\n        var idx = authority.indexOf('@');\n        if (idx !== -1) {\n            var userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                parts.push(encoder(userinfo));\n            }\n            else {\n                parts.push(encoder(userinfo.substr(0, idx)), ':', encoder(userinfo.substr(idx + 1)));\n            }\n            parts.push('@');\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            parts.push(encoder(authority));\n        }\n        else {\n            parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        var m = _upperCaseDrive.exec(path);\n        if (m) {\n            if (m[1]) {\n                path = '/' + m[2].toLowerCase() + path.substr(3); // \"/c:\".length === 3\n            }\n            else {\n                path = m[2].toLowerCase() + path.substr(2); // // \"c:\".length === 2\n            }\n        }\n        // encode every segement but not slashes\n        // make sure that # and ? are always encoded\n        // when occurring in paths - otherwise the result\n        // cannot be parsed back again\n        var lastIdx = 0;\n        while (true) {\n            var idx = path.indexOf(_slash, lastIdx);\n            if (idx === -1) {\n                parts.push(encoder(path.substring(lastIdx)));\n                break;\n            }\n            parts.push(encoder(path.substring(lastIdx, idx)), _slash);\n            lastIdx = idx + 1;\n        }\n    }\n    if (query) {\n        parts.push('?', encoder(query));\n    }\n    if (fragment) {\n        parts.push('#', encoder(fragment));\n    }\n    return parts.join(_empty);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdXJpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VyaS5qcz82ZDhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmZ1bmN0aW9uIF9lbmNvZGUoY2gpIHtcbiAgICByZXR1cm4gJyUnICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbn1cbi8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9lbmNvZGVVUklDb21wb25lbnRcbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudDIoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgX2VuY29kZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVOb29wKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWyM/XS8sIF9lbmNvZGUpO1xufVxudmFyIF9zY2hlbWVQYXR0ZXJuID0gL15cXHdbXFx3XFxkKy4tXSokLztcbnZhciBfc2luZ2xlU2xhc2hTdGFydCA9IC9eXFwvLztcbnZhciBfZG91YmxlU2xhc2hTdGFydCA9IC9eXFwvXFwvLztcbmZ1bmN0aW9uIF92YWxpZGF0ZVVyaShyZXQpIHtcbiAgICAvLyBzY2hlbWUsIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gICAgLy8gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gICAgaWYgKHJldC5zY2hlbWUgJiYgIV9zY2hlbWVQYXR0ZXJuLnRlc3QocmV0LnNjaGVtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICAvLyBwYXRoLCBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4zXG4gICAgLy8gSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnRcbiAgICAvLyBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXIuICBJZiBhIFVSSVxuICAgIC8vIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW5cbiAgICAvLyB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpLlxuICAgIGlmIChyZXQucGF0aCkge1xuICAgICAgICBpZiAocmV0LmF1dGhvcml0eSkge1xuICAgICAgICAgICAgaWYgKCFfc2luZ2xlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnQgbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIHNsYXNoIChcIi9cIikgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoX2RvdWJsZVNsYXNoU3RhcnQudGVzdChyZXQucGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxudmFyIF9lbXB0eSA9ICcnO1xudmFyIF9zbGFzaCA9ICcvJztcbnZhciBfcmVnZXhwID0gL14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy87XG52YXIgX2RyaXZlTGV0dGVyUGF0aCA9IC9eXFwvW2EtekEtWl06LztcbnZhciBfdXBwZXJDYXNlRHJpdmUgPSAvXihcXC8pPyhbQS1aXTopLztcbnZhciBfZHJpdmVMZXR0ZXIgPSAvXlthLXpBLVpdOi87XG4vKipcbiAqIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxuICogVGhpcyBjbGFzcyBpcyBhIHNpbXBsZSBwYXJzZXIgd2hpY2ggY3JlYXRlcyB0aGUgYmFzaWMgY29tcG9uZW50IHBhdGhzXG4gKiAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMpIHdpdGggbWluaW1hbCB2YWxpZGF0aW9uXG4gKiBhbmQgZW5jb2RpbmcuXG4gKlxuICogICAgICAgZm9vOi8vZXhhbXBsZS5jb206ODA0Mi9vdmVyL3RoZXJlP25hbWU9ZmVycmV0I25vc2VcbiAqICAgICAgIFxcXy8gICBcXF9fX19fX19fX19fX19fL1xcX19fX19fX19fLyBcXF9fX19fX19fXy8gXFxfXy9cbiAqICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgfCAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICBzY2hlbWUgICAgIGF1dGhvcml0eSAgICAgICBwYXRoICAgICAgICBxdWVyeSAgIGZyYWdtZW50XG4gKiAgICAgICAgfCAgIF9fX19fX19fX19fX19fX19fX19fX3xfX1xuICogICAgICAgLyBcXCAvICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAqICAgICAgIHVybjpleGFtcGxlOmFuaW1hbDpmZXJyZXQ6bm9zZVxuICpcbiAqXG4gKi9cbnZhciBVUkkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gVVJJKHNjaGVtZU9yRGF0YSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWVPckRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtZSA9IHNjaGVtZU9yRGF0YS5zY2hlbWUgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBzY2hlbWVPckRhdGEuYXV0aG9yaXR5IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHNjaGVtZU9yRGF0YS5wYXRoIHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBzY2hlbWVPckRhdGEucXVlcnkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHNjaGVtZU9yRGF0YS5mcmFnbWVudCB8fCBfZW1wdHk7XG4gICAgICAgICAgICAvLyBubyB2YWxpZGF0aW9uIGJlY2F1c2UgaXQncyB0aGlzIFVSSVxuICAgICAgICAgICAgLy8gdGhhdCBjcmVhdGVzIHVyaSBjb21wb25lbnRzLlxuICAgICAgICAgICAgLy8gX3ZhbGlkYXRlVXJpKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBzY2hlbWVPckRhdGEgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBhdXRob3JpdHkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aCB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIF92YWxpZGF0ZVVyaSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBVUkkuaXNVcmkgPSBmdW5jdGlvbiAodGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgVVJJKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGluZy5hdXRob3JpdHkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuZnJhZ21lbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcucGF0aCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5xdWVyeSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5zY2hlbWUgPT09ICdzdHJpbmcnO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSSS5wcm90b3R5cGUsIFwiZnNQYXRoXCIsIHtcbiAgICAgICAgLy8gLS0tLSBmaWxlc3lzdGVtIHBhdGggLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgc3lzdGVtIHBhdGggb2YgdGhpcyBVUkkuXG4gICAgICAgICAqIFdpbGwgaGFuZGxlIFVOQyBwYXRocyBhbmQgbm9ybWFsaXplIHdpbmRvd3MgZHJpdmUgbGV0dGVycyB0byBsb3dlci1jYXNlLiBBbHNvXG4gICAgICAgICAqIHVzZXMgdGhlIHBsYXRmb3JtIHNwZWNpZmljIHBhdGggc2VwYXJhdG9yLiBXaWxsICpub3QqIHZhbGlkYXRlIHRoZSBwYXRoIGZvclxuICAgICAgICAgKiBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIHNlbWFudGljcy4gV2lsbCAqbm90KiBsb29rIGF0IHRoZSBzY2hlbWUgb2YgdGhpcyBVUkkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFrZUZzUGF0aCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gLS0tLSBtb2RpZnkgdG8gbmV3IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBVUkkucHJvdG90eXBlLndpdGggPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NoZW1lID0gY2hhbmdlLnNjaGVtZSwgYXV0aG9yaXR5ID0gY2hhbmdlLmF1dGhvcml0eSwgcGF0aCA9IGNoYW5nZS5wYXRoLCBxdWVyeSA9IGNoYW5nZS5xdWVyeSwgZnJhZ21lbnQgPSBjaGFuZ2UuZnJhZ21lbnQ7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc2NoZW1lID0gdGhpcy5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdXRob3JpdHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcnkgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmFnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdGhpcy5zY2hlbWVcbiAgICAgICAgICAgICYmIGF1dGhvcml0eSA9PT0gdGhpcy5hdXRob3JpdHlcbiAgICAgICAgICAgICYmIHBhdGggPT09IHRoaXMucGF0aFxuICAgICAgICAgICAgJiYgcXVlcnkgPT09IHRoaXMucXVlcnlcbiAgICAgICAgICAgICYmIGZyYWdtZW50ID09PSB0aGlzLmZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IF9VUkkoc2NoZW1lLCBhdXRob3JpdHksIHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCk7XG4gICAgfTtcbiAgICAvLyAtLS0tIHBhcnNlICYgdmFsaWRhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVVJJLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IF9yZWdleHAuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX1VSSShfZW1wdHksIF9lbXB0eSwgX2VtcHR5LCBfZW1wdHksIF9lbXB0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBfVVJJKG1hdGNoWzJdIHx8IF9lbXB0eSwgZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzRdIHx8IF9lbXB0eSksIGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFs1XSB8fCBfZW1wdHkpLCBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbN10gfHwgX2VtcHR5KSwgZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzldIHx8IF9lbXB0eSkpO1xuICAgIH07XG4gICAgVVJJLmZpbGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgYXV0aG9yaXR5ID0gX2VtcHR5O1xuICAgICAgICAvLyBub3JtYWxpemUgdG8gZndkLXNsYXNoZXMgb24gd2luZG93cyxcbiAgICAgICAgLy8gb24gb3RoZXIgc3lzdGVtcyBid2Qtc2xhc2hlcyBhcmUgdmFsaWRcbiAgICAgICAgLy8gZmlsZW5hbWUgY2hhcmFjdGVyLCBlZyAvZlxcb28vYmFcXHIudHh0XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgX3NsYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgYXV0aG9yaXR5IGFzIHVzZWQgaW4gVU5DIHNoYXJlc1xuICAgICAgICAvLyBvciB1c2UgdGhlIHBhdGggYXMgZ2l2ZW5cbiAgICAgICAgaWYgKHBhdGhbMF0gPT09IF9zbGFzaCAmJiBwYXRoWzFdID09PSBfc2xhc2gpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBwYXRoLmluZGV4T2YoX3NsYXNoLCAyKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5ID0gcGF0aC5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgcGF0aCA9IF9zbGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1dGhvcml0eSA9IHBhdGguc3Vic3RyaW5nKDIsIGlkeCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKGlkeCkgfHwgX3NsYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHBhdGggc3RhcnRzIHdpdGggYSBzbGFzaFxuICAgICAgICAvLyBvciB0aGF0IGl0IGlzIGF0IGxlYXN0IGEgc2xhc2hcbiAgICAgICAgaWYgKF9kcml2ZUxldHRlci50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICBwYXRoID0gX3NsYXNoICsgcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoWzBdICE9PSBfc2xhc2gpIHtcbiAgICAgICAgICAgIC8vIHRyaWNreSAtPiBtYWtlcyBpbnZhbGlkIHBhdGhzXG4gICAgICAgICAgICAvLyBidXQgb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RvcFxuICAgICAgICAgICAgLy8gYWxsb3dpbmcgcmVsYXRpdmUgcGF0aHMuLi5cbiAgICAgICAgICAgIHBhdGggPSBfc2xhc2ggKyBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgX1VSSSgnZmlsZScsIGF1dGhvcml0eSwgcGF0aCwgX2VtcHR5LCBfZW1wdHkpO1xuICAgIH07XG4gICAgVVJJLmZyb20gPSBmdW5jdGlvbiAoY29tcG9uZW50cykge1xuICAgICAgICByZXR1cm4gbmV3IF9VUkkoY29tcG9uZW50cy5zY2hlbWUsIGNvbXBvbmVudHMuYXV0aG9yaXR5LCBjb21wb25lbnRzLnBhdGgsIGNvbXBvbmVudHMucXVlcnksIGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgIH07XG4gICAgLy8gLS0tLSBwcmludGluZy9leHRlcm5hbGl6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBza2lwRW5jb2RpbmcgRG8gbm90IGVuY29kZSB0aGUgcmVzdWx0LCBkZWZhdWx0IGlzIGBmYWxzZWBcbiAgICAgKi9cbiAgICBVUkkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNraXBFbmNvZGluZykge1xuICAgICAgICBpZiAoc2tpcEVuY29kaW5nID09PSB2b2lkIDApIHsgc2tpcEVuY29kaW5nID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCBza2lwRW5jb2RpbmcpO1xuICAgIH07XG4gICAgVVJJLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICAkbWlkOiAxLFxuICAgICAgICAgICAgZnNQYXRoOiB0aGlzLmZzUGF0aCxcbiAgICAgICAgICAgIGV4dGVybmFsOiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgICAgIHJlcy5wYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjaGVtZSkge1xuICAgICAgICAgICAgcmVzLnNjaGVtZSA9IHRoaXMuc2NoZW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xuICAgICAgICAgICAgcmVzLmF1dGhvcml0eSA9IHRoaXMuYXV0aG9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICAgICAgICByZXMucXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXMuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBVUkkucmV2aXZlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVVJJKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgX1VSSShkYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdC5fZnNQYXRoID0gZGF0YS5mc1BhdGg7XG4gICAgICAgICAgICByZXN1bHQuX2Zvcm1hdHRlZCA9IGRhdGEuZXh0ZXJuYWw7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVVJJO1xufSgpKTtcbmV4cG9ydCBkZWZhdWx0IFVSSTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjbGFzcy1uYW1lXG52YXIgX1VSSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX1VSSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfVVJJKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2Zvcm1hdHRlZCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9mc1BhdGggPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfVVJJLnByb3RvdHlwZSwgXCJmc1BhdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZnNQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnNQYXRoID0gX21ha2VGc1BhdGgodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnNQYXRoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfVVJJLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChza2lwRW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHNraXBFbmNvZGluZyA9PT0gdm9pZCAwKSB7IHNraXBFbmNvZGluZyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghc2tpcEVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Zvcm1hdHRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlZCA9IF9hc0Zvcm1hdHRlZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2FjaGUgdGhhdFxuICAgICAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9VUkk7XG59KFVSSSkpO1xuLyoqXG4gKiBDb21wdXRlIGBmc1BhdGhgIGZvciB0aGUgZ2l2ZW4gdXJpXG4gKiBAcGFyYW0gdXJpXG4gKi9cbmZ1bmN0aW9uIF9tYWtlRnNQYXRoKHVyaSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAodXJpLmF1dGhvcml0eSAmJiB1cmkucGF0aCAmJiB1cmkuc2NoZW1lID09PSAnZmlsZScpIHtcbiAgICAgICAgLy8gdW5jIHBhdGg6IGZpbGU6Ly9zaGFyZXMvYyQvZmFyL2Jvb1xuICAgICAgICB2YWx1ZSA9IFwiLy9cIiArIHVyaS5hdXRob3JpdHkgKyB1cmkucGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2RyaXZlTGV0dGVyUGF0aC50ZXN0KHVyaS5wYXRoKSkge1xuICAgICAgICAvLyB3aW5kb3dzIGRyaXZlIGxldHRlcjogZmlsZTovLy9jOi9mYXIvYm9vXG4gICAgICAgIHZhbHVlID0gdXJpLnBhdGhbMV0udG9Mb3dlckNhc2UoKSArIHVyaS5wYXRoLnN1YnN0cigyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG90aGVyIHBhdGhcbiAgICAgICAgdmFsdWUgPSB1cmkucGF0aDtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzV2luZG93cykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgZXh0ZXJuYWwgdmVyc2lvbiBvZiBhIHVyaVxuICovXG5mdW5jdGlvbiBfYXNGb3JtYXR0ZWQodXJpLCBza2lwRW5jb2RpbmcpIHtcbiAgICB2YXIgZW5jb2RlciA9ICFza2lwRW5jb2RpbmdcbiAgICAgICAgPyBlbmNvZGVVUklDb21wb25lbnQyXG4gICAgICAgIDogZW5jb2RlTm9vcDtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgc2NoZW1lID0gdXJpLnNjaGVtZSwgYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eSwgcGF0aCA9IHVyaS5wYXRoLCBxdWVyeSA9IHVyaS5xdWVyeSwgZnJhZ21lbnQgPSB1cmkuZnJhZ21lbnQ7XG4gICAgaWYgKHNjaGVtZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHNjaGVtZSwgJzonKTtcbiAgICB9XG4gICAgaWYgKGF1dGhvcml0eSB8fCBzY2hlbWUgPT09ICdmaWxlJykge1xuICAgICAgICBwYXJ0cy5wdXNoKCcvLycpO1xuICAgIH1cbiAgICBpZiAoYXV0aG9yaXR5KSB7XG4gICAgICAgIHZhciBpZHggPSBhdXRob3JpdHkuaW5kZXhPZignQCcpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHVzZXJpbmZvID0gYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpO1xuICAgICAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnN1YnN0cihpZHggKyAxKTtcbiAgICAgICAgICAgIGlkeCA9IHVzZXJpbmZvLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChlbmNvZGVyKHVzZXJpbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZXIodXNlcmluZm8uc3Vic3RyKDAsIGlkeCkpLCAnOicsIGVuY29kZXIodXNlcmluZm8uc3Vic3RyKGlkeCArIDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdAJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlkeCA9IGF1dGhvcml0eS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZXIoYXV0aG9yaXR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZXIoYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpKSwgYXV0aG9yaXR5LnN1YnN0cihpZHgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aCkge1xuICAgICAgICAvLyBsb3dlci1jYXNlIHdpbmRvd3MgZHJpdmUgbGV0dGVycyBpbiAvQzovZmZmIG9yIEM6L2ZmZlxuICAgICAgICB2YXIgbSA9IF91cHBlckNhc2VEcml2ZS5leGVjKHBhdGgpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgaWYgKG1bMV0pIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gJy8nICsgbVsyXS50b0xvd2VyQ2FzZSgpICsgcGF0aC5zdWJzdHIoMyk7IC8vIFwiL2M6XCIubGVuZ3RoID09PSAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gbVsyXS50b0xvd2VyQ2FzZSgpICsgcGF0aC5zdWJzdHIoMik7IC8vIC8vIFwiYzpcIi5sZW5ndGggPT09IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlbmNvZGUgZXZlcnkgc2VnZW1lbnQgYnV0IG5vdCBzbGFzaGVzXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0ICMgYW5kID8gYXJlIGFsd2F5cyBlbmNvZGVkXG4gICAgICAgIC8vIHdoZW4gb2NjdXJyaW5nIGluIHBhdGhzIC0gb3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAgICAgICAgLy8gY2Fubm90IGJlIHBhcnNlZCBiYWNrIGFnYWluXG4gICAgICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBwYXRoLmluZGV4T2YoX3NsYXNoLCBsYXN0SWR4KTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChlbmNvZGVyKHBhdGguc3Vic3RyaW5nKGxhc3RJZHgpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZXIocGF0aC5zdWJzdHJpbmcobGFzdElkeCwgaWR4KSksIF9zbGFzaCk7XG4gICAgICAgICAgICBsYXN0SWR4ID0gaWR4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgcGFydHMucHVzaCgnPycsIGVuY29kZXIocXVlcnkpKTtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyMnLCBlbmNvZGVyKGZyYWdtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKF9lbXB0eSk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/uri.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js":
/*!*********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js ***!
  \*********************************************************************/
/*! exports provided: Promise, TPromise, PPromise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Promise\", function() { return Promise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TPromise\", function() { return TPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PPromise\", function() { return PPromise; });\n/**\n * Extracted from https://github.com/winjs/winjs\n * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)\n * Copyright (c) Microsoft Corporation.\n * All Rights Reserved.\n * Licensed under the MIT License.\n */\nvar __winjs_exports;\n\n(function() {\n\nvar _modules = Object.create(null);//{};\n_modules[\"WinJS/Core/_WinJS\"] = {};\n\nvar _winjs = function(moduleId, deps, factory) {\n    var exports = {};\n    var exportsPassedIn = false;\n\n    var depsValues = deps.map(function(dep) {\n        if (dep === 'exports') {\n            exportsPassedIn = true;\n            return exports;\n        }\n        return _modules[dep];\n    });\n\n    var result = factory.apply({}, depsValues);\n\n    _modules[moduleId] = exportsPassedIn ? exports : result;\n};\n\n\n_winjs(\"WinJS/Core/_Global\", [], function () {\n    \"use strict\";\n\n    // Appease jshint\n    /* global window, self, global */\n\n    var globalObject =\n        typeof window !== 'undefined' ? window :\n        typeof self !== 'undefined' ? self :\n        typeof global !== 'undefined' ? global :\n        {};\n    return globalObject;\n});\n\n_winjs(\"WinJS/Core/_BaseCoreUtils\", [\"WinJS/Core/_Global\"], function baseCoreUtilsInit(_Global) {\n    \"use strict\";\n\n    var hasWinRT = !!_Global.Windows;\n\n    function markSupportedForProcessing(func) {\n        /// <signature helpKeyword=\"WinJS.Utilities.markSupportedForProcessing\">\n        /// <summary locid=\"WinJS.Utilities.markSupportedForProcessing\">\n        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll\n        /// or WinJS.Binding.processAll.\n        /// </summary>\n        /// <param name=\"func\" type=\"Function\" locid=\"WinJS.Utilities.markSupportedForProcessing_p:func\">\n        /// The function to be marked as compatible with declarative processing.\n        /// </param>\n        /// <returns type=\"Function\" locid=\"WinJS.Utilities.markSupportedForProcessing_returnValue\">\n        /// The input function.\n        /// </returns>\n        /// </signature>\n        func.supportedForProcessing = true;\n        return func;\n    }\n\n    var actualSetImmediate = null;\n\n    return {\n        hasWinRT: hasWinRT,\n        markSupportedForProcessing: markSupportedForProcessing,\n        _setImmediate: function (callback) {\n            // BEGIN monaco change\n            if (actualSetImmediate === null) {\n                if (_Global.setImmediate) {\n                    actualSetImmediate = _Global.setImmediate.bind(_Global);\n                } else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n                    actualSetImmediate = process.nextTick.bind(process);\n                } else {\n                    actualSetImmediate = _Global.setTimeout.bind(_Global);\n                }\n            }\n            actualSetImmediate(callback);\n            // END monaco change\n        }\n    };\n});\n_winjs(\"WinJS/Core/_WriteProfilerMark\", [\"WinJS/Core/_Global\"], function profilerInit(_Global) {\n    \"use strict\";\n\n    return _Global.msWriteProfilerMark || function () { };\n});\n_winjs(\"WinJS/Core/_Base\", [\"WinJS/Core/_WinJS\",\"WinJS/Core/_Global\",\"WinJS/Core/_BaseCoreUtils\",\"WinJS/Core/_WriteProfilerMark\"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {\n    \"use strict\";\n\n    function initializeProperties(target, members, prefix) {\n        var keys = Object.keys(members);\n        var isArray = Array.isArray(target);\n        var properties;\n        var i, len;\n        for (i = 0, len = keys.length; i < len; i++) {\n            var key = keys[i];\n            var enumerable = key.charCodeAt(0) !== /*_*/95;\n            var member = members[key];\n            if (member && typeof member === 'object') {\n                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {\n                    if (member.enumerable === undefined) {\n                        member.enumerable = enumerable;\n                    }\n                    if (prefix && member.setName && typeof member.setName === 'function') {\n                        member.setName(prefix + \".\" + key);\n                    }\n                    properties = properties || {};\n                    properties[key] = member;\n                    continue;\n                }\n            }\n            if (!enumerable) {\n                properties = properties || {};\n                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };\n                continue;\n            }\n            if (isArray) {\n                target.forEach(function (target) {\n                    target[key] = member;\n                });\n            } else {\n                target[key] = member;\n            }\n        }\n        if (properties) {\n            if (isArray) {\n                target.forEach(function (target) {\n                    Object.defineProperties(target, properties);\n                });\n            } else {\n                Object.defineProperties(target, properties);\n            }\n        }\n    }\n\n    (function () {\n\n        var _rootNamespace = _WinJS;\n        if (!_rootNamespace.Namespace) {\n            _rootNamespace.Namespace = Object.create(Object.prototype);\n        }\n\n        function createNamespace(parentNamespace, name) {\n            var currentNamespace = parentNamespace || {};\n            if (name) {\n                var namespaceFragments = name.split(\".\");\n                if (currentNamespace === _Global && namespaceFragments[0] === \"WinJS\") {\n                    currentNamespace = _WinJS;\n                    namespaceFragments.splice(0, 1);\n                }\n                for (var i = 0, len = namespaceFragments.length; i < len; i++) {\n                    var namespaceName = namespaceFragments[i];\n                    if (!currentNamespace[namespaceName]) {\n                        Object.defineProperty(currentNamespace, namespaceName,\n                            { value: {}, writable: false, enumerable: true, configurable: true }\n                        );\n                    }\n                    currentNamespace = currentNamespace[namespaceName];\n                }\n            }\n            return currentNamespace;\n        }\n\n        function defineWithParent(parentNamespace, name, members) {\n            /// <signature helpKeyword=\"WinJS.Namespace.defineWithParent\">\n            /// <summary locid=\"WinJS.Namespace.defineWithParent\">\n            /// Defines a new namespace with the specified name under the specified parent namespace.\n            /// </summary>\n            /// <param name=\"parentNamespace\" type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_p:parentNamespace\">\n            /// The parent namespace.\n            /// </param>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.Namespace.defineWithParent_p:name\">\n            /// The name of the new namespace.\n            /// </param>\n            /// <param name=\"members\" type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_p:members\">\n            /// The members of the new namespace.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_returnValue\">\n            /// The newly-defined namespace.\n            /// </returns>\n            /// </signature>\n            var currentNamespace = createNamespace(parentNamespace, name);\n\n            if (members) {\n                initializeProperties(currentNamespace, members, name || \"<ANONYMOUS>\");\n            }\n\n            return currentNamespace;\n        }\n\n        function define(name, members) {\n            /// <signature helpKeyword=\"WinJS.Namespace.define\">\n            /// <summary locid=\"WinJS.Namespace.define\">\n            /// Defines a new namespace with the specified name.\n            /// </summary>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.Namespace.define_p:name\">\n            /// The name of the namespace. This could be a dot-separated name for nested namespaces.\n            /// </param>\n            /// <param name=\"members\" type=\"Object\" locid=\"WinJS.Namespace.define_p:members\">\n            /// The members of the new namespace.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Namespace.define_returnValue\">\n            /// The newly-defined namespace.\n            /// </returns>\n            /// </signature>\n            return defineWithParent(_Global, name, members);\n        }\n\n        var LazyStates = {\n            uninitialized: 1,\n            working: 2,\n            initialized: 3,\n        };\n\n        function lazy(f) {\n            var name;\n            var state = LazyStates.uninitialized;\n            var result;\n            return {\n                setName: function (value) {\n                    name = value;\n                },\n                get: function () {\n                    switch (state) {\n                        case LazyStates.initialized:\n                            return result;\n\n                        case LazyStates.uninitialized:\n                            state = LazyStates.working;\n                            try {\n                                _WriteProfilerMark(\"WinJS.Namespace._lazy:\" + name + \",StartTM\");\n                                result = f();\n                            } finally {\n                                _WriteProfilerMark(\"WinJS.Namespace._lazy:\" + name + \",StopTM\");\n                                state = LazyStates.uninitialized;\n                            }\n                            f = null;\n                            state = LazyStates.initialized;\n                            return result;\n\n                        case LazyStates.working:\n                            throw \"Illegal: reentrancy on initialization\";\n\n                        default:\n                            throw \"Illegal\";\n                    }\n                },\n                set: function (value) {\n                    switch (state) {\n                        case LazyStates.working:\n                            throw \"Illegal: reentrancy on initialization\";\n\n                        default:\n                            state = LazyStates.initialized;\n                            result = value;\n                            break;\n                    }\n                },\n                enumerable: true,\n                configurable: true,\n            };\n        }\n\n        // helper for defining AMD module members\n        function moduleDefine(exports, name, members) {\n            var target = [exports];\n            var publicNS = null;\n            if (name) {\n                publicNS = createNamespace(_Global, name);\n                target.push(publicNS);\n            }\n            initializeProperties(target, members, name || \"<ANONYMOUS>\");\n            return publicNS;\n        }\n\n        // Establish members of the \"WinJS.Namespace\" namespace\n        Object.defineProperties(_rootNamespace.Namespace, {\n\n            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },\n\n            define: { value: define, writable: true, enumerable: true, configurable: true },\n\n            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },\n\n            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }\n\n        });\n\n    })();\n\n    (function () {\n\n        function define(constructor, instanceMembers, staticMembers) {\n            /// <signature helpKeyword=\"WinJS.Class.define\">\n            /// <summary locid=\"WinJS.Class.define\">\n            /// Defines a class using the given constructor and the specified instance members.\n            /// </summary>\n            /// <param name=\"constructor\" type=\"Function\" locid=\"WinJS.Class.define_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <param name=\"instanceMembers\" type=\"Object\" locid=\"WinJS.Class.define_p:instanceMembers\">\n            /// The set of instance fields, properties, and methods made available on the class.\n            /// </param>\n            /// <param name=\"staticMembers\" type=\"Object\" locid=\"WinJS.Class.define_p:staticMembers\">\n            /// The set of static fields, properties, and methods made available on the class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.define_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            constructor = constructor || function () { };\n            _BaseCoreUtils.markSupportedForProcessing(constructor);\n            if (instanceMembers) {\n                initializeProperties(constructor.prototype, instanceMembers);\n            }\n            if (staticMembers) {\n                initializeProperties(constructor, staticMembers);\n            }\n            return constructor;\n        }\n\n        function derive(baseClass, constructor, instanceMembers, staticMembers) {\n            /// <signature helpKeyword=\"WinJS.Class.derive\">\n            /// <summary locid=\"WinJS.Class.derive\">\n            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.\n            /// </summary>\n            /// <param name=\"baseClass\" type=\"Function\" locid=\"WinJS.Class.derive_p:baseClass\">\n            /// The class to inherit from.\n            /// </param>\n            /// <param name=\"constructor\" type=\"Function\" locid=\"WinJS.Class.derive_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <param name=\"instanceMembers\" type=\"Object\" locid=\"WinJS.Class.derive_p:instanceMembers\">\n            /// The set of instance fields, properties, and methods to be made available on the class.\n            /// </param>\n            /// <param name=\"staticMembers\" type=\"Object\" locid=\"WinJS.Class.derive_p:staticMembers\">\n            /// The set of static fields, properties, and methods to be made available on the class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.derive_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            if (baseClass) {\n                constructor = constructor || function () { };\n                var basePrototype = baseClass.prototype;\n                constructor.prototype = Object.create(basePrototype);\n                _BaseCoreUtils.markSupportedForProcessing(constructor);\n                Object.defineProperty(constructor.prototype, \"constructor\", { value: constructor, writable: true, configurable: true, enumerable: true });\n                if (instanceMembers) {\n                    initializeProperties(constructor.prototype, instanceMembers);\n                }\n                if (staticMembers) {\n                    initializeProperties(constructor, staticMembers);\n                }\n                return constructor;\n            } else {\n                return define(constructor, instanceMembers, staticMembers);\n            }\n        }\n\n        function mix(constructor) {\n            /// <signature helpKeyword=\"WinJS.Class.mix\">\n            /// <summary locid=\"WinJS.Class.mix\">\n            /// Defines a class using the given constructor and the union of the set of instance members\n            /// specified by all the mixin objects. The mixin parameter list is of variable length.\n            /// </summary>\n            /// <param name=\"constructor\" locid=\"WinJS.Class.mix_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.mix_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            constructor = constructor || function () { };\n            var i, len;\n            for (i = 1, len = arguments.length; i < len; i++) {\n                initializeProperties(constructor.prototype, arguments[i]);\n            }\n            return constructor;\n        }\n\n        // Establish members of \"WinJS.Class\" namespace\n        _WinJS.Namespace.define(\"WinJS.Class\", {\n            define: define,\n            derive: derive,\n            mix: mix\n        });\n\n    })();\n\n    return {\n        Namespace: _WinJS.Namespace,\n        Class: _WinJS.Class\n    };\n\n});\n_winjs(\"WinJS/Core/_ErrorFromName\", [\"WinJS/Core/_Base\"], function errorsInit(_Base) {\n    \"use strict\";\n\n    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {\n        /// <signature helpKeyword=\"WinJS.ErrorFromName\">\n        /// <summary locid=\"WinJS.ErrorFromName\">\n        /// Creates an Error object with the specified name and message properties.\n        /// </summary>\n        /// <param name=\"name\" type=\"String\" locid=\"WinJS.ErrorFromName_p:name\">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>\n        /// <param name=\"message\" type=\"String\" optional=\"true\" locid=\"WinJS.ErrorFromName_p:message\">The message for this error. The message is meant to be consumed by humans and should be localized.</param>\n        /// <returns type=\"Error\" locid=\"WinJS.ErrorFromName_returnValue\">Error instance with .name and .message properties populated</returns>\n        /// </signature>\n        this.name = name;\n        this.message = message || name;\n    }, {\n        /* empty */\n    }, {\n        supportedForProcessing: false,\n    });\n\n    _Base.Namespace.define(\"WinJS\", {\n        // ErrorFromName establishes a simple pattern for returning error codes.\n        //\n        ErrorFromName: ErrorFromName\n    });\n\n    return ErrorFromName;\n\n});\n\n\n_winjs(\"WinJS/Core/_Events\", [\"exports\",\"WinJS/Core/_Base\"], function eventsInit(exports, _Base) {\n    \"use strict\";\n\n\n    function createEventProperty(name) {\n        var eventPropStateName = \"_on\" + name + \"state\";\n\n        return {\n            get: function () {\n                var state = this[eventPropStateName];\n                return state && state.userHandler;\n            },\n            set: function (handler) {\n                var state = this[eventPropStateName];\n                if (handler) {\n                    if (!state) {\n                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };\n                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });\n                        this.addEventListener(name, state.wrapper, false);\n                    }\n                    state.userHandler = handler;\n                } else if (state) {\n                    this.removeEventListener(name, state.wrapper, false);\n                    this[eventPropStateName] = null;\n                }\n            },\n            enumerable: true\n        };\n    }\n\n    function createEventProperties() {\n        /// <signature helpKeyword=\"WinJS.Utilities.createEventProperties\">\n        /// <summary locid=\"WinJS.Utilities.createEventProperties\">\n        /// Creates an object that has one property for each name passed to the function.\n        /// </summary>\n        /// <param name=\"events\" locid=\"WinJS.Utilities.createEventProperties_p:events\">\n        /// A variable list of property names.\n        /// </param>\n        /// <returns type=\"Object\" locid=\"WinJS.Utilities.createEventProperties_returnValue\">\n        /// The object with the specified properties. The names of the properties are prefixed with 'on'.\n        /// </returns>\n        /// </signature>\n        var props = {};\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            var name = arguments[i];\n            props[\"on\" + name] = createEventProperty(name);\n        }\n        return props;\n    }\n\n    var EventMixinEvent = _Base.Class.define(\n        function EventMixinEvent_ctor(type, detail, target) {\n            this.detail = detail;\n            this.target = target;\n            this.timeStamp = Date.now();\n            this.type = type;\n        },\n        {\n            bubbles: { value: false, writable: false },\n            cancelable: { value: false, writable: false },\n            currentTarget: {\n                get: function () { return this.target; }\n            },\n            defaultPrevented: {\n                get: function () { return this._preventDefaultCalled; }\n            },\n            trusted: { value: false, writable: false },\n            eventPhase: { value: 0, writable: false },\n            target: null,\n            timeStamp: null,\n            type: null,\n\n            preventDefault: function () {\n                this._preventDefaultCalled = true;\n            },\n            stopImmediatePropagation: function () {\n                this._stopImmediatePropagationCalled = true;\n            },\n            stopPropagation: function () {\n            }\n        }, {\n            supportedForProcessing: false,\n        }\n    );\n\n    var eventMixin = {\n        _listeners: null,\n\n        addEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.addEventListener\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.addEventListener\">\n            /// Adds an event listener to the control.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"listener\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:listener\">\n            /// The listener to invoke when the event is raised.\n            /// </param>\n            /// <param name=\"useCapture\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:useCapture\">\n            /// if true initiates capture, otherwise false.\n            /// </param>\n            /// </signature>\n            useCapture = useCapture || false;\n            this._listeners = this._listeners || {};\n            var eventListeners = (this._listeners[type] = this._listeners[type] || []);\n            for (var i = 0, len = eventListeners.length; i < len; i++) {\n                var l = eventListeners[i];\n                if (l.useCapture === useCapture && l.listener === listener) {\n                    return;\n                }\n            }\n            eventListeners.push({ listener: listener, useCapture: useCapture });\n        },\n        dispatchEvent: function (type, details) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.dispatchEvent\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.dispatchEvent\">\n            /// Raises an event of the specified type and with the specified additional properties.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"details\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_p:details\">\n            /// The set of additional properties to be attached to the event object when the event is raised.\n            /// </param>\n            /// <returns type=\"Boolean\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_returnValue\">\n            /// true if preventDefault was called on the event.\n            /// </returns>\n            /// </signature>\n            var listeners = this._listeners && this._listeners[type];\n            if (listeners) {\n                var eventValue = new EventMixinEvent(type, details, this);\n                // Need to copy the array to protect against people unregistering while we are dispatching\n                listeners = listeners.slice(0, listeners.length);\n                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {\n                    listeners[i].listener(eventValue);\n                }\n                return eventValue.defaultPrevented || false;\n            }\n            return false;\n        },\n        removeEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.removeEventListener\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.removeEventListener\">\n            /// Removes an event listener from the control.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"listener\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:listener\">\n            /// The listener to remove.\n            /// </param>\n            /// <param name=\"useCapture\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:useCapture\">\n            /// Specifies whether to initiate capture.\n            /// </param>\n            /// </signature>\n            useCapture = useCapture || false;\n            var listeners = this._listeners && this._listeners[type];\n            if (listeners) {\n                for (var i = 0, len = listeners.length; i < len; i++) {\n                    var l = listeners[i];\n                    if (l.listener === listener && l.useCapture === useCapture) {\n                        listeners.splice(i, 1);\n                        if (listeners.length === 0) {\n                            delete this._listeners[type];\n                        }\n                        // Only want to remove one element for each call to removeEventListener\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    _Base.Namespace._moduleDefine(exports, \"WinJS.Utilities\", {\n        _createEventProperty: createEventProperty,\n        createEventProperties: createEventProperties,\n        eventMixin: eventMixin\n    });\n\n});\n\n\n_winjs(\"WinJS/Core/_Trace\", [\"WinJS/Core/_Global\"], function traceInit(_Global) {\n    \"use strict\";\n\n    function nop(v) {\n        return v;\n    }\n\n    return {\n        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,\n        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,\n        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,\n        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop\n    };\n});\n_winjs(\"WinJS/Promise/_StateMachine\", [\"WinJS/Core/_Global\",\"WinJS/Core/_BaseCoreUtils\",\"WinJS/Core/_Base\",\"WinJS/Core/_ErrorFromName\",\"WinJS/Core/_Events\",\"WinJS/Core/_Trace\"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {\n    \"use strict\";\n\n    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);\n\n    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);\n    var promiseEventListeners = new ListenerType();\n    // make sure there is a listeners collection so that we can do a more trivial check below\n    promiseEventListeners._listeners = {};\n    var errorET = \"error\";\n    var canceledName = \"Canceled\";\n    var tagWithStack = false;\n    var tag = {\n        promise: 0x01,\n        thenPromise: 0x02,\n        errorPromise: 0x04,\n        exceptionPromise: 0x08,\n        completePromise: 0x10,\n    };\n    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;\n\n    //\n    // Global error counter, for each error which enters the system we increment this once and then\n    // the error number travels with the error as it traverses the tree of potential handlers.\n    //\n    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises\n    // which are in error will get tagged with a ._errorId field. This tagged field is the\n    // contract by which nested promises with errors will be identified as chaining for the\n    // purposes of the callonerror semantics. If a nested promise in error is encountered without\n    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and\n    // a new error id will be minted.\n    //\n    var error_number = 1;\n\n    //\n    // The state machine has a interesting hiccup in it with regards to notification, in order\n    // to flatten out notification and avoid recursion for synchronous completion we have an\n    // explicit set of *_notify states which are responsible for notifying their entire tree\n    // of children. They can do this because they know that immediate children are always\n    // ThenPromise instances and we can therefore reach into their state to access the\n    // _listeners collection.\n    //\n    // So, what happens is that a Promise will be fulfilled through the _completed or _error\n    // messages at which point it will enter a *_notify state and be responsible for to move\n    // its children into an (as appropriate) success or error state and also notify that child's\n    // listeners of the state transition, until leaf notes are reached.\n    //\n\n    var state_created,              // -> working\n        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting\n        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled\n        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling\n        state_canceled,             // -> error | error_notify | success | success_notify | canceling\n        state_canceling,            // -> error_notify\n        state_success_notify,       // -> success\n        state_success,              // -> .\n        state_error_notify,         // -> error\n        state_error;                // -> .\n\n    // Noop function, used in the various states to indicate that they don't support a given\n    // message. Named with the somewhat cute name '_' because it reads really well in the states.\n\n    function _() { }\n\n    // Initial state\n    //\n    state_created = {\n        name: \"created\",\n        enter: function (promise) {\n            promise._setState(state_working);\n        },\n        cancel: _,\n        done: _,\n        then: _,\n        _completed: _,\n        _error: _,\n        _notify: _,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Ready state, waiting for a message (completed/error/progress), able to be canceled\n    //\n    state_working = {\n        name: \"working\",\n        enter: _,\n        cancel: function (promise) {\n            promise._setState(state_canceled);\n        },\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Waiting state, if a promise is completed with a value which is itself a promise\n    // (has a then() method) it signs up to be informed when that child promise is\n    // fulfilled at which point it will be fulfilled with that value.\n    //\n    state_waiting = {\n        name: \"waiting\",\n        enter: function (promise) {\n            var waitedUpon = promise._value;\n            // We can special case our own intermediate promises which are not in a\n            //  terminal state by just pushing this promise as a listener without\n            //  having to create new indirection functions\n            if (waitedUpon instanceof ThenPromise &&\n                waitedUpon._state !== state_error &&\n                waitedUpon._state !== state_success) {\n                pushListener(waitedUpon, { promise: promise });\n            } else {\n                var error = function (value) {\n                    if (waitedUpon._errorId) {\n                        promise._chainedError(value, waitedUpon);\n                    } else {\n                        // Because this is an interop boundary we want to indicate that this\n                        //  error has been handled by the promise infrastructure before we\n                        //  begin a new handling chain.\n                        //\n                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);\n                        promise._error(value);\n                    }\n                };\n                error.handlesOnError = true;\n                waitedUpon.then(\n                    promise._completed.bind(promise),\n                    error,\n                    promise._progress.bind(promise)\n                );\n            }\n        },\n        cancel: function (promise) {\n            promise._setState(state_waiting_canceled);\n        },\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Waiting canceled state, when a promise has been in a waiting state and receives a\n    // request to cancel its pending work it will forward that request to the child promise\n    // and then waits to be informed of the result. This promise moves itself into the\n    // canceling state but understands that the child promise may instead push it to a\n    // different state.\n    //\n    state_waiting_canceled = {\n        name: \"waiting_canceled\",\n        enter: function (promise) {\n            // Initiate a transition to canceling. Triggering a cancel on the promise\n            // that we are waiting upon may result in a different state transition\n            // before the state machine pump runs again.\n            promise._setState(state_canceling);\n            var waitedUpon = promise._value;\n            if (waitedUpon.cancel) {\n                waitedUpon.cancel();\n            }\n        },\n        cancel: _,\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Canceled state, moves to the canceling state and then tells the promise to do\n    // whatever it might need to do on cancelation.\n    //\n    state_canceled = {\n        name: \"canceled\",\n        enter: function (promise) {\n            // Initiate a transition to canceling. The _cancelAction may change the state\n            // before the state machine pump runs again.\n            promise._setState(state_canceling);\n            promise._cancelAction();\n        },\n        cancel: _,\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Canceling state, commits to the promise moving to an error state with an error\n    // object whose 'name' and 'message' properties contain the string \"Canceled\"\n    //\n    state_canceling = {\n        name: \"canceling\",\n        enter: function (promise) {\n            var error = new Error(canceledName);\n            error.name = error.message;\n            promise._value = error;\n            promise._setState(state_error_notify);\n        },\n        cancel: _,\n        done: _,\n        then: _,\n        _completed: _,\n        _error: _,\n        _notify: _,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Success notify state, moves a promise to the success state and notifies all children\n    //\n    state_success_notify = {\n        name: \"complete_notify\",\n        enter: function (promise) {\n            promise.done = CompletePromise.prototype.done;\n            promise.then = CompletePromise.prototype.then;\n            if (promise._listeners) {\n                var queue = [promise];\n                var p;\n                while (queue.length) {\n                    p = queue.shift();\n                    p._state._notify(p, queue);\n                }\n            }\n            promise._setState(state_success);\n        },\n        cancel: _,\n        done: null, /*error to get here */\n        then: null, /*error to get here */\n        _completed: _,\n        _error: _,\n        _notify: notifySuccess,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Success state, moves a promise to the success state and does NOT notify any children.\n    // Some upstream promise is owning the notification pass.\n    //\n    state_success = {\n        name: \"success\",\n        enter: function (promise) {\n            promise.done = CompletePromise.prototype.done;\n            promise.then = CompletePromise.prototype.then;\n            promise._cleanupAction();\n        },\n        cancel: _,\n        done: null, /*error to get here */\n        then: null, /*error to get here */\n        _completed: _,\n        _error: _,\n        _notify: notifySuccess,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Error notify state, moves a promise to the error state and notifies all children\n    //\n    state_error_notify = {\n        name: \"error_notify\",\n        enter: function (promise) {\n            promise.done = ErrorPromise.prototype.done;\n            promise.then = ErrorPromise.prototype.then;\n            if (promise._listeners) {\n                var queue = [promise];\n                var p;\n                while (queue.length) {\n                    p = queue.shift();\n                    p._state._notify(p, queue);\n                }\n            }\n            promise._setState(state_error);\n        },\n        cancel: _,\n        done: null, /*error to get here*/\n        then: null, /*error to get here*/\n        _completed: _,\n        _error: _,\n        _notify: notifyError,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Error state, moves a promise to the error state and does NOT notify any children.\n    // Some upstream promise is owning the notification pass.\n    //\n    state_error = {\n        name: \"error\",\n        enter: function (promise) {\n            promise.done = ErrorPromise.prototype.done;\n            promise.then = ErrorPromise.prototype.then;\n            promise._cleanupAction();\n        },\n        cancel: _,\n        done: null, /*error to get here*/\n        then: null, /*error to get here*/\n        _completed: _,\n        _error: _,\n        _notify: notifyError,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    //\n    // The statemachine implementation follows a very particular pattern, the states are specified\n    // as static stateless bags of functions which are then indirected through the state machine\n    // instance (a Promise). As such all of the functions on each state have the promise instance\n    // passed to them explicitly as a parameter and the Promise instance members do a little\n    // dance where they indirect through the state and insert themselves in the argument list.\n    //\n    // We could instead call directly through the promise states however then every caller\n    // would have to remember to do things like pumping the state machine to catch state transitions.\n    //\n\n    var PromiseStateMachine = _Base.Class.define(null, {\n        _listeners: null,\n        _nextState: null,\n        _state: null,\n        _value: null,\n\n        cancel: function () {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n            /// already been fulfilled and cancellation is supported, the promise enters\n            /// the error state with a value of Error(\"Canceled\").\n            /// </summary>\n            /// </signature>\n            this._state.cancel(this);\n            this._run();\n        },\n        done: function Promise_done(onComplete, onError, onProgress) {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n            /// Allows you to specify the work to be done on the fulfillment of the promised value,\n            /// the error handling to be performed if the promise fails to fulfill\n            /// a value, and the handling of progress notifications along the way.\n            ///\n            /// After the handlers have finished executing, this function throws any error that would have been returned\n            /// from then() as a promise in the error state.\n            /// </summary>\n            /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n            /// The function to be called if the promise is fulfilled successfully with a value.\n            /// The fulfilled value is passed as the single argument. If the value is null,\n            /// the fulfilled value is returned. The value returned\n            /// from the function becomes the fulfilled value of the promise returned by\n            /// then(). If an exception is thrown while executing the function, the promise returned\n            /// by then() moves into the error state.\n            /// </param>\n            /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n            /// The function to be called if the promise is fulfilled with an error. The error\n            /// is passed as the single argument. If it is null, the error is forwarded.\n            /// The value returned from the function is the fulfilled value of the promise returned by then().\n            /// </param>\n            /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n            /// the function to be called if the promise reports progress. Data about the progress\n            /// is passed as the single argument. Promises are not required to support\n            /// progress.\n            /// </param>\n            /// </signature>\n            this._state.done(this, onComplete, onError, onProgress);\n        },\n        then: function Promise_then(onComplete, onError, onProgress) {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n            /// Allows you to specify the work to be done on the fulfillment of the promised value,\n            /// the error handling to be performed if the promise fails to fulfill\n            /// a value, and the handling of progress notifications along the way.\n            /// </summary>\n            /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n            /// The function to be called if the promise is fulfilled successfully with a value.\n            /// The value is passed as the single argument. If the value is null, the value is returned.\n            /// The value returned from the function becomes the fulfilled value of the promise returned by\n            /// then(). If an exception is thrown while this function is being executed, the promise returned\n            /// by then() moves into the error state.\n            /// </param>\n            /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n            /// The function to be called if the promise is fulfilled with an error. The error\n            /// is passed as the single argument. If it is null, the error is forwarded.\n            /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n            /// </param>\n            /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n            /// The function to be called if the promise reports progress. Data about the progress\n            /// is passed as the single argument. Promises are not required to support\n            /// progress.\n            /// </param>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n            /// The promise whose value is the result of executing the complete or\n            /// error function.\n            /// </returns>\n            /// </signature>\n            return this._state.then(this, onComplete, onError, onProgress);\n        },\n\n        _chainedError: function (value, context) {\n            var result = this._state._error(this, value, detailsForChainedError, context);\n            this._run();\n            return result;\n        },\n        _completed: function (value) {\n            var result = this._state._completed(this, value);\n            this._run();\n            return result;\n        },\n        _error: function (value) {\n            var result = this._state._error(this, value, detailsForError);\n            this._run();\n            return result;\n        },\n        _progress: function (value) {\n            this._state._progress(this, value);\n        },\n        _setState: function (state) {\n            this._nextState = state;\n        },\n        _setCompleteValue: function (value) {\n            this._state._setCompleteValue(this, value);\n            this._run();\n        },\n        _setChainedErrorValue: function (value, context) {\n            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);\n            this._run();\n            return result;\n        },\n        _setExceptionValue: function (value) {\n            var result = this._state._setErrorValue(this, value, detailsForException);\n            this._run();\n            return result;\n        },\n        _run: function () {\n            while (this._nextState) {\n                this._state = this._nextState;\n                this._nextState = null;\n                this._state.enter(this);\n            }\n        }\n    }, {\n        supportedForProcessing: false\n    });\n\n    //\n    // Implementations of shared state machine code.\n    //\n\n    function completed(promise, value) {\n        var targetState;\n        if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n            targetState = state_waiting;\n        } else {\n            targetState = state_success_notify;\n        }\n        promise._value = value;\n        promise._setState(targetState);\n    }\n    function createErrorDetails(exception, error, promise, id, parent, handler) {\n        return {\n            exception: exception,\n            error: error,\n            promise: promise,\n            handler: handler,\n            id: id,\n            parent: parent\n        };\n    }\n    function detailsForHandledError(promise, errorValue, context, handler) {\n        var exception = context._isException;\n        var errorId = context._errorId;\n        return createErrorDetails(\n            exception ? errorValue : null,\n            exception ? null : errorValue,\n            promise,\n            errorId,\n            context,\n            handler\n        );\n    }\n    function detailsForChainedError(promise, errorValue, context) {\n        var exception = context._isException;\n        var errorId = context._errorId;\n        setErrorInfo(promise, errorId, exception);\n        return createErrorDetails(\n            exception ? errorValue : null,\n            exception ? null : errorValue,\n            promise,\n            errorId,\n            context\n        );\n    }\n    function detailsForError(promise, errorValue) {\n        var errorId = ++error_number;\n        setErrorInfo(promise, errorId);\n        return createErrorDetails(\n            null,\n            errorValue,\n            promise,\n            errorId\n        );\n    }\n    function detailsForException(promise, exceptionValue) {\n        var errorId = ++error_number;\n        setErrorInfo(promise, errorId, true);\n        return createErrorDetails(\n            exceptionValue,\n            null,\n            promise,\n            errorId\n        );\n    }\n    function done(promise, onComplete, onError, onProgress) {\n        var asyncOpID = _Trace._traceAsyncOperationStarting(\"WinJS.Promise.done\");\n        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });\n    }\n    function error(promise, value, onerrorDetails, context) {\n        promise._value = value;\n        callonerror(promise, value, onerrorDetails, context);\n        promise._setState(state_error_notify);\n    }\n    function notifySuccess(promise, queue) {\n        var value = promise._value;\n        var listeners = promise._listeners;\n        if (!listeners) {\n            return;\n        }\n        promise._listeners = null;\n        var i, len;\n        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n            var listener = len === 1 ? listeners : listeners[i];\n            var onComplete = listener.c;\n            var target = listener.promise;\n\n            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);\n\n            if (target) {\n                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);\n                try {\n                    target._setCompleteValue(onComplete ? onComplete(value) : value);\n                } catch (ex) {\n                    target._setExceptionValue(ex);\n                } finally {\n                    _Trace._traceAsyncCallbackCompleted();\n                }\n                if (target._state !== state_waiting && target._listeners) {\n                    queue.push(target);\n                }\n            } else {\n                CompletePromise.prototype.done.call(promise, onComplete);\n            }\n        }\n    }\n    function notifyError(promise, queue) {\n        var value = promise._value;\n        var listeners = promise._listeners;\n        if (!listeners) {\n            return;\n        }\n        promise._listeners = null;\n        var i, len;\n        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n            var listener = len === 1 ? listeners : listeners[i];\n            var onError = listener.e;\n            var target = listener.promise;\n\n            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);\n            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);\n\n            if (target) {\n                var asyncCallbackStarted = false;\n                try {\n                    if (onError) {\n                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);\n                        asyncCallbackStarted = true;\n                        if (!onError.handlesOnError) {\n                            callonerror(target, value, detailsForHandledError, promise, onError);\n                        }\n                        target._setCompleteValue(onError(value));\n                    } else {\n                        target._setChainedErrorValue(value, promise);\n                    }\n                } catch (ex) {\n                    target._setExceptionValue(ex);\n                } finally {\n                    if (asyncCallbackStarted) {\n                        _Trace._traceAsyncCallbackCompleted();\n                    }\n                }\n                if (target._state !== state_waiting && target._listeners) {\n                    queue.push(target);\n                }\n            } else {\n                ErrorPromise.prototype.done.call(promise, null, onError);\n            }\n        }\n    }\n    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {\n        if (promiseEventListeners._listeners[errorET]) {\n            if (value instanceof Error && value.message === canceledName) {\n                return;\n            }\n            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));\n        }\n    }\n    function progress(promise, value) {\n        var listeners = promise._listeners;\n        if (listeners) {\n            var i, len;\n            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n                var listener = len === 1 ? listeners : listeners[i];\n                var onProgress = listener.p;\n                if (onProgress) {\n                    try { onProgress(value); } catch (ex) { }\n                }\n                if (!(listener.c || listener.e) && listener.promise) {\n                    listener.promise._progress(value);\n                }\n            }\n        }\n    }\n    function pushListener(promise, listener) {\n        var listeners = promise._listeners;\n        if (listeners) {\n            // We may have either a single listener (which will never be wrapped in an array)\n            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener\n            // we may have to wrap the single listener before adding the second.\n            listeners = Array.isArray(listeners) ? listeners : [listeners];\n            listeners.push(listener);\n        } else {\n            listeners = listener;\n        }\n        promise._listeners = listeners;\n    }\n    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves\n    // a promise directly to the success/error state without starting another notification pass (because one\n    // is already ongoing).\n    function setErrorInfo(promise, errorId, isException) {\n        promise._isException = isException || false;\n        promise._errorId = errorId;\n    }\n    function setErrorValue(promise, value, onerrorDetails, context) {\n        promise._value = value;\n        callonerror(promise, value, onerrorDetails, context);\n        promise._setState(state_error);\n    }\n    function setCompleteValue(promise, value) {\n        var targetState;\n        if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n            targetState = state_waiting;\n        } else {\n            targetState = state_success;\n        }\n        promise._value = value;\n        promise._setState(targetState);\n    }\n    function then(promise, onComplete, onError, onProgress) {\n        var result = new ThenPromise(promise);\n        var asyncOpID = _Trace._traceAsyncOperationStarting(\"WinJS.Promise.then\");\n        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });\n        return result;\n    }\n\n    //\n    // Internal implementation detail promise, ThenPromise is created when a promise needs\n    // to be returned from a then() method.\n    //\n    var ThenPromise = _Base.Class.derive(PromiseStateMachine,\n        function (creator) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {\n                this._stack = Promise._getStack();\n            }\n\n            this._creator = creator;\n            this._setState(state_created);\n            this._run();\n        }, {\n            _creator: null,\n\n            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },\n            _cleanupAction: function () { this._creator = null; }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    //\n    // Slim promise implementations for already completed promises, these are created\n    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap\n    // and WinJS.Promise.wrapError.\n    //\n\n    var ErrorPromise = _Base.Class.define(\n        function ErrorPromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {\n                this._stack = Promise._getStack();\n            }\n\n            this._value = value;\n            callonerror(this, value, detailsForError);\n        }, {\n            cancel: function () {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n                /// already been fulfilled and cancellation is supported, the promise enters\n                /// the error state with a value of Error(\"Canceled\").\n                /// </summary>\n                /// </signature>\n            },\n            done: function ErrorPromise_done(unused, onError) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                ///\n                /// After the handlers have finished executing, this function throws any error that would have been returned\n                /// from then() as a promise in the error state.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The fulfilled value is passed as the single argument. If the value is null,\n                /// the fulfilled value is returned. The value returned\n                /// from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while executing the function, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function is the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n                /// the function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// </signature>\n                var value = this._value;\n                if (onError) {\n                    try {\n                        if (!onError.handlesOnError) {\n                            callonerror(null, value, detailsForHandledError, this, onError);\n                        }\n                        var result = onError(value);\n                        if (result && typeof result === \"object\" && typeof result.done === \"function\") {\n                            // If a promise is returned we need to wait on it.\n                            result.done();\n                        }\n                        return;\n                    } catch (ex) {\n                        value = ex;\n                    }\n                }\n                if (value instanceof Error && value.message === canceledName) {\n                    // suppress cancel\n                    return;\n                }\n                // force the exception to be thrown asyncronously to avoid any try/catch blocks\n                //\n                Promise._doneHandler(value);\n            },\n            then: function ErrorPromise_then(unused, onError) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The value is passed as the single argument. If the value is null, the value is returned.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while this function is being executed, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n                /// The promise whose value is the result of executing the complete or\n                /// error function.\n                /// </returns>\n                /// </signature>\n\n                // If the promise is already in a error state and no error handler is provided\n                // we optimize by simply returning the promise instead of creating a new one.\n                //\n                if (!onError) { return this; }\n                var result;\n                var value = this._value;\n                try {\n                    if (!onError.handlesOnError) {\n                        callonerror(null, value, detailsForHandledError, this, onError);\n                    }\n                    result = new CompletePromise(onError(value));\n                } catch (ex) {\n                    // If the value throw from the error handler is the same as the value\n                    // provided to the error handler then there is no need for a new promise.\n                    //\n                    if (ex === value) {\n                        result = this;\n                    } else {\n                        result = new ExceptionPromise(ex);\n                    }\n                }\n                return result;\n            }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var ExceptionPromise = _Base.Class.derive(ErrorPromise,\n        function ExceptionPromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {\n                this._stack = Promise._getStack();\n            }\n\n            this._value = value;\n            callonerror(this, value, detailsForException);\n        }, {\n            /* empty */\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var CompletePromise = _Base.Class.define(\n        function CompletePromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {\n                this._stack = Promise._getStack();\n            }\n\n            if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n                var result = new ThenPromise(null);\n                result._setCompleteValue(value);\n                return result;\n            }\n            this._value = value;\n        }, {\n            cancel: function () {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n                /// already been fulfilled and cancellation is supported, the promise enters\n                /// the error state with a value of Error(\"Canceled\").\n                /// </summary>\n                /// </signature>\n            },\n            done: function CompletePromise_done(onComplete) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                ///\n                /// After the handlers have finished executing, this function throws any error that would have been returned\n                /// from then() as a promise in the error state.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The fulfilled value is passed as the single argument. If the value is null,\n                /// the fulfilled value is returned. The value returned\n                /// from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while executing the function, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function is the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n                /// the function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// </signature>\n                if (!onComplete) { return; }\n                try {\n                    var result = onComplete(this._value);\n                    if (result && typeof result === \"object\" && typeof result.done === \"function\") {\n                        result.done();\n                    }\n                } catch (ex) {\n                    // force the exception to be thrown asynchronously to avoid any try/catch blocks\n                    Promise._doneHandler(ex);\n                }\n            },\n            then: function CompletePromise_then(onComplete) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The value is passed as the single argument. If the value is null, the value is returned.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while this function is being executed, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n                /// The promise whose value is the result of executing the complete or\n                /// error function.\n                /// </returns>\n                /// </signature>\n                try {\n                    // If the value returned from the completion handler is the same as the value\n                    // provided to the completion handler then there is no need for a new promise.\n                    //\n                    var newValue = onComplete ? onComplete(this._value) : this._value;\n                    return newValue === this._value ? this : new CompletePromise(newValue);\n                } catch (ex) {\n                    return new ExceptionPromise(ex);\n                }\n            }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    //\n    // Promise is the user-creatable WinJS.Promise object.\n    //\n\n    function timeout(timeoutMS) {\n        var id;\n        return new Promise(\n            function (c) {\n                if (timeoutMS) {\n                    id = _Global.setTimeout(c, timeoutMS);\n                } else {\n                    _BaseCoreUtils._setImmediate(c);\n                }\n            },\n            function () {\n                if (id) {\n                    _Global.clearTimeout(id);\n                }\n            }\n        );\n    }\n\n    function timeoutWithPromise(timeout, promise) {\n        var cancelPromise = function () { promise.cancel(); };\n        var cancelTimeout = function () { timeout.cancel(); };\n        timeout.then(cancelPromise);\n        promise.then(cancelTimeout, cancelTimeout);\n        return promise;\n    }\n\n    var staticCanceledPromise;\n\n    var Promise = _Base.Class.derive(PromiseStateMachine,\n        function Promise_ctor(init, oncancel) {\n            /// <signature helpKeyword=\"WinJS.Promise\">\n            /// <summary locid=\"WinJS.Promise\">\n            /// A promise provides a mechanism to schedule work to be done on a value that\n            /// has not yet been computed. It is a convenient abstraction for managing\n            /// interactions with asynchronous APIs.\n            /// </summary>\n            /// <param name=\"init\" type=\"Function\" locid=\"WinJS.Promise_p:init\">\n            /// The function that is called during construction of the  promise. The function\n            /// is given three arguments (complete, error, progress). Inside this function\n            /// you should add event listeners for the notifications supported by this value.\n            /// </param>\n            /// <param name=\"oncancel\" optional=\"true\" locid=\"WinJS.Promise_p:oncancel\">\n            /// The function to call if a consumer of this promise wants\n            /// to cancel its undone work. Promises are not required to\n            /// support cancellation.\n            /// </param>\n            /// </signature>\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {\n                this._stack = Promise._getStack();\n            }\n\n            this._oncancel = oncancel;\n            this._setState(state_created);\n            this._run();\n\n            try {\n                var complete = this._completed.bind(this);\n                var error = this._error.bind(this);\n                var progress = this._progress.bind(this);\n                init(complete, error, progress);\n            } catch (ex) {\n                this._setExceptionValue(ex);\n            }\n        }, {\n            _oncancel: null,\n\n            _cancelAction: function () {\n                // BEGIN monaco change\n                try {\n                    if (this._oncancel) {\n                        this._oncancel();\n                    } else {\n                        throw new Error('Promise did not implement oncancel');\n                    }\n                } catch (ex) {\n                    // Access fields to get them created\n                    var msg = ex.message;\n                    var stack = ex.stack;\n                    promiseEventListeners.dispatchEvent('error', ex);\n                }\n                // END monaco change\n            },\n            _cleanupAction: function () { this._oncancel = null; }\n        }, {\n\n            addEventListener: function Promise_addEventListener(eventType, listener, capture) {\n                /// <signature helpKeyword=\"WinJS.Promise.addEventListener\">\n                /// <summary locid=\"WinJS.Promise.addEventListener\">\n                /// Adds an event listener to the control.\n                /// </summary>\n                /// <param name=\"eventType\" locid=\"WinJS.Promise.addEventListener_p:eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name=\"listener\" locid=\"WinJS.Promise.addEventListener_p:listener\">\n                /// The listener to invoke when the event is raised.\n                /// </param>\n                /// <param name=\"capture\" locid=\"WinJS.Promise.addEventListener_p:capture\">\n                /// Specifies whether or not to initiate capture.\n                /// </param>\n                /// </signature>\n                promiseEventListeners.addEventListener(eventType, listener, capture);\n            },\n            any: function Promise_any(values) {\n                /// <signature helpKeyword=\"WinJS.Promise.any\">\n                /// <summary locid=\"WinJS.Promise.any\">\n                /// Returns a promise that is fulfilled when one of the input promises\n                /// has been fulfilled.\n                /// </summary>\n                /// <param name=\"values\" type=\"Array\" locid=\"WinJS.Promise.any_p:values\">\n                /// An array that contains promise objects or objects whose property\n                /// values include promise objects.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.any_returnValue\">\n                /// A promise that on fulfillment yields the value of the input (complete or error).\n                /// </returns>\n                /// </signature>\n                return new Promise(\n                    function (complete, error) {\n                        var keys = Object.keys(values);\n                        if (keys.length === 0) {\n                            complete();\n                        }\n                        var canceled = 0;\n                        keys.forEach(function (key) {\n                            Promise.as(values[key]).then(\n                                function () { complete({ key: key, value: values[key] }); },\n                                function (e) {\n                                    if (e instanceof Error && e.name === canceledName) {\n                                        if ((++canceled) === keys.length) {\n                                            complete(Promise.cancel);\n                                        }\n                                        return;\n                                    }\n                                    error({ key: key, value: values[key] });\n                                }\n                            );\n                        });\n                    },\n                    function () {\n                        var keys = Object.keys(values);\n                        keys.forEach(function (key) {\n                            var promise = Promise.as(values[key]);\n                            if (typeof promise.cancel === \"function\") {\n                                promise.cancel();\n                            }\n                        });\n                    }\n                );\n            },\n            as: function Promise_as(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.as\">\n                /// <summary locid=\"WinJS.Promise.as\">\n                /// Returns a promise. If the object is already a promise it is returned;\n                /// otherwise the object is wrapped in a promise.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.as_p:value\">\n                /// The value to be treated as a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.as_returnValue\">\n                /// A promise.\n                /// </returns>\n                /// </signature>\n                if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n                    return value;\n                }\n                return new CompletePromise(value);\n            },\n            /// <field type=\"WinJS.Promise\" helpKeyword=\"WinJS.Promise.cancel\" locid=\"WinJS.Promise.cancel\">\n            /// Canceled promise value, can be returned from a promise completion handler\n            /// to indicate cancelation of the promise chain.\n            /// </field>\n            cancel: {\n                get: function () {\n                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));\n                }\n            },\n            dispatchEvent: function Promise_dispatchEvent(eventType, details) {\n                /// <signature helpKeyword=\"WinJS.Promise.dispatchEvent\">\n                /// <summary locid=\"WinJS.Promise.dispatchEvent\">\n                /// Raises an event of the specified type and properties.\n                /// </summary>\n                /// <param name=\"eventType\" locid=\"WinJS.Promise.dispatchEvent_p:eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name=\"details\" locid=\"WinJS.Promise.dispatchEvent_p:details\">\n                /// The set of additional properties to be attached to the event object.\n                /// </param>\n                /// <returns type=\"Boolean\" locid=\"WinJS.Promise.dispatchEvent_returnValue\">\n                /// Specifies whether preventDefault was called on the event.\n                /// </returns>\n                /// </signature>\n                return promiseEventListeners.dispatchEvent(eventType, details);\n            },\n            is: function Promise_is(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.is\">\n                /// <summary locid=\"WinJS.Promise.is\">\n                /// Determines whether a value fulfills the promise contract.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.is_p:value\">\n                /// A value that may be a promise.\n                /// </param>\n                /// <returns type=\"Boolean\" locid=\"WinJS.Promise.is_returnValue\">\n                /// true if the specified value is a promise, otherwise false.\n                /// </returns>\n                /// </signature>\n                return value && typeof value === \"object\" && typeof value.then === \"function\";\n            },\n            join: function Promise_join(values) {\n                /// <signature helpKeyword=\"WinJS.Promise.join\">\n                /// <summary locid=\"WinJS.Promise.join\">\n                /// Creates a promise that is fulfilled when all the values are fulfilled.\n                /// </summary>\n                /// <param name=\"values\" type=\"Object\" locid=\"WinJS.Promise.join_p:values\">\n                /// An object whose fields contain values, some of which may be promises.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.join_returnValue\">\n                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where\n                /// each field value is the fulfilled value of a promise.\n                /// </returns>\n                /// </signature>\n                return new Promise(\n                    function (complete, error, progress) {\n                        var keys = Object.keys(values);\n                        var errors = Array.isArray(values) ? [] : {};\n                        var results = Array.isArray(values) ? [] : {};\n                        var undefineds = 0;\n                        var pending = keys.length;\n                        var argDone = function (key) {\n                            if ((--pending) === 0) {\n                                var errorCount = Object.keys(errors).length;\n                                if (errorCount === 0) {\n                                    complete(results);\n                                } else {\n                                    var canceledCount = 0;\n                                    keys.forEach(function (key) {\n                                        var e = errors[key];\n                                        if (e instanceof Error && e.name === canceledName) {\n                                            canceledCount++;\n                                        }\n                                    });\n                                    if (canceledCount === errorCount) {\n                                        complete(Promise.cancel);\n                                    } else {\n                                        error(errors);\n                                    }\n                                }\n                            } else {\n                                progress({ Key: key, Done: true });\n                            }\n                        };\n                        keys.forEach(function (key) {\n                            var value = values[key];\n                            if (value === undefined) {\n                                undefineds++;\n                            } else {\n                                Promise.then(value,\n                                    function (value) { results[key] = value; argDone(key); },\n                                    function (value) { errors[key] = value; argDone(key); }\n                                );\n                            }\n                        });\n                        pending -= undefineds;\n                        if (pending === 0) {\n                            complete(results);\n                            return;\n                        }\n                    },\n                    function () {\n                        Object.keys(values).forEach(function (key) {\n                            var promise = Promise.as(values[key]);\n                            if (typeof promise.cancel === \"function\") {\n                                promise.cancel();\n                            }\n                        });\n                    }\n                );\n            },\n            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {\n                /// <signature helpKeyword=\"WinJS.Promise.removeEventListener\">\n                /// <summary locid=\"WinJS.Promise.removeEventListener\">\n                /// Removes an event listener from the control.\n                /// </summary>\n                /// <param name='eventType' locid=\"WinJS.Promise.removeEventListener_eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name='listener' locid=\"WinJS.Promise.removeEventListener_listener\">\n                /// The listener to remove.\n                /// </param>\n                /// <param name='capture' locid=\"WinJS.Promise.removeEventListener_capture\">\n                /// Specifies whether or not to initiate capture.\n                /// </param>\n                /// </signature>\n                promiseEventListeners.removeEventListener(eventType, listener, capture);\n            },\n            supportedForProcessing: false,\n            then: function Promise_then(value, onComplete, onError, onProgress) {\n                /// <signature helpKeyword=\"WinJS.Promise.then\">\n                /// <summary locid=\"WinJS.Promise.then\">\n                /// A static version of the promise instance method then().\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.then_p:value\">\n                /// the value to be treated as a promise.\n                /// </param>\n                /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.Promise.then_p:complete\">\n                /// The function to be called if the promise is fulfilled with a value.\n                /// If it is null, the promise simply\n                /// returns the value. The value is passed as the single argument.\n                /// </param>\n                /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.then_p:error\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument.\n                /// </param>\n                /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.then_p:progress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.then_returnValue\">\n                /// A promise whose value is the result of executing the provided complete function.\n                /// </returns>\n                /// </signature>\n                return Promise.as(value).then(onComplete, onError, onProgress);\n            },\n            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {\n                /// <signature helpKeyword=\"WinJS.Promise.thenEach\">\n                /// <summary locid=\"WinJS.Promise.thenEach\">\n                /// Performs an operation on all the input promises and returns a promise\n                /// that has the shape of the input and contains the result of the operation\n                /// that has been performed on each input.\n                /// </summary>\n                /// <param name=\"values\" locid=\"WinJS.Promise.thenEach_p:values\">\n                /// A set of values (which could be either an array or an object) of which some or all are promises.\n                /// </param>\n                /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.Promise.thenEach_p:complete\">\n                /// The function to be called if the promise is fulfilled with a value.\n                /// If the value is null, the promise returns the value.\n                /// The value is passed as the single argument.\n                /// </param>\n                /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.thenEach_p:error\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument.\n                /// </param>\n                /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.thenEach_p:progress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.thenEach_returnValue\">\n                /// A promise that is the result of calling Promise.join on the values parameter.\n                /// </returns>\n                /// </signature>\n                var result = Array.isArray(values) ? [] : {};\n                Object.keys(values).forEach(function (key) {\n                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);\n                });\n                return Promise.join(result);\n            },\n            timeout: function Promise_timeout(time, promise) {\n                /// <signature helpKeyword=\"WinJS.Promise.timeout\">\n                /// <summary locid=\"WinJS.Promise.timeout\">\n                /// Creates a promise that is fulfilled after a timeout.\n                /// </summary>\n                /// <param name=\"timeout\" type=\"Number\" optional=\"true\" locid=\"WinJS.Promise.timeout_p:timeout\">\n                /// The timeout period in milliseconds. If this value is zero or not specified\n                /// setImmediate is called, otherwise setTimeout is called.\n                /// </param>\n                /// <param name=\"promise\" type=\"Promise\" optional=\"true\" locid=\"WinJS.Promise.timeout_p:promise\">\n                /// A promise that will be canceled if it doesn't complete before the\n                /// timeout has expired.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.timeout_returnValue\">\n                /// A promise that is completed asynchronously after the specified timeout.\n                /// </returns>\n                /// </signature>\n                var to = timeout(time);\n                return promise ? timeoutWithPromise(to, promise) : to;\n            },\n            wrap: function Promise_wrap(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.wrap\">\n                /// <summary locid=\"WinJS.Promise.wrap\">\n                /// Wraps a non-promise value in a promise. You can use this function if you need\n                /// to pass a value to a function that requires a promise.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.wrap_p:value\">\n                /// Some non-promise value to be wrapped in a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.wrap_returnValue\">\n                /// A promise that is successfully fulfilled with the specified value\n                /// </returns>\n                /// </signature>\n                return new CompletePromise(value);\n            },\n            wrapError: function Promise_wrapError(error) {\n                /// <signature helpKeyword=\"WinJS.Promise.wrapError\">\n                /// <summary locid=\"WinJS.Promise.wrapError\">\n                /// Wraps a non-promise error value in a promise. You can use this function if you need\n                /// to pass an error to a function that requires a promise.\n                /// </summary>\n                /// <param name=\"error\" locid=\"WinJS.Promise.wrapError_p:error\">\n                /// A non-promise error value to be wrapped in a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.wrapError_returnValue\">\n                /// A promise that is in an error state with the specified value.\n                /// </returns>\n                /// </signature>\n                return new ErrorPromise(error);\n            },\n\n            _veryExpensiveTagWithStack: {\n                get: function () { return tagWithStack; },\n                set: function (value) { tagWithStack = value; }\n            },\n            _veryExpensiveTagWithStack_tag: tag,\n            _getStack: function () {\n                if (_Global.Debug && _Global.Debug.debuggerEnabled) {\n                    try { throw new Error(); } catch (e) { return e.stack; }\n                }\n            },\n\n            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {\n                //\n                // Returns a promise which on cancelation will still result in downstream cancelation while\n                //  protecting the promise 'input' from being  canceled which has the effect of allowing\n                //  'input' to be shared amoung various consumers.\n                //\n                if (!Promise.is(input)) {\n                    return Promise.wrap(input);\n                }\n                var complete;\n                var error;\n                var output = new Promise(\n                    function (c, e) {\n                        complete = c;\n                        error = e;\n                    },\n                    function () {\n                        complete = null;\n                        error = null;\n                        oncancel && oncancel();\n                    }\n                );\n                input.then(\n                    function (v) { complete && complete(v); },\n                    function (e) { error && error(e); }\n                );\n                return output;\n            },\n\n        }\n    );\n    Object.defineProperties(Promise, _Events.createEventProperties(errorET));\n\n    Promise._doneHandler = function (value) {\n        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {\n            throw value;\n        });\n    };\n\n    return {\n        PromiseStateMachine: PromiseStateMachine,\n        Promise: Promise,\n        state_created: state_created\n    };\n});\n\n_winjs(\"WinJS/Promise\", [\"WinJS/Core/_Base\",\"WinJS/Promise/_StateMachine\"], function promiseInit( _Base, _StateMachine) {\n    \"use strict\";\n\n    _Base.Namespace.define(\"WinJS\", {\n        Promise: _StateMachine.Promise\n    });\n\n    return _StateMachine.Promise;\n});\n\n__winjs_exports = _modules[\"WinJS/Core/_WinJS\"];\n__winjs_exports.TPromise = __winjs_exports.Promise;\n__winjs_exports.PPromise = __winjs_exports.Promise;\n\n// ESM-comment-begin\n// if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {\n//     define([], __winjs_exports);\n// } else {\n//     module.exports = __winjs_exports;\n// }\n// ESM-comment-end\n\n})();\n\n// ESM-uncomment-begin\nvar Promise = __winjs_exports.Promise;\nvar TPromise = __winjs_exports.TPromise;\nvar PPromise = __winjs_exports.PPromise;\n// ESM-uncomment-end\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vd2luanMuYmFzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93aW5qcy5iYXNlLmpzPzU0YzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRyYWN0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vd2luanMvd2luanNcbiAqIFZlcnNpb246IDQuNC4wKGVjMzI1OGE5ZjNhMzY4MDVhMTg3ODQ4OTg0ZTNiYjkzODA0NDE3OGQpXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBfX3dpbmpzX2V4cG9ydHM7XG5cbihmdW5jdGlvbigpIHtcblxudmFyIF9tb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsvL3t9O1xuX21vZHVsZXNbXCJXaW5KUy9Db3JlL19XaW5KU1wiXSA9IHt9O1xuXG52YXIgX3dpbmpzID0gZnVuY3Rpb24obW9kdWxlSWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIHZhciBleHBvcnRzUGFzc2VkSW4gPSBmYWxzZTtcblxuICAgIHZhciBkZXBzVmFsdWVzID0gZGVwcy5tYXAoZnVuY3Rpb24oZGVwKSB7XG4gICAgICAgIGlmIChkZXAgPT09ICdleHBvcnRzJykge1xuICAgICAgICAgICAgZXhwb3J0c1Bhc3NlZEluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbW9kdWxlc1tkZXBdO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlc3VsdCA9IGZhY3RvcnkuYXBwbHkoe30sIGRlcHNWYWx1ZXMpO1xuXG4gICAgX21vZHVsZXNbbW9kdWxlSWRdID0gZXhwb3J0c1Bhc3NlZEluID8gZXhwb3J0cyA6IHJlc3VsdDtcbn07XG5cblxuX3dpbmpzKFwiV2luSlMvQ29yZS9fR2xvYmFsXCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBBcHBlYXNlIGpzaGludFxuICAgIC8qIGdsb2JhbCB3aW5kb3csIHNlbGYsIGdsb2JhbCAqL1xuXG4gICAgdmFyIGdsb2JhbE9iamVjdCA9XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgICAgIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICAgICAge307XG4gICAgcmV0dXJuIGdsb2JhbE9iamVjdDtcbn0pO1xuXG5fd2luanMoXCJXaW5KUy9Db3JlL19CYXNlQ29yZVV0aWxzXCIsIFtcIldpbkpTL0NvcmUvX0dsb2JhbFwiXSwgZnVuY3Rpb24gYmFzZUNvcmVVdGlsc0luaXQoX0dsb2JhbCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGhhc1dpblJUID0gISFfR2xvYmFsLldpbmRvd3M7XG5cbiAgICBmdW5jdGlvbiBtYXJrU3VwcG9ydGVkRm9yUHJvY2Vzc2luZyhmdW5jKSB7XG4gICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuVXRpbGl0aWVzLm1hcmtTdXBwb3J0ZWRGb3JQcm9jZXNzaW5nXCI+XG4gICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlV0aWxpdGllcy5tYXJrU3VwcG9ydGVkRm9yUHJvY2Vzc2luZ1wiPlxuICAgICAgICAvLy8gTWFya3MgYSBmdW5jdGlvbiBhcyBiZWluZyBjb21wYXRpYmxlIHdpdGggZGVjbGFyYXRpdmUgcHJvY2Vzc2luZywgc3VjaCBhcyBXaW5KUy5VSS5wcm9jZXNzQWxsXG4gICAgICAgIC8vLyBvciBXaW5KUy5CaW5kaW5nLnByb2Nlc3NBbGwuXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZ1bmNcIiB0eXBlPVwiRnVuY3Rpb25cIiBsb2NpZD1cIldpbkpTLlV0aWxpdGllcy5tYXJrU3VwcG9ydGVkRm9yUHJvY2Vzc2luZ19wOmZ1bmNcIj5cbiAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBtYXJrZWQgYXMgY29tcGF0aWJsZSB3aXRoIGRlY2xhcmF0aXZlIHByb2Nlc3NpbmcuXG4gICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIkZ1bmN0aW9uXCIgbG9jaWQ9XCJXaW5KUy5VdGlsaXRpZXMubWFya1N1cHBvcnRlZEZvclByb2Nlc3NpbmdfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgLy8vIFRoZSBpbnB1dCBmdW5jdGlvbi5cbiAgICAgICAgLy8vIDwvcmV0dXJucz5cbiAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICBmdW5jLnN1cHBvcnRlZEZvclByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG5cbiAgICB2YXIgYWN0dWFsU2V0SW1tZWRpYXRlID0gbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhhc1dpblJUOiBoYXNXaW5SVCxcbiAgICAgICAgbWFya1N1cHBvcnRlZEZvclByb2Nlc3Npbmc6IG1hcmtTdXBwb3J0ZWRGb3JQcm9jZXNzaW5nLFxuICAgICAgICBfc2V0SW1tZWRpYXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIEJFR0lOIG1vbmFjbyBjaGFuZ2VcbiAgICAgICAgICAgIGlmIChhY3R1YWxTZXRJbW1lZGlhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX0dsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsU2V0SW1tZWRpYXRlID0gX0dsb2JhbC5zZXRJbW1lZGlhdGUuYmluZChfR2xvYmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxTZXRJbW1lZGlhdGUgPSBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsU2V0SW1tZWRpYXRlID0gX0dsb2JhbC5zZXRUaW1lb3V0LmJpbmQoX0dsb2JhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0dWFsU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIEVORCBtb25hY28gY2hhbmdlXG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5fd2luanMoXCJXaW5KUy9Db3JlL19Xcml0ZVByb2ZpbGVyTWFya1wiLCBbXCJXaW5KUy9Db3JlL19HbG9iYWxcIl0sIGZ1bmN0aW9uIHByb2ZpbGVySW5pdChfR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICByZXR1cm4gX0dsb2JhbC5tc1dyaXRlUHJvZmlsZXJNYXJrIHx8IGZ1bmN0aW9uICgpIHsgfTtcbn0pO1xuX3dpbmpzKFwiV2luSlMvQ29yZS9fQmFzZVwiLCBbXCJXaW5KUy9Db3JlL19XaW5KU1wiLFwiV2luSlMvQ29yZS9fR2xvYmFsXCIsXCJXaW5KUy9Db3JlL19CYXNlQ29yZVV0aWxzXCIsXCJXaW5KUy9Db3JlL19Xcml0ZVByb2ZpbGVyTWFya1wiXSwgZnVuY3Rpb24gYmFzZUluaXQoX1dpbkpTLCBfR2xvYmFsLCBfQmFzZUNvcmVVdGlscywgX1dyaXRlUHJvZmlsZXJNYXJrKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplUHJvcGVydGllcyh0YXJnZXQsIG1lbWJlcnMsIHByZWZpeCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lbWJlcnMpO1xuICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXM7XG4gICAgICAgIHZhciBpLCBsZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIGVudW1lcmFibGUgPSBrZXkuY2hhckNvZGVBdCgwKSAhPT0gLypfKi85NTtcbiAgICAgICAgICAgIHZhciBtZW1iZXIgPSBtZW1iZXJzW2tleV07XG4gICAgICAgICAgICBpZiAobWVtYmVyICYmIHR5cGVvZiBtZW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlci52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZW1iZXIuZ2V0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBtZW1iZXIuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuZW51bWVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCAmJiBtZW1iZXIuc2V0TmFtZSAmJiB0eXBlb2YgbWVtYmVyLnNldE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5zZXROYW1lKHByZWZpeCArIFwiLlwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1trZXldID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVudW1lcmFibGUpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB7IHZhbHVlOiBtZW1iZXIsIGVudW1lcmFibGU6IGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lbWJlcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgX3Jvb3ROYW1lc3BhY2UgPSBfV2luSlM7XG4gICAgICAgIGlmICghX3Jvb3ROYW1lc3BhY2UuTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBfcm9vdE5hbWVzcGFjZS5OYW1lc3BhY2UgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2UgfHwge307XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2VGcmFnbWVudHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWVzcGFjZSA9PT0gX0dsb2JhbCAmJiBuYW1lc3BhY2VGcmFnbWVudHNbMF0gPT09IFwiV2luSlNcIikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmFtZXNwYWNlID0gX1dpbkpTO1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VGcmFnbWVudHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbmFtZXNwYWNlRnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2VOYW1lID0gbmFtZXNwYWNlRnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROYW1lc3BhY2VbbmFtZXNwYWNlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyZW50TmFtZXNwYWNlLCBuYW1lc3BhY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROYW1lc3BhY2UgPSBjdXJyZW50TmFtZXNwYWNlW25hbWVzcGFjZU5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TmFtZXNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lV2l0aFBhcmVudChwYXJlbnROYW1lc3BhY2UsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuTmFtZXNwYWNlLmRlZmluZVdpdGhQYXJlbnRcIj5cbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLk5hbWVzcGFjZS5kZWZpbmVXaXRoUGFyZW50XCI+XG4gICAgICAgICAgICAvLy8gRGVmaW5lcyBhIG5ldyBuYW1lc3BhY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgdW5kZXIgdGhlIHNwZWNpZmllZCBwYXJlbnQgbmFtZXNwYWNlLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBhcmVudE5hbWVzcGFjZVwiIHR5cGU9XCJPYmplY3RcIiBsb2NpZD1cIldpbkpTLk5hbWVzcGFjZS5kZWZpbmVXaXRoUGFyZW50X3A6cGFyZW50TmFtZXNwYWNlXCI+XG4gICAgICAgICAgICAvLy8gVGhlIHBhcmVudCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5hbWVcIiB0eXBlPVwiU3RyaW5nXCIgbG9jaWQ9XCJXaW5KUy5OYW1lc3BhY2UuZGVmaW5lV2l0aFBhcmVudF9wOm5hbWVcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgbmFtZSBvZiB0aGUgbmV3IG5hbWVzcGFjZS5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWVtYmVyc1wiIHR5cGU9XCJPYmplY3RcIiBsb2NpZD1cIldpbkpTLk5hbWVzcGFjZS5kZWZpbmVXaXRoUGFyZW50X3A6bWVtYmVyc1wiPlxuICAgICAgICAgICAgLy8vIFRoZSBtZW1iZXJzIG9mIHRoZSBuZXcgbmFtZXNwYWNlLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIk9iamVjdFwiIGxvY2lkPVwiV2luSlMuTmFtZXNwYWNlLmRlZmluZVdpdGhQYXJlbnRfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgbmV3bHktZGVmaW5lZCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgdmFyIGN1cnJlbnROYW1lc3BhY2UgPSBjcmVhdGVOYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCBuYW1lKTtcblxuICAgICAgICAgICAgaWYgKG1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplUHJvcGVydGllcyhjdXJyZW50TmFtZXNwYWNlLCBtZW1iZXJzLCBuYW1lIHx8IFwiPEFOT05ZTU9VUz5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TmFtZXNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lKG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuTmFtZXNwYWNlLmRlZmluZVwiPlxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuTmFtZXNwYWNlLmRlZmluZVwiPlxuICAgICAgICAgICAgLy8vIERlZmluZXMgYSBuZXcgbmFtZXNwYWNlIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5hbWVcIiB0eXBlPVwiU3RyaW5nXCIgbG9jaWQ9XCJXaW5KUy5OYW1lc3BhY2UuZGVmaW5lX3A6bmFtZVwiPlxuICAgICAgICAgICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBuYW1lc3BhY2UuIFRoaXMgY291bGQgYmUgYSBkb3Qtc2VwYXJhdGVkIG5hbWUgZm9yIG5lc3RlZCBuYW1lc3BhY2VzLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtZW1iZXJzXCIgdHlwZT1cIk9iamVjdFwiIGxvY2lkPVwiV2luSlMuTmFtZXNwYWNlLmRlZmluZV9wOm1lbWJlcnNcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgbWVtYmVycyBvZiB0aGUgbmV3IG5hbWVzcGFjZS5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJPYmplY3RcIiBsb2NpZD1cIldpbkpTLk5hbWVzcGFjZS5kZWZpbmVfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgbmV3bHktZGVmaW5lZCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgcmV0dXJuIGRlZmluZVdpdGhQYXJlbnQoX0dsb2JhbCwgbmFtZSwgbWVtYmVycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgTGF6eVN0YXRlcyA9IHtcbiAgICAgICAgICAgIHVuaW5pdGlhbGl6ZWQ6IDEsXG4gICAgICAgICAgICB3b3JraW5nOiAyLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IDMsXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbGF6eShmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IExhenlTdGF0ZXMudW5pbml0aWFsaXplZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMYXp5U3RhdGVzLmluaXRpYWxpemVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTGF6eVN0YXRlcy51bmluaXRpYWxpemVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gTGF6eVN0YXRlcy53b3JraW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9Xcml0ZVByb2ZpbGVyTWFyayhcIldpbkpTLk5hbWVzcGFjZS5fbGF6eTpcIiArIG5hbWUgKyBcIixTdGFydFRNXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX1dyaXRlUHJvZmlsZXJNYXJrKFwiV2luSlMuTmFtZXNwYWNlLl9sYXp5OlwiICsgbmFtZSArIFwiLFN0b3BUTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBMYXp5U3RhdGVzLnVuaW5pdGlhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gTGF6eVN0YXRlcy5pbml0aWFsaXplZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIExhenlTdGF0ZXMud29ya2luZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIklsbGVnYWw6IHJlZW50cmFuY3kgb24gaW5pdGlhbGl6YXRpb25cIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIklsbGVnYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMYXp5U3RhdGVzLndvcmtpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJJbGxlZ2FsOiByZWVudHJhbmN5IG9uIGluaXRpYWxpemF0aW9uXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBMYXp5U3RhdGVzLmluaXRpYWxpemVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWxwZXIgZm9yIGRlZmluaW5nIEFNRCBtb2R1bGUgbWVtYmVyc1xuICAgICAgICBmdW5jdGlvbiBtb2R1bGVEZWZpbmUoZXhwb3J0cywgbmFtZSwgbWVtYmVycykge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IFtleHBvcnRzXTtcbiAgICAgICAgICAgIHZhciBwdWJsaWNOUyA9IG51bGw7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHB1YmxpY05TID0gY3JlYXRlTmFtZXNwYWNlKF9HbG9iYWwsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKHB1YmxpY05TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRpYWxpemVQcm9wZXJ0aWVzKHRhcmdldCwgbWVtYmVycywgbmFtZSB8fCBcIjxBTk9OWU1PVVM+XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY05TO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXN0YWJsaXNoIG1lbWJlcnMgb2YgdGhlIFwiV2luSlMuTmFtZXNwYWNlXCIgbmFtZXNwYWNlXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9yb290TmFtZXNwYWNlLk5hbWVzcGFjZSwge1xuXG4gICAgICAgICAgICBkZWZpbmVXaXRoUGFyZW50OiB7IHZhbHVlOiBkZWZpbmVXaXRoUGFyZW50LCB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG5cbiAgICAgICAgICAgIGRlZmluZTogeyB2YWx1ZTogZGVmaW5lLCB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG5cbiAgICAgICAgICAgIF9sYXp5OiB7IHZhbHVlOiBsYXp5LCB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG5cbiAgICAgICAgICAgIF9tb2R1bGVEZWZpbmU6IHsgdmFsdWU6IG1vZHVsZURlZmluZSwgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG5cbiAgICAgICAgfSk7XG5cbiAgICB9KSgpO1xuXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBmdW5jdGlvbiBkZWZpbmUoY29uc3RydWN0b3IsIGluc3RhbmNlTWVtYmVycywgc3RhdGljTWVtYmVycykge1xuICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5DbGFzcy5kZWZpbmVcIj5cbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLkNsYXNzLmRlZmluZVwiPlxuICAgICAgICAgICAgLy8vIERlZmluZXMgYSBjbGFzcyB1c2luZyB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgYW5kIHRoZSBzcGVjaWZpZWQgaW5zdGFuY2UgbWVtYmVycy5cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb25zdHJ1Y3RvclwiIHR5cGU9XCJGdW5jdGlvblwiIGxvY2lkPVwiV2luSlMuQ2xhc3MuZGVmaW5lX3A6Y29uc3RydWN0b3JcIj5cbiAgICAgICAgICAgIC8vLyBBIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnN0YW5jZU1lbWJlcnNcIiB0eXBlPVwiT2JqZWN0XCIgbG9jaWQ9XCJXaW5KUy5DbGFzcy5kZWZpbmVfcDppbnN0YW5jZU1lbWJlcnNcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgc2V0IG9mIGluc3RhbmNlIGZpZWxkcywgcHJvcGVydGllcywgYW5kIG1ldGhvZHMgbWFkZSBhdmFpbGFibGUgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdGF0aWNNZW1iZXJzXCIgdHlwZT1cIk9iamVjdFwiIGxvY2lkPVwiV2luSlMuQ2xhc3MuZGVmaW5lX3A6c3RhdGljTWVtYmVyc1wiPlxuICAgICAgICAgICAgLy8vIFRoZSBzZXQgb2Ygc3RhdGljIGZpZWxkcywgcHJvcGVydGllcywgYW5kIG1ldGhvZHMgbWFkZSBhdmFpbGFibGUgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIkZ1bmN0aW9uXCIgbG9jaWQ9XCJXaW5KUy5DbGFzcy5kZWZpbmVfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgbmV3bHktZGVmaW5lZCBjbGFzcy5cbiAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yIHx8IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIF9CYXNlQ29yZVV0aWxzLm1hcmtTdXBwb3J0ZWRGb3JQcm9jZXNzaW5nKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZU1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplUHJvcGVydGllcyhjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGluc3RhbmNlTWVtYmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGljTWVtYmVycykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVQcm9wZXJ0aWVzKGNvbnN0cnVjdG9yLCBzdGF0aWNNZW1iZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlcml2ZShiYXNlQ2xhc3MsIGNvbnN0cnVjdG9yLCBpbnN0YW5jZU1lbWJlcnMsIHN0YXRpY01lbWJlcnMpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuQ2xhc3MuZGVyaXZlXCI+XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5DbGFzcy5kZXJpdmVcIj5cbiAgICAgICAgICAgIC8vLyBDcmVhdGVzIGEgc3ViLWNsYXNzIGJhc2VkIG9uIHRoZSBzdXBwbGllZCBiYXNlQ2xhc3MgcGFyYW1ldGVyLCB1c2luZyBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJhc2VDbGFzc1wiIHR5cGU9XCJGdW5jdGlvblwiIGxvY2lkPVwiV2luSlMuQ2xhc3MuZGVyaXZlX3A6YmFzZUNsYXNzXCI+XG4gICAgICAgICAgICAvLy8gVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbS5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29uc3RydWN0b3JcIiB0eXBlPVwiRnVuY3Rpb25cIiBsb2NpZD1cIldpbkpTLkNsYXNzLmRlcml2ZV9wOmNvbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICAvLy8gQSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5zdGFuY2VNZW1iZXJzXCIgdHlwZT1cIk9iamVjdFwiIGxvY2lkPVwiV2luSlMuQ2xhc3MuZGVyaXZlX3A6aW5zdGFuY2VNZW1iZXJzXCI+XG4gICAgICAgICAgICAvLy8gVGhlIHNldCBvZiBpbnN0YW5jZSBmaWVsZHMsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIHRvIGJlIG1hZGUgYXZhaWxhYmxlIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RhdGljTWVtYmVyc1wiIHR5cGU9XCJPYmplY3RcIiBsb2NpZD1cIldpbkpTLkNsYXNzLmRlcml2ZV9wOnN0YXRpY01lbWJlcnNcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgc2V0IG9mIHN0YXRpYyBmaWVsZHMsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIHRvIGJlIG1hZGUgYXZhaWxhYmxlIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJGdW5jdGlvblwiIGxvY2lkPVwiV2luSlMuQ2xhc3MuZGVyaXZlX3JldHVyblZhbHVlXCI+XG4gICAgICAgICAgICAvLy8gVGhlIG5ld2x5LWRlZmluZWQgY2xhc3MuXG4gICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgaWYgKGJhc2VDbGFzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3IgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgICAgIHZhciBiYXNlUHJvdG90eXBlID0gYmFzZUNsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIF9CYXNlQ29yZVV0aWxzLm1hcmtTdXBwb3J0ZWRGb3JQcm9jZXNzaW5nKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IGNvbnN0cnVjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZU1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZVByb3BlcnRpZXMoY29uc3RydWN0b3IucHJvdG90eXBlLCBpbnN0YW5jZU1lbWJlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplUHJvcGVydGllcyhjb25zdHJ1Y3Rvciwgc3RhdGljTWVtYmVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZShjb25zdHJ1Y3RvciwgaW5zdGFuY2VNZW1iZXJzLCBzdGF0aWNNZW1iZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1peChjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5DbGFzcy5taXhcIj5cbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLkNsYXNzLm1peFwiPlxuICAgICAgICAgICAgLy8vIERlZmluZXMgYSBjbGFzcyB1c2luZyB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgYW5kIHRoZSB1bmlvbiBvZiB0aGUgc2V0IG9mIGluc3RhbmNlIG1lbWJlcnNcbiAgICAgICAgICAgIC8vLyBzcGVjaWZpZWQgYnkgYWxsIHRoZSBtaXhpbiBvYmplY3RzLiBUaGUgbWl4aW4gcGFyYW1ldGVyIGxpc3QgaXMgb2YgdmFyaWFibGUgbGVuZ3RoLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnN0cnVjdG9yXCIgbG9jaWQ9XCJXaW5KUy5DbGFzcy5taXhfcDpjb25zdHJ1Y3RvclwiPlxuICAgICAgICAgICAgLy8vIEEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiRnVuY3Rpb25cIiBsb2NpZD1cIldpbkpTLkNsYXNzLm1peF9yZXR1cm5WYWx1ZVwiPlxuICAgICAgICAgICAgLy8vIFRoZSBuZXdseS1kZWZpbmVkIGNsYXNzLlxuICAgICAgICAgICAgLy8vIDwvcmV0dXJucz5cbiAgICAgICAgICAgIC8vLyA8L3NpZ25hdHVyZT5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3IgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgdmFyIGksIGxlbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVQcm9wZXJ0aWVzKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVzdGFibGlzaCBtZW1iZXJzIG9mIFwiV2luSlMuQ2xhc3NcIiBuYW1lc3BhY2VcbiAgICAgICAgX1dpbkpTLk5hbWVzcGFjZS5kZWZpbmUoXCJXaW5KUy5DbGFzc1wiLCB7XG4gICAgICAgICAgICBkZWZpbmU6IGRlZmluZSxcbiAgICAgICAgICAgIGRlcml2ZTogZGVyaXZlLFxuICAgICAgICAgICAgbWl4OiBtaXhcbiAgICAgICAgfSk7XG5cbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgTmFtZXNwYWNlOiBfV2luSlMuTmFtZXNwYWNlLFxuICAgICAgICBDbGFzczogX1dpbkpTLkNsYXNzXG4gICAgfTtcblxufSk7XG5fd2luanMoXCJXaW5KUy9Db3JlL19FcnJvckZyb21OYW1lXCIsIFtcIldpbkpTL0NvcmUvX0Jhc2VcIl0sIGZ1bmN0aW9uIGVycm9yc0luaXQoX0Jhc2UpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBFcnJvckZyb21OYW1lID0gX0Jhc2UuQ2xhc3MuZGVyaXZlKEVycm9yLCBmdW5jdGlvbiAobmFtZSwgbWVzc2FnZSkge1xuICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLkVycm9yRnJvbU5hbWVcIj5cbiAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuRXJyb3JGcm9tTmFtZVwiPlxuICAgICAgICAvLy8gQ3JlYXRlcyBhbiBFcnJvciBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgYW5kIG1lc3NhZ2UgcHJvcGVydGllcy5cbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibmFtZVwiIHR5cGU9XCJTdHJpbmdcIiBsb2NpZD1cIldpbkpTLkVycm9yRnJvbU5hbWVfcDpuYW1lXCI+VGhlIG5hbWUgb2YgdGhpcyBlcnJvci4gVGhlIG5hbWUgaXMgbWVhbnQgdG8gYmUgY29uc3VtZWQgcHJvZ3JhbW1hdGljYWxseSBhbmQgc2hvdWxkIG5vdCBiZSBsb2NhbGl6ZWQuPC9wYXJhbT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWVzc2FnZVwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIiBsb2NpZD1cIldpbkpTLkVycm9yRnJvbU5hbWVfcDptZXNzYWdlXCI+VGhlIG1lc3NhZ2UgZm9yIHRoaXMgZXJyb3IuIFRoZSBtZXNzYWdlIGlzIG1lYW50IHRvIGJlIGNvbnN1bWVkIGJ5IGh1bWFucyBhbmQgc2hvdWxkIGJlIGxvY2FsaXplZC48L3BhcmFtPlxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIkVycm9yXCIgbG9jaWQ9XCJXaW5KUy5FcnJvckZyb21OYW1lX3JldHVyblZhbHVlXCI+RXJyb3IgaW5zdGFuY2Ugd2l0aCAubmFtZSBhbmQgLm1lc3NhZ2UgcHJvcGVydGllcyBwb3B1bGF0ZWQ8L3JldHVybnM+XG4gICAgICAgIC8vLyA8L3NpZ25hdHVyZT5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBuYW1lO1xuICAgIH0sIHtcbiAgICAgICAgLyogZW1wdHkgKi9cbiAgICB9LCB7XG4gICAgICAgIHN1cHBvcnRlZEZvclByb2Nlc3Npbmc6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgX0Jhc2UuTmFtZXNwYWNlLmRlZmluZShcIldpbkpTXCIsIHtcbiAgICAgICAgLy8gRXJyb3JGcm9tTmFtZSBlc3RhYmxpc2hlcyBhIHNpbXBsZSBwYXR0ZXJuIGZvciByZXR1cm5pbmcgZXJyb3IgY29kZXMuXG4gICAgICAgIC8vXG4gICAgICAgIEVycm9yRnJvbU5hbWU6IEVycm9yRnJvbU5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiBFcnJvckZyb21OYW1lO1xuXG59KTtcblxuXG5fd2luanMoXCJXaW5KUy9Db3JlL19FdmVudHNcIiwgW1wiZXhwb3J0c1wiLFwiV2luSlMvQ29yZS9fQmFzZVwiXSwgZnVuY3Rpb24gZXZlbnRzSW5pdChleHBvcnRzLCBfQmFzZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudFByb3BlcnR5KG5hbWUpIHtcbiAgICAgICAgdmFyIGV2ZW50UHJvcFN0YXRlTmFtZSA9IFwiX29uXCIgKyBuYW1lICsgXCJzdGF0ZVwiO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW2V2ZW50UHJvcFN0YXRlTmFtZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnVzZXJIYW5kbGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW2V2ZW50UHJvcFN0YXRlTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHdyYXBwZXI6IGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIHN0YXRlLnVzZXJIYW5kbGVyKGV2dCk7IH0sIHVzZXJIYW5kbGVyOiBoYW5kbGVyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZXZlbnRQcm9wU3RhdGVOYW1lLCB7IHZhbHVlOiBzdGF0ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOnRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBzdGF0ZS53cmFwcGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudXNlckhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHN0YXRlLndyYXBwZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tldmVudFByb3BTdGF0ZU5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5VdGlsaXRpZXMuY3JlYXRlRXZlbnRQcm9wZXJ0aWVzXCI+XG4gICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlV0aWxpdGllcy5jcmVhdGVFdmVudFByb3BlcnRpZXNcIj5cbiAgICAgICAgLy8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaGFzIG9uZSBwcm9wZXJ0eSBmb3IgZWFjaCBuYW1lIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImV2ZW50c1wiIGxvY2lkPVwiV2luSlMuVXRpbGl0aWVzLmNyZWF0ZUV2ZW50UHJvcGVydGllc19wOmV2ZW50c1wiPlxuICAgICAgICAvLy8gQSB2YXJpYWJsZSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJPYmplY3RcIiBsb2NpZD1cIldpbkpTLlV0aWxpdGllcy5jcmVhdGVFdmVudFByb3BlcnRpZXNfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgLy8vIFRoZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuIFRoZSBuYW1lcyBvZiB0aGUgcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCAnb24nLlxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHByb3BzW1wib25cIiArIG5hbWVdID0gY3JlYXRlRXZlbnRQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIEV2ZW50TWl4aW5FdmVudCA9IF9CYXNlLkNsYXNzLmRlZmluZShcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRNaXhpbkV2ZW50X2N0b3IodHlwZSwgZGV0YWlsLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBidWJibGVzOiB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRhcmdldDsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByZXZlbnREZWZhdWx0Q2FsbGVkOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1c3RlZDogeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgICAgICAgZXZlbnRQaGFzZTogeyB2YWx1ZTogMCwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICB0aW1lU3RhbXA6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBudWxsLFxuXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25DYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRGb3JQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgZXZlbnRNaXhpbiA9IHtcbiAgICAgICAgX2xpc3RlbmVyczogbnVsbCxcblxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4uYWRkRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4uYWRkRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgLy8vIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHlwZVwiIGxvY2lkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4uYWRkRXZlbnRMaXN0ZW5lcl9wOnR5cGVcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgdHlwZSAobmFtZSkgb2YgdGhlIGV2ZW50LlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsaXN0ZW5lclwiIGxvY2lkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4uYWRkRXZlbnRMaXN0ZW5lcl9wOmxpc3RlbmVyXCI+XG4gICAgICAgICAgICAvLy8gVGhlIGxpc3RlbmVyIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBpcyByYWlzZWQuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInVzZUNhcHR1cmVcIiBsb2NpZD1cIldpbkpTLlV0aWxpdGllcy5ldmVudE1peGluLmFkZEV2ZW50TGlzdGVuZXJfcDp1c2VDYXB0dXJlXCI+XG4gICAgICAgICAgICAvLy8gaWYgdHJ1ZSBpbml0aWF0ZXMgY2FwdHVyZSwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICB1c2VDYXB0dXJlID0gdXNlQ2FwdHVyZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBldmVudExpc3RlbmVycyA9ICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgW10pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBldmVudExpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobC51c2VDYXB0dXJlID09PSB1c2VDYXB0dXJlICYmIGwubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXI6IGxpc3RlbmVyLCB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZGV0YWlscykge1xuICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5VdGlsaXRpZXMuZXZlbnRNaXhpbi5kaXNwYXRjaEV2ZW50XCI+XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5VdGlsaXRpZXMuZXZlbnRNaXhpbi5kaXNwYXRjaEV2ZW50XCI+XG4gICAgICAgICAgICAvLy8gUmFpc2VzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBhbmQgd2l0aCB0aGUgc3BlY2lmaWVkIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0eXBlXCIgbG9jaWQ9XCJXaW5KUy5VdGlsaXRpZXMuZXZlbnRNaXhpbi5kaXNwYXRjaEV2ZW50X3A6dHlwZVwiPlxuICAgICAgICAgICAgLy8vIFRoZSB0eXBlIChuYW1lKSBvZiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRldGFpbHNcIiBsb2NpZD1cIldpbkpTLlV0aWxpdGllcy5ldmVudE1peGluLmRpc3BhdGNoRXZlbnRfcDpkZXRhaWxzXCI+XG4gICAgICAgICAgICAvLy8gVGhlIHNldCBvZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGV2ZW50IG9iamVjdCB3aGVuIHRoZSBldmVudCBpcyByYWlzZWQuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiQm9vbGVhblwiIGxvY2lkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4uZGlzcGF0Y2hFdmVudF9yZXR1cm5WYWx1ZVwiPlxuICAgICAgICAgICAgLy8vIHRydWUgaWYgcHJldmVudERlZmF1bHQgd2FzIGNhbGxlZCBvbiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VmFsdWUgPSBuZXcgRXZlbnRNaXhpbkV2ZW50KHR5cGUsIGRldGFpbHMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY29weSB0aGUgYXJyYXkgdG8gcHJvdGVjdCBhZ2FpbnN0IHBlb3BsZSB1bnJlZ2lzdGVyaW5nIHdoaWxlIHdlIGFyZSBkaXNwYXRjaGluZ1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgwLCBsaXN0ZW5lcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZXZlbnRWYWx1ZS5fc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uQ2FsbGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmxpc3RlbmVyKGV2ZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRWYWx1ZS5kZWZhdWx0UHJldmVudGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuVXRpbGl0aWVzLmV2ZW50TWl4aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgLy8vIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgY29udHJvbC5cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0eXBlXCIgbG9jaWQ9XCJXaW5KUy5VdGlsaXRpZXMuZXZlbnRNaXhpbi5yZW1vdmVFdmVudExpc3RlbmVyX3A6dHlwZVwiPlxuICAgICAgICAgICAgLy8vIFRoZSB0eXBlIChuYW1lKSBvZiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxpc3RlbmVyXCIgbG9jaWQ9XCJXaW5KUy5VdGlsaXRpZXMuZXZlbnRNaXhpbi5yZW1vdmVFdmVudExpc3RlbmVyX3A6bGlzdGVuZXJcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ1c2VDYXB0dXJlXCIgbG9jaWQ9XCJXaW5KUy5VdGlsaXRpZXMuZXZlbnRNaXhpbi5yZW1vdmVFdmVudExpc3RlbmVyX3A6dXNlQ2FwdHVyZVwiPlxuICAgICAgICAgICAgLy8vIFNwZWNpZmllcyB3aGV0aGVyIHRvIGluaXRpYXRlIGNhcHR1cmUuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8L3NpZ25hdHVyZT5cbiAgICAgICAgICAgIHVzZUNhcHR1cmUgPSB1c2VDYXB0dXJlIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGwudXNlQ2FwdHVyZSA9PT0gdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgd2FudCB0byByZW1vdmUgb25lIGVsZW1lbnQgZm9yIGVhY2ggY2FsbCB0byByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfQmFzZS5OYW1lc3BhY2UuX21vZHVsZURlZmluZShleHBvcnRzLCBcIldpbkpTLlV0aWxpdGllc1wiLCB7XG4gICAgICAgIF9jcmVhdGVFdmVudFByb3BlcnR5OiBjcmVhdGVFdmVudFByb3BlcnR5LFxuICAgICAgICBjcmVhdGVFdmVudFByb3BlcnRpZXM6IGNyZWF0ZUV2ZW50UHJvcGVydGllcyxcbiAgICAgICAgZXZlbnRNaXhpbjogZXZlbnRNaXhpblxuICAgIH0pO1xuXG59KTtcblxuXG5fd2luanMoXCJXaW5KUy9Db3JlL19UcmFjZVwiLCBbXCJXaW5KUy9Db3JlL19HbG9iYWxcIl0sIGZ1bmN0aW9uIHRyYWNlSW5pdChfR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBub3Aodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBfdHJhY2VBc3luY09wZXJhdGlvblN0YXJ0aW5nOiAoX0dsb2JhbC5EZWJ1ZyAmJiBfR2xvYmFsLkRlYnVnLm1zVHJhY2VBc3luY09wZXJhdGlvblN0YXJ0aW5nICYmIF9HbG9iYWwuRGVidWcubXNUcmFjZUFzeW5jT3BlcmF0aW9uU3RhcnRpbmcuYmluZChfR2xvYmFsLkRlYnVnKSkgfHwgbm9wLFxuICAgICAgICBfdHJhY2VBc3luY09wZXJhdGlvbkNvbXBsZXRlZDogKF9HbG9iYWwuRGVidWcgJiYgX0dsb2JhbC5EZWJ1Zy5tc1RyYWNlQXN5bmNPcGVyYXRpb25Db21wbGV0ZWQgJiYgX0dsb2JhbC5EZWJ1Zy5tc1RyYWNlQXN5bmNPcGVyYXRpb25Db21wbGV0ZWQuYmluZChfR2xvYmFsLkRlYnVnKSkgfHwgbm9wLFxuICAgICAgICBfdHJhY2VBc3luY0NhbGxiYWNrU3RhcnRpbmc6IChfR2xvYmFsLkRlYnVnICYmIF9HbG9iYWwuRGVidWcubXNUcmFjZUFzeW5jQ2FsbGJhY2tTdGFydGluZyAmJiBfR2xvYmFsLkRlYnVnLm1zVHJhY2VBc3luY0NhbGxiYWNrU3RhcnRpbmcuYmluZChfR2xvYmFsLkRlYnVnKSkgfHwgbm9wLFxuICAgICAgICBfdHJhY2VBc3luY0NhbGxiYWNrQ29tcGxldGVkOiAoX0dsb2JhbC5EZWJ1ZyAmJiBfR2xvYmFsLkRlYnVnLm1zVHJhY2VBc3luY0NhbGxiYWNrQ29tcGxldGVkICYmIF9HbG9iYWwuRGVidWcubXNUcmFjZUFzeW5jQ2FsbGJhY2tDb21wbGV0ZWQuYmluZChfR2xvYmFsLkRlYnVnKSkgfHwgbm9wXG4gICAgfTtcbn0pO1xuX3dpbmpzKFwiV2luSlMvUHJvbWlzZS9fU3RhdGVNYWNoaW5lXCIsIFtcIldpbkpTL0NvcmUvX0dsb2JhbFwiLFwiV2luSlMvQ29yZS9fQmFzZUNvcmVVdGlsc1wiLFwiV2luSlMvQ29yZS9fQmFzZVwiLFwiV2luSlMvQ29yZS9fRXJyb3JGcm9tTmFtZVwiLFwiV2luSlMvQ29yZS9fRXZlbnRzXCIsXCJXaW5KUy9Db3JlL19UcmFjZVwiXSwgZnVuY3Rpb24gcHJvbWlzZVN0YXRlTWFjaGluZUluaXQoX0dsb2JhbCwgX0Jhc2VDb3JlVXRpbHMsIF9CYXNlLCBfRXJyb3JGcm9tTmFtZSwgX0V2ZW50cywgX1RyYWNlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBfR2xvYmFsLkRlYnVnICYmIChfR2xvYmFsLkRlYnVnLnNldE5vblVzZXJDb2RlRXhjZXB0aW9ucyA9IHRydWUpO1xuXG4gICAgdmFyIExpc3RlbmVyVHlwZSA9IF9CYXNlLkNsYXNzLm1peChfQmFzZS5DbGFzcy5kZWZpbmUobnVsbCwgeyAvKmVtcHR5Ki8gfSwgeyBzdXBwb3J0ZWRGb3JQcm9jZXNzaW5nOiBmYWxzZSB9KSwgX0V2ZW50cy5ldmVudE1peGluKTtcbiAgICB2YXIgcHJvbWlzZUV2ZW50TGlzdGVuZXJzID0gbmV3IExpc3RlbmVyVHlwZSgpO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIGxpc3RlbmVycyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGRvIGEgbW9yZSB0cml2aWFsIGNoZWNrIGJlbG93XG4gICAgcHJvbWlzZUV2ZW50TGlzdGVuZXJzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB2YXIgZXJyb3JFVCA9IFwiZXJyb3JcIjtcbiAgICB2YXIgY2FuY2VsZWROYW1lID0gXCJDYW5jZWxlZFwiO1xuICAgIHZhciB0YWdXaXRoU3RhY2sgPSBmYWxzZTtcbiAgICB2YXIgdGFnID0ge1xuICAgICAgICBwcm9taXNlOiAweDAxLFxuICAgICAgICB0aGVuUHJvbWlzZTogMHgwMixcbiAgICAgICAgZXJyb3JQcm9taXNlOiAweDA0LFxuICAgICAgICBleGNlcHRpb25Qcm9taXNlOiAweDA4LFxuICAgICAgICBjb21wbGV0ZVByb21pc2U6IDB4MTAsXG4gICAgfTtcbiAgICB0YWcuYWxsID0gdGFnLnByb21pc2UgfCB0YWcudGhlblByb21pc2UgfCB0YWcuZXJyb3JQcm9taXNlIHwgdGFnLmV4Y2VwdGlvblByb21pc2UgfCB0YWcuY29tcGxldGVQcm9taXNlO1xuXG4gICAgLy9cbiAgICAvLyBHbG9iYWwgZXJyb3IgY291bnRlciwgZm9yIGVhY2ggZXJyb3Igd2hpY2ggZW50ZXJzIHRoZSBzeXN0ZW0gd2UgaW5jcmVtZW50IHRoaXMgb25jZSBhbmQgdGhlblxuICAgIC8vIHRoZSBlcnJvciBudW1iZXIgdHJhdmVscyB3aXRoIHRoZSBlcnJvciBhcyBpdCB0cmF2ZXJzZXMgdGhlIHRyZWUgb2YgcG90ZW50aWFsIGhhbmRsZXJzLlxuICAgIC8vXG4gICAgLy8gV2hlbiBzb21lb25lIGhhcyByZWdpc3RlcmVkIHRvIGJlIHRvbGQgYWJvdXQgZXJyb3JzIChXaW5KUy5Qcm9taXNlLmNhbGxvbmVycm9yKSBwcm9taXNlc1xuICAgIC8vIHdoaWNoIGFyZSBpbiBlcnJvciB3aWxsIGdldCB0YWdnZWQgd2l0aCBhIC5fZXJyb3JJZCBmaWVsZC4gVGhpcyB0YWdnZWQgZmllbGQgaXMgdGhlXG4gICAgLy8gY29udHJhY3QgYnkgd2hpY2ggbmVzdGVkIHByb21pc2VzIHdpdGggZXJyb3JzIHdpbGwgYmUgaWRlbnRpZmllZCBhcyBjaGFpbmluZyBmb3IgdGhlXG4gICAgLy8gcHVycG9zZXMgb2YgdGhlIGNhbGxvbmVycm9yIHNlbWFudGljcy4gSWYgYSBuZXN0ZWQgcHJvbWlzZSBpbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB3aXRob3V0XG4gICAgLy8gYSAuX2Vycm9ySWQgaXQgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIGZvcmVpZ24gYW5kIHRyZWF0ZWQgYXMgYW4gaW50ZXJvcCBib3VuZGFyeSBhbmRcbiAgICAvLyBhIG5ldyBlcnJvciBpZCB3aWxsIGJlIG1pbnRlZC5cbiAgICAvL1xuICAgIHZhciBlcnJvcl9udW1iZXIgPSAxO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgc3RhdGUgbWFjaGluZSBoYXMgYSBpbnRlcmVzdGluZyBoaWNjdXAgaW4gaXQgd2l0aCByZWdhcmRzIHRvIG5vdGlmaWNhdGlvbiwgaW4gb3JkZXJcbiAgICAvLyB0byBmbGF0dGVuIG91dCBub3RpZmljYXRpb24gYW5kIGF2b2lkIHJlY3Vyc2lvbiBmb3Igc3luY2hyb25vdXMgY29tcGxldGlvbiB3ZSBoYXZlIGFuXG4gICAgLy8gZXhwbGljaXQgc2V0IG9mICpfbm90aWZ5IHN0YXRlcyB3aGljaCBhcmUgcmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyB0aGVpciBlbnRpcmUgdHJlZVxuICAgIC8vIG9mIGNoaWxkcmVuLiBUaGV5IGNhbiBkbyB0aGlzIGJlY2F1c2UgdGhleSBrbm93IHRoYXQgaW1tZWRpYXRlIGNoaWxkcmVuIGFyZSBhbHdheXNcbiAgICAvLyBUaGVuUHJvbWlzZSBpbnN0YW5jZXMgYW5kIHdlIGNhbiB0aGVyZWZvcmUgcmVhY2ggaW50byB0aGVpciBzdGF0ZSB0byBhY2Nlc3MgdGhlXG4gICAgLy8gX2xpc3RlbmVycyBjb2xsZWN0aW9uLlxuICAgIC8vXG4gICAgLy8gU28sIHdoYXQgaGFwcGVucyBpcyB0aGF0IGEgUHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCB0aHJvdWdoIHRoZSBfY29tcGxldGVkIG9yIF9lcnJvclxuICAgIC8vIG1lc3NhZ2VzIGF0IHdoaWNoIHBvaW50IGl0IHdpbGwgZW50ZXIgYSAqX25vdGlmeSBzdGF0ZSBhbmQgYmUgcmVzcG9uc2libGUgZm9yIHRvIG1vdmVcbiAgICAvLyBpdHMgY2hpbGRyZW4gaW50byBhbiAoYXMgYXBwcm9wcmlhdGUpIHN1Y2Nlc3Mgb3IgZXJyb3Igc3RhdGUgYW5kIGFsc28gbm90aWZ5IHRoYXQgY2hpbGQnc1xuICAgIC8vIGxpc3RlbmVycyBvZiB0aGUgc3RhdGUgdHJhbnNpdGlvbiwgdW50aWwgbGVhZiBub3RlcyBhcmUgcmVhY2hlZC5cbiAgICAvL1xuXG4gICAgdmFyIHN0YXRlX2NyZWF0ZWQsICAgICAgICAgICAgICAvLyAtPiB3b3JraW5nXG4gICAgICAgIHN0YXRlX3dvcmtpbmcsICAgICAgICAgICAgICAvLyAtPiBlcnJvciB8IGVycm9yX25vdGlmeSB8IHN1Y2Nlc3MgfCBzdWNjZXNzX25vdGlmeSB8IGNhbmNlbGVkIHwgd2FpdGluZ1xuICAgICAgICBzdGF0ZV93YWl0aW5nLCAgICAgICAgICAgICAgLy8gLT4gZXJyb3IgfCBlcnJvcl9ub3RpZnkgfCBzdWNjZXNzIHwgc3VjY2Vzc19ub3RpZnkgfCB3YWl0aW5nX2NhbmNlbGVkXG4gICAgICAgIHN0YXRlX3dhaXRpbmdfY2FuY2VsZWQsICAgICAvLyAtPiBlcnJvciB8IGVycm9yX25vdGlmeSB8IHN1Y2Nlc3MgfCBzdWNjZXNzX25vdGlmeSB8IGNhbmNlbGluZ1xuICAgICAgICBzdGF0ZV9jYW5jZWxlZCwgICAgICAgICAgICAgLy8gLT4gZXJyb3IgfCBlcnJvcl9ub3RpZnkgfCBzdWNjZXNzIHwgc3VjY2Vzc19ub3RpZnkgfCBjYW5jZWxpbmdcbiAgICAgICAgc3RhdGVfY2FuY2VsaW5nLCAgICAgICAgICAgIC8vIC0+IGVycm9yX25vdGlmeVxuICAgICAgICBzdGF0ZV9zdWNjZXNzX25vdGlmeSwgICAgICAgLy8gLT4gc3VjY2Vzc1xuICAgICAgICBzdGF0ZV9zdWNjZXNzLCAgICAgICAgICAgICAgLy8gLT4gLlxuICAgICAgICBzdGF0ZV9lcnJvcl9ub3RpZnksICAgICAgICAgLy8gLT4gZXJyb3JcbiAgICAgICAgc3RhdGVfZXJyb3I7ICAgICAgICAgICAgICAgIC8vIC0+IC5cblxuICAgIC8vIE5vb3AgZnVuY3Rpb24sIHVzZWQgaW4gdGhlIHZhcmlvdXMgc3RhdGVzIHRvIGluZGljYXRlIHRoYXQgdGhleSBkb24ndCBzdXBwb3J0IGEgZ2l2ZW5cbiAgICAvLyBtZXNzYWdlLiBOYW1lZCB3aXRoIHRoZSBzb21ld2hhdCBjdXRlIG5hbWUgJ18nIGJlY2F1c2UgaXQgcmVhZHMgcmVhbGx5IHdlbGwgaW4gdGhlIHN0YXRlcy5cblxuICAgIGZ1bmN0aW9uIF8oKSB7IH1cblxuICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAvL1xuICAgIHN0YXRlX2NyZWF0ZWQgPSB7XG4gICAgICAgIG5hbWU6IFwiY3JlYXRlZFwiLFxuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFN0YXRlKHN0YXRlX3dvcmtpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IF8sXG4gICAgICAgIGRvbmU6IF8sXG4gICAgICAgIHRoZW46IF8sXG4gICAgICAgIF9jb21wbGV0ZWQ6IF8sXG4gICAgICAgIF9lcnJvcjogXyxcbiAgICAgICAgX25vdGlmeTogXyxcbiAgICAgICAgX3Byb2dyZXNzOiBfLFxuICAgICAgICBfc2V0Q29tcGxldGVWYWx1ZTogXyxcbiAgICAgICAgX3NldEVycm9yVmFsdWU6IF9cbiAgICB9O1xuXG4gICAgLy8gUmVhZHkgc3RhdGUsIHdhaXRpbmcgZm9yIGEgbWVzc2FnZSAoY29tcGxldGVkL2Vycm9yL3Byb2dyZXNzKSwgYWJsZSB0byBiZSBjYW5jZWxlZFxuICAgIC8vXG4gICAgc3RhdGVfd29ya2luZyA9IHtcbiAgICAgICAgbmFtZTogXCJ3b3JraW5nXCIsXG4gICAgICAgIGVudGVyOiBfLFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRTdGF0ZShzdGF0ZV9jYW5jZWxlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgIHRoZW46IHRoZW4sXG4gICAgICAgIF9jb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgX2Vycm9yOiBlcnJvcixcbiAgICAgICAgX25vdGlmeTogXyxcbiAgICAgICAgX3Byb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgICAgX3NldENvbXBsZXRlVmFsdWU6IHNldENvbXBsZXRlVmFsdWUsXG4gICAgICAgIF9zZXRFcnJvclZhbHVlOiBzZXRFcnJvclZhbHVlXG4gICAgfTtcblxuICAgIC8vIFdhaXRpbmcgc3RhdGUsIGlmIGEgcHJvbWlzZSBpcyBjb21wbGV0ZWQgd2l0aCBhIHZhbHVlIHdoaWNoIGlzIGl0c2VsZiBhIHByb21pc2VcbiAgICAvLyAoaGFzIGEgdGhlbigpIG1ldGhvZCkgaXQgc2lnbnMgdXAgdG8gYmUgaW5mb3JtZWQgd2hlbiB0aGF0IGNoaWxkIHByb21pc2UgaXNcbiAgICAvLyBmdWxmaWxsZWQgYXQgd2hpY2ggcG9pbnQgaXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGF0IHZhbHVlLlxuICAgIC8vXG4gICAgc3RhdGVfd2FpdGluZyA9IHtcbiAgICAgICAgbmFtZTogXCJ3YWl0aW5nXCIsXG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHdhaXRlZFVwb24gPSBwcm9taXNlLl92YWx1ZTtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBzcGVjaWFsIGNhc2Ugb3VyIG93biBpbnRlcm1lZGlhdGUgcHJvbWlzZXMgd2hpY2ggYXJlIG5vdCBpbiBhXG4gICAgICAgICAgICAvLyAgdGVybWluYWwgc3RhdGUgYnkganVzdCBwdXNoaW5nIHRoaXMgcHJvbWlzZSBhcyBhIGxpc3RlbmVyIHdpdGhvdXRcbiAgICAgICAgICAgIC8vICBoYXZpbmcgdG8gY3JlYXRlIG5ldyBpbmRpcmVjdGlvbiBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmICh3YWl0ZWRVcG9uIGluc3RhbmNlb2YgVGhlblByb21pc2UgJiZcbiAgICAgICAgICAgICAgICB3YWl0ZWRVcG9uLl9zdGF0ZSAhPT0gc3RhdGVfZXJyb3IgJiZcbiAgICAgICAgICAgICAgICB3YWl0ZWRVcG9uLl9zdGF0ZSAhPT0gc3RhdGVfc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHB1c2hMaXN0ZW5lcih3YWl0ZWRVcG9uLCB7IHByb21pc2U6IHByb21pc2UgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2FpdGVkVXBvbi5fZXJyb3JJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fY2hhaW5lZEVycm9yKHZhbHVlLCB3YWl0ZWRVcG9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhpcyBpcyBhbiBpbnRlcm9wIGJvdW5kYXJ5IHdlIHdhbnQgdG8gaW5kaWNhdGUgdGhhdCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgZXJyb3IgaGFzIGJlZW4gaGFuZGxlZCBieSB0aGUgcHJvbWlzZSBpbmZyYXN0cnVjdHVyZSBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBiZWdpbiBhIG5ldyBoYW5kbGluZyBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsb25lcnJvcihwcm9taXNlLCB2YWx1ZSwgZGV0YWlsc0ZvckhhbmRsZWRFcnJvciwgd2FpdGVkVXBvbiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fZXJyb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlcnJvci5oYW5kbGVzT25FcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2FpdGVkVXBvbi50aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9jb21wbGV0ZWQuYmluZChwcm9taXNlKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Byb2dyZXNzLmJpbmQocHJvbWlzZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRTdGF0ZShzdGF0ZV93YWl0aW5nX2NhbmNlbGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgdGhlbjogdGhlbixcbiAgICAgICAgX2NvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICBfZXJyb3I6IGVycm9yLFxuICAgICAgICBfbm90aWZ5OiBfLFxuICAgICAgICBfcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBfc2V0Q29tcGxldGVWYWx1ZTogc2V0Q29tcGxldGVWYWx1ZSxcbiAgICAgICAgX3NldEVycm9yVmFsdWU6IHNldEVycm9yVmFsdWVcbiAgICB9O1xuXG4gICAgLy8gV2FpdGluZyBjYW5jZWxlZCBzdGF0ZSwgd2hlbiBhIHByb21pc2UgaGFzIGJlZW4gaW4gYSB3YWl0aW5nIHN0YXRlIGFuZCByZWNlaXZlcyBhXG4gICAgLy8gcmVxdWVzdCB0byBjYW5jZWwgaXRzIHBlbmRpbmcgd29yayBpdCB3aWxsIGZvcndhcmQgdGhhdCByZXF1ZXN0IHRvIHRoZSBjaGlsZCBwcm9taXNlXG4gICAgLy8gYW5kIHRoZW4gd2FpdHMgdG8gYmUgaW5mb3JtZWQgb2YgdGhlIHJlc3VsdC4gVGhpcyBwcm9taXNlIG1vdmVzIGl0c2VsZiBpbnRvIHRoZVxuICAgIC8vIGNhbmNlbGluZyBzdGF0ZSBidXQgdW5kZXJzdGFuZHMgdGhhdCB0aGUgY2hpbGQgcHJvbWlzZSBtYXkgaW5zdGVhZCBwdXNoIGl0IHRvIGFcbiAgICAvLyBkaWZmZXJlbnQgc3RhdGUuXG4gICAgLy9cbiAgICBzdGF0ZV93YWl0aW5nX2NhbmNlbGVkID0ge1xuICAgICAgICBuYW1lOiBcIndhaXRpbmdfY2FuY2VsZWRcIixcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBJbml0aWF0ZSBhIHRyYW5zaXRpb24gdG8gY2FuY2VsaW5nLiBUcmlnZ2VyaW5nIGEgY2FuY2VsIG9uIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGFyZSB3YWl0aW5nIHVwb24gbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCBzdGF0ZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIHN0YXRlIG1hY2hpbmUgcHVtcCBydW5zIGFnYWluLlxuICAgICAgICAgICAgcHJvbWlzZS5fc2V0U3RhdGUoc3RhdGVfY2FuY2VsaW5nKTtcbiAgICAgICAgICAgIHZhciB3YWl0ZWRVcG9uID0gcHJvbWlzZS5fdmFsdWU7XG4gICAgICAgICAgICBpZiAod2FpdGVkVXBvbi5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICB3YWl0ZWRVcG9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IF8sXG4gICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgIHRoZW46IHRoZW4sXG4gICAgICAgIF9jb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgX2Vycm9yOiBlcnJvcixcbiAgICAgICAgX25vdGlmeTogXyxcbiAgICAgICAgX3Byb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgICAgX3NldENvbXBsZXRlVmFsdWU6IHNldENvbXBsZXRlVmFsdWUsXG4gICAgICAgIF9zZXRFcnJvclZhbHVlOiBzZXRFcnJvclZhbHVlXG4gICAgfTtcblxuICAgIC8vIENhbmNlbGVkIHN0YXRlLCBtb3ZlcyB0byB0aGUgY2FuY2VsaW5nIHN0YXRlIGFuZCB0aGVuIHRlbGxzIHRoZSBwcm9taXNlIHRvIGRvXG4gICAgLy8gd2hhdGV2ZXIgaXQgbWlnaHQgbmVlZCB0byBkbyBvbiBjYW5jZWxhdGlvbi5cbiAgICAvL1xuICAgIHN0YXRlX2NhbmNlbGVkID0ge1xuICAgICAgICBuYW1lOiBcImNhbmNlbGVkXCIsXG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gSW5pdGlhdGUgYSB0cmFuc2l0aW9uIHRvIGNhbmNlbGluZy4gVGhlIF9jYW5jZWxBY3Rpb24gbWF5IGNoYW5nZSB0aGUgc3RhdGVcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgc3RhdGUgbWFjaGluZSBwdW1wIHJ1bnMgYWdhaW4uXG4gICAgICAgICAgICBwcm9taXNlLl9zZXRTdGF0ZShzdGF0ZV9jYW5jZWxpbmcpO1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsQWN0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogXyxcbiAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgdGhlbjogdGhlbixcbiAgICAgICAgX2NvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICBfZXJyb3I6IGVycm9yLFxuICAgICAgICBfbm90aWZ5OiBfLFxuICAgICAgICBfcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBfc2V0Q29tcGxldGVWYWx1ZTogc2V0Q29tcGxldGVWYWx1ZSxcbiAgICAgICAgX3NldEVycm9yVmFsdWU6IHNldEVycm9yVmFsdWVcbiAgICB9O1xuXG4gICAgLy8gQ2FuY2VsaW5nIHN0YXRlLCBjb21taXRzIHRvIHRoZSBwcm9taXNlIG1vdmluZyB0byBhbiBlcnJvciBzdGF0ZSB3aXRoIGFuIGVycm9yXG4gICAgLy8gb2JqZWN0IHdob3NlICduYW1lJyBhbmQgJ21lc3NhZ2UnIHByb3BlcnRpZXMgY29udGFpbiB0aGUgc3RyaW5nIFwiQ2FuY2VsZWRcIlxuICAgIC8vXG4gICAgc3RhdGVfY2FuY2VsaW5nID0ge1xuICAgICAgICBuYW1lOiBcImNhbmNlbGluZ1wiLFxuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihjYW5jZWxlZE5hbWUpO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBwcm9taXNlLl92YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgcHJvbWlzZS5fc2V0U3RhdGUoc3RhdGVfZXJyb3Jfbm90aWZ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBfLFxuICAgICAgICBkb25lOiBfLFxuICAgICAgICB0aGVuOiBfLFxuICAgICAgICBfY29tcGxldGVkOiBfLFxuICAgICAgICBfZXJyb3I6IF8sXG4gICAgICAgIF9ub3RpZnk6IF8sXG4gICAgICAgIF9wcm9ncmVzczogXyxcbiAgICAgICAgX3NldENvbXBsZXRlVmFsdWU6IF8sXG4gICAgICAgIF9zZXRFcnJvclZhbHVlOiBfXG4gICAgfTtcblxuICAgIC8vIFN1Y2Nlc3Mgbm90aWZ5IHN0YXRlLCBtb3ZlcyBhIHByb21pc2UgdG8gdGhlIHN1Y2Nlc3Mgc3RhdGUgYW5kIG5vdGlmaWVzIGFsbCBjaGlsZHJlblxuICAgIC8vXG4gICAgc3RhdGVfc3VjY2Vzc19ub3RpZnkgPSB7XG4gICAgICAgIG5hbWU6IFwiY29tcGxldGVfbm90aWZ5XCIsXG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5kb25lID0gQ29tcGxldGVQcm9taXNlLnByb3RvdHlwZS5kb25lO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuID0gQ29tcGxldGVQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IFtwcm9taXNlXTtcbiAgICAgICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLl9zdGF0ZS5fbm90aWZ5KHAsIHF1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRTdGF0ZShzdGF0ZV9zdWNjZXNzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBfLFxuICAgICAgICBkb25lOiBudWxsLCAvKmVycm9yIHRvIGdldCBoZXJlICovXG4gICAgICAgIHRoZW46IG51bGwsIC8qZXJyb3IgdG8gZ2V0IGhlcmUgKi9cbiAgICAgICAgX2NvbXBsZXRlZDogXyxcbiAgICAgICAgX2Vycm9yOiBfLFxuICAgICAgICBfbm90aWZ5OiBub3RpZnlTdWNjZXNzLFxuICAgICAgICBfcHJvZ3Jlc3M6IF8sXG4gICAgICAgIF9zZXRDb21wbGV0ZVZhbHVlOiBfLFxuICAgICAgICBfc2V0RXJyb3JWYWx1ZTogX1xuICAgIH07XG5cbiAgICAvLyBTdWNjZXNzIHN0YXRlLCBtb3ZlcyBhIHByb21pc2UgdG8gdGhlIHN1Y2Nlc3Mgc3RhdGUgYW5kIGRvZXMgTk9UIG5vdGlmeSBhbnkgY2hpbGRyZW4uXG4gICAgLy8gU29tZSB1cHN0cmVhbSBwcm9taXNlIGlzIG93bmluZyB0aGUgbm90aWZpY2F0aW9uIHBhc3MuXG4gICAgLy9cbiAgICBzdGF0ZV9zdWNjZXNzID0ge1xuICAgICAgICBuYW1lOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLmRvbmUgPSBDb21wbGV0ZVByb21pc2UucHJvdG90eXBlLmRvbmU7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4gPSBDb21wbGV0ZVByb21pc2UucHJvdG90eXBlLnRoZW47XG4gICAgICAgICAgICBwcm9taXNlLl9jbGVhbnVwQWN0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogXyxcbiAgICAgICAgZG9uZTogbnVsbCwgLyplcnJvciB0byBnZXQgaGVyZSAqL1xuICAgICAgICB0aGVuOiBudWxsLCAvKmVycm9yIHRvIGdldCBoZXJlICovXG4gICAgICAgIF9jb21wbGV0ZWQ6IF8sXG4gICAgICAgIF9lcnJvcjogXyxcbiAgICAgICAgX25vdGlmeTogbm90aWZ5U3VjY2VzcyxcbiAgICAgICAgX3Byb2dyZXNzOiBfLFxuICAgICAgICBfc2V0Q29tcGxldGVWYWx1ZTogXyxcbiAgICAgICAgX3NldEVycm9yVmFsdWU6IF9cbiAgICB9O1xuXG4gICAgLy8gRXJyb3Igbm90aWZ5IHN0YXRlLCBtb3ZlcyBhIHByb21pc2UgdG8gdGhlIGVycm9yIHN0YXRlIGFuZCBub3RpZmllcyBhbGwgY2hpbGRyZW5cbiAgICAvL1xuICAgIHN0YXRlX2Vycm9yX25vdGlmeSA9IHtcbiAgICAgICAgbmFtZTogXCJlcnJvcl9ub3RpZnlcIixcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLmRvbmUgPSBFcnJvclByb21pc2UucHJvdG90eXBlLmRvbmU7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4gPSBFcnJvclByb21pc2UucHJvdG90eXBlLnRoZW47XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0gW3Byb21pc2VdO1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAuX3N0YXRlLl9ub3RpZnkocCwgcXVldWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2UuX3NldFN0YXRlKHN0YXRlX2Vycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBfLFxuICAgICAgICBkb25lOiBudWxsLCAvKmVycm9yIHRvIGdldCBoZXJlKi9cbiAgICAgICAgdGhlbjogbnVsbCwgLyplcnJvciB0byBnZXQgaGVyZSovXG4gICAgICAgIF9jb21wbGV0ZWQ6IF8sXG4gICAgICAgIF9lcnJvcjogXyxcbiAgICAgICAgX25vdGlmeTogbm90aWZ5RXJyb3IsXG4gICAgICAgIF9wcm9ncmVzczogXyxcbiAgICAgICAgX3NldENvbXBsZXRlVmFsdWU6IF8sXG4gICAgICAgIF9zZXRFcnJvclZhbHVlOiBfXG4gICAgfTtcblxuICAgIC8vIEVycm9yIHN0YXRlLCBtb3ZlcyBhIHByb21pc2UgdG8gdGhlIGVycm9yIHN0YXRlIGFuZCBkb2VzIE5PVCBub3RpZnkgYW55IGNoaWxkcmVuLlxuICAgIC8vIFNvbWUgdXBzdHJlYW0gcHJvbWlzZSBpcyBvd25pbmcgdGhlIG5vdGlmaWNhdGlvbiBwYXNzLlxuICAgIC8vXG4gICAgc3RhdGVfZXJyb3IgPSB7XG4gICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLmRvbmUgPSBFcnJvclByb21pc2UucHJvdG90eXBlLmRvbmU7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4gPSBFcnJvclByb21pc2UucHJvdG90eXBlLnRoZW47XG4gICAgICAgICAgICBwcm9taXNlLl9jbGVhbnVwQWN0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogXyxcbiAgICAgICAgZG9uZTogbnVsbCwgLyplcnJvciB0byBnZXQgaGVyZSovXG4gICAgICAgIHRoZW46IG51bGwsIC8qZXJyb3IgdG8gZ2V0IGhlcmUqL1xuICAgICAgICBfY29tcGxldGVkOiBfLFxuICAgICAgICBfZXJyb3I6IF8sXG4gICAgICAgIF9ub3RpZnk6IG5vdGlmeUVycm9yLFxuICAgICAgICBfcHJvZ3Jlc3M6IF8sXG4gICAgICAgIF9zZXRDb21wbGV0ZVZhbHVlOiBfLFxuICAgICAgICBfc2V0RXJyb3JWYWx1ZTogX1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIFRoZSBzdGF0ZW1hY2hpbmUgaW1wbGVtZW50YXRpb24gZm9sbG93cyBhIHZlcnkgcGFydGljdWxhciBwYXR0ZXJuLCB0aGUgc3RhdGVzIGFyZSBzcGVjaWZpZWRcbiAgICAvLyBhcyBzdGF0aWMgc3RhdGVsZXNzIGJhZ3Mgb2YgZnVuY3Rpb25zIHdoaWNoIGFyZSB0aGVuIGluZGlyZWN0ZWQgdGhyb3VnaCB0aGUgc3RhdGUgbWFjaGluZVxuICAgIC8vIGluc3RhbmNlIChhIFByb21pc2UpLiBBcyBzdWNoIGFsbCBvZiB0aGUgZnVuY3Rpb25zIG9uIGVhY2ggc3RhdGUgaGF2ZSB0aGUgcHJvbWlzZSBpbnN0YW5jZVxuICAgIC8vIHBhc3NlZCB0byB0aGVtIGV4cGxpY2l0bHkgYXMgYSBwYXJhbWV0ZXIgYW5kIHRoZSBQcm9taXNlIGluc3RhbmNlIG1lbWJlcnMgZG8gYSBsaXR0bGVcbiAgICAvLyBkYW5jZSB3aGVyZSB0aGV5IGluZGlyZWN0IHRocm91Z2ggdGhlIHN0YXRlIGFuZCBpbnNlcnQgdGhlbXNlbHZlcyBpbiB0aGUgYXJndW1lbnQgbGlzdC5cbiAgICAvL1xuICAgIC8vIFdlIGNvdWxkIGluc3RlYWQgY2FsbCBkaXJlY3RseSB0aHJvdWdoIHRoZSBwcm9taXNlIHN0YXRlcyBob3dldmVyIHRoZW4gZXZlcnkgY2FsbGVyXG4gICAgLy8gd291bGQgaGF2ZSB0byByZW1lbWJlciB0byBkbyB0aGluZ3MgbGlrZSBwdW1waW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHRvIGNhdGNoIHN0YXRlIHRyYW5zaXRpb25zLlxuICAgIC8vXG5cbiAgICB2YXIgUHJvbWlzZVN0YXRlTWFjaGluZSA9IF9CYXNlLkNsYXNzLmRlZmluZShudWxsLCB7XG4gICAgICAgIF9saXN0ZW5lcnM6IG51bGwsXG4gICAgICAgIF9uZXh0U3RhdGU6IG51bGwsXG4gICAgICAgIF9zdGF0ZTogbnVsbCxcbiAgICAgICAgX3ZhbHVlOiBudWxsLFxuXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmNhbmNlbFwiPlxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5jYW5jZWxcIj5cbiAgICAgICAgICAgIC8vLyBBdHRlbXB0cyB0byBjYW5jZWwgdGhlIGZ1bGZpbGxtZW50IG9mIGEgcHJvbWlzZWQgdmFsdWUuIElmIHRoZSBwcm9taXNlIGhhc24ndFxuICAgICAgICAgICAgLy8vIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgYW5kIGNhbmNlbGxhdGlvbiBpcyBzdXBwb3J0ZWQsIHRoZSBwcm9taXNlIGVudGVyc1xuICAgICAgICAgICAgLy8vIHRoZSBlcnJvciBzdGF0ZSB3aXRoIGEgdmFsdWUgb2YgRXJyb3IoXCJDYW5jZWxlZFwiKS5cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9ydW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG9uZTogZnVuY3Rpb24gUHJvbWlzZV9kb25lKG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lXCI+XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVcIj5cbiAgICAgICAgICAgIC8vLyBBbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHdvcmsgdG8gYmUgZG9uZSBvbiB0aGUgZnVsZmlsbG1lbnQgb2YgdGhlIHByb21pc2VkIHZhbHVlLFxuICAgICAgICAgICAgLy8vIHRoZSBlcnJvciBoYW5kbGluZyB0byBiZSBwZXJmb3JtZWQgaWYgdGhlIHByb21pc2UgZmFpbHMgdG8gZnVsZmlsbFxuICAgICAgICAgICAgLy8vIGEgdmFsdWUsIGFuZCB0aGUgaGFuZGxpbmcgb2YgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBhbG9uZyB0aGUgd2F5LlxuICAgICAgICAgICAgLy8vXG4gICAgICAgICAgICAvLy8gQWZ0ZXIgdGhlIGhhbmRsZXJzIGhhdmUgZmluaXNoZWQgZXhlY3V0aW5nLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbnkgZXJyb3IgdGhhdCB3b3VsZCBoYXZlIGJlZW4gcmV0dXJuZWRcbiAgICAgICAgICAgIC8vLyBmcm9tIHRoZW4oKSBhcyBhIHByb21pc2UgaW4gdGhlIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25Db21wbGV0ZScgdHlwZT0nRnVuY3Rpb24nIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lX3A6b25Db21wbGV0ZVwiPlxuICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIHN1Y2Nlc3NmdWxseSB3aXRoIGEgdmFsdWUuXG4gICAgICAgICAgICAvLy8gVGhlIGZ1bGZpbGxlZCB2YWx1ZSBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC4gSWYgdGhlIHZhbHVlIGlzIG51bGwsXG4gICAgICAgICAgICAvLy8gdGhlIGZ1bGZpbGxlZCB2YWx1ZSBpcyByZXR1cm5lZC4gVGhlIHZhbHVlIHJldHVybmVkXG4gICAgICAgICAgICAvLy8gZnJvbSB0aGUgZnVuY3Rpb24gYmVjb21lcyB0aGUgZnVsZmlsbGVkIHZhbHVlIG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAgICAvLy8gdGhlbigpLiBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGV4ZWN1dGluZyB0aGUgZnVuY3Rpb24sIHRoZSBwcm9taXNlIHJldHVybmVkXG4gICAgICAgICAgICAvLy8gYnkgdGhlbigpIG1vdmVzIGludG8gdGhlIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J29uRXJyb3InIHR5cGU9J0Z1bmN0aW9uJyBvcHRpb25hbD0ndHJ1ZScgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVfcDpvbkVycm9yXCI+XG4gICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhbiBlcnJvci4gVGhlIGVycm9yXG4gICAgICAgICAgICAvLy8gaXMgcGFzc2VkIGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIElmIGl0IGlzIG51bGwsIHRoZSBlcnJvciBpcyBmb3J3YXJkZWQuXG4gICAgICAgICAgICAvLy8gVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2YgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlbigpLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J29uUHJvZ3Jlc3MnIHR5cGU9J0Z1bmN0aW9uJyBvcHRpb25hbD0ndHJ1ZScgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVfcDpvblByb2dyZXNzXCI+XG4gICAgICAgICAgICAvLy8gdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSByZXBvcnRzIHByb2dyZXNzLiBEYXRhIGFib3V0IHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBQcm9taXNlcyBhcmUgbm90IHJlcXVpcmVkIHRvIHN1cHBvcnRcbiAgICAgICAgICAgIC8vLyBwcm9ncmVzcy5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuZG9uZSh0aGlzLCBvbkNvbXBsZXRlLCBvbkVycm9yLCBvblByb2dyZXNzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gUHJvbWlzZV90aGVuKG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuXCI+XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLnRoZW5cIj5cbiAgICAgICAgICAgIC8vLyBBbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHdvcmsgdG8gYmUgZG9uZSBvbiB0aGUgZnVsZmlsbG1lbnQgb2YgdGhlIHByb21pc2VkIHZhbHVlLFxuICAgICAgICAgICAgLy8vIHRoZSBlcnJvciBoYW5kbGluZyB0byBiZSBwZXJmb3JtZWQgaWYgdGhlIHByb21pc2UgZmFpbHMgdG8gZnVsZmlsbFxuICAgICAgICAgICAgLy8vIGEgdmFsdWUsIGFuZCB0aGUgaGFuZGxpbmcgb2YgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBhbG9uZyB0aGUgd2F5LlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25Db21wbGV0ZScgdHlwZT0nRnVuY3Rpb24nIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3A6b25Db21wbGV0ZVwiPlxuICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIHN1Y2Nlc3NmdWxseSB3aXRoIGEgdmFsdWUuXG4gICAgICAgICAgICAvLy8gVGhlIHZhbHVlIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBJZiB0aGUgdmFsdWUgaXMgbnVsbCwgdGhlIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAgICAgICAgLy8vIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbiBiZWNvbWVzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2YgdGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICAgICAgICAgIC8vLyB0aGVuKCkuIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgdGhpcyBmdW5jdGlvbiBpcyBiZWluZyBleGVjdXRlZCwgdGhlIHByb21pc2UgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vLyBieSB0aGVuKCkgbW92ZXMgaW50byB0aGUgZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25FcnJvcicgdHlwZT0nRnVuY3Rpb24nIG9wdGlvbmFsPSd0cnVlJyBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUudGhlbl9wOm9uRXJyb3JcIj5cbiAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGVycm9yLiBUaGUgZXJyb3JcbiAgICAgICAgICAgIC8vLyBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC4gSWYgaXQgaXMgbnVsbCwgdGhlIGVycm9yIGlzIGZvcndhcmRlZC5cbiAgICAgICAgICAgIC8vLyBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgZnVuY3Rpb24gYmVjb21lcyB0aGUgZnVsZmlsbGVkIHZhbHVlIG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZW4oKS5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdvblByb2dyZXNzJyB0eXBlPSdGdW5jdGlvbicgb3B0aW9uYWw9J3RydWUnIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3A6b25Qcm9ncmVzc1wiPlxuICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgcmVwb3J0cyBwcm9ncmVzcy4gRGF0YSBhYm91dCB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vLyBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC4gUHJvbWlzZXMgYXJlIG5vdCByZXF1aXJlZCB0byBzdXBwb3J0XG4gICAgICAgICAgICAvLy8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiV2luSlMuUHJvbWlzZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3JldHVyblZhbHVlXCI+XG4gICAgICAgICAgICAvLy8gVGhlIHByb21pc2Ugd2hvc2UgdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhlIGNvbXBsZXRlIG9yXG4gICAgICAgICAgICAvLy8gZXJyb3IgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnRoZW4odGhpcywgb25Db21wbGV0ZSwgb25FcnJvciwgb25Qcm9ncmVzcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NoYWluZWRFcnJvcjogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RhdGUuX2Vycm9yKHRoaXMsIHZhbHVlLCBkZXRhaWxzRm9yQ2hhaW5lZEVycm9yLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuX3J1bigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgX2NvbXBsZXRlZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RhdGUuX2NvbXBsZXRlZCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9ydW4oKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9lcnJvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RhdGUuX2Vycm9yKHRoaXMsIHZhbHVlLCBkZXRhaWxzRm9yRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5fcnVuKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBfcHJvZ3Jlc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuX3Byb2dyZXNzKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0Q29tcGxldGVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5fc2V0Q29tcGxldGVWYWx1ZSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9ydW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldENoYWluZWRFcnJvclZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdGF0ZS5fc2V0RXJyb3JWYWx1ZSh0aGlzLCB2YWx1ZSwgZGV0YWlsc0ZvckNoYWluZWRFcnJvciwgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl9ydW4oKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRFeGNlcHRpb25WYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RhdGUuX3NldEVycm9yVmFsdWUodGhpcywgdmFsdWUsIGRldGFpbHNGb3JFeGNlcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fcnVuKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBfcnVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9uZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5lbnRlcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgc3VwcG9ydGVkRm9yUHJvY2Vzc2luZzogZmFsc2VcbiAgICB9KTtcblxuICAgIC8vXG4gICAgLy8gSW1wbGVtZW50YXRpb25zIG9mIHNoYXJlZCBzdGF0ZSBtYWNoaW5lIGNvZGUuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZChwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0U3RhdGU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGUgPSBzdGF0ZV93YWl0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGUgPSBzdGF0ZV9zdWNjZXNzX25vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBwcm9taXNlLl9zZXRTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yRGV0YWlscyhleGNlcHRpb24sIGVycm9yLCBwcm9taXNlLCBpZCwgcGFyZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleGNlcHRpb246IGV4Y2VwdGlvbixcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWlsc0ZvckhhbmRsZWRFcnJvcihwcm9taXNlLCBlcnJvclZhbHVlLCBjb250ZXh0LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBleGNlcHRpb24gPSBjb250ZXh0Ll9pc0V4Y2VwdGlvbjtcbiAgICAgICAgdmFyIGVycm9ySWQgPSBjb250ZXh0Ll9lcnJvcklkO1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3JEZXRhaWxzKFxuICAgICAgICAgICAgZXhjZXB0aW9uID8gZXJyb3JWYWx1ZSA6IG51bGwsXG4gICAgICAgICAgICBleGNlcHRpb24gPyBudWxsIDogZXJyb3JWYWx1ZSxcbiAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICBlcnJvcklkLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWlsc0ZvckNoYWluZWRFcnJvcihwcm9taXNlLCBlcnJvclZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleGNlcHRpb24gPSBjb250ZXh0Ll9pc0V4Y2VwdGlvbjtcbiAgICAgICAgdmFyIGVycm9ySWQgPSBjb250ZXh0Ll9lcnJvcklkO1xuICAgICAgICBzZXRFcnJvckluZm8ocHJvbWlzZSwgZXJyb3JJZCwgZXhjZXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yRGV0YWlscyhcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA/IGVycm9yVmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgZXhjZXB0aW9uID8gbnVsbCA6IGVycm9yVmFsdWUsXG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgZXJyb3JJZCxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWlsc0ZvckVycm9yKHByb21pc2UsIGVycm9yVmFsdWUpIHtcbiAgICAgICAgdmFyIGVycm9ySWQgPSArK2Vycm9yX251bWJlcjtcbiAgICAgICAgc2V0RXJyb3JJbmZvKHByb21pc2UsIGVycm9ySWQpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3JEZXRhaWxzKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGVycm9yVmFsdWUsXG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgZXJyb3JJZFxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhaWxzRm9yRXhjZXB0aW9uKHByb21pc2UsIGV4Y2VwdGlvblZhbHVlKSB7XG4gICAgICAgIHZhciBlcnJvcklkID0gKytlcnJvcl9udW1iZXI7XG4gICAgICAgIHNldEVycm9ySW5mbyhwcm9taXNlLCBlcnJvcklkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yRGV0YWlscyhcbiAgICAgICAgICAgIGV4Y2VwdGlvblZhbHVlLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICBlcnJvcklkXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvbmUocHJvbWlzZSwgb25Db21wbGV0ZSwgb25FcnJvciwgb25Qcm9ncmVzcykge1xuICAgICAgICB2YXIgYXN5bmNPcElEID0gX1RyYWNlLl90cmFjZUFzeW5jT3BlcmF0aW9uU3RhcnRpbmcoXCJXaW5KUy5Qcm9taXNlLmRvbmVcIik7XG4gICAgICAgIHB1c2hMaXN0ZW5lcihwcm9taXNlLCB7IGM6IG9uQ29tcGxldGUsIGU6IG9uRXJyb3IsIHA6IG9uUHJvZ3Jlc3MsIGFzeW5jT3BJRDogYXN5bmNPcElEIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcihwcm9taXNlLCB2YWx1ZSwgb25lcnJvckRldGFpbHMsIGNvbnRleHQpIHtcbiAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY2FsbG9uZXJyb3IocHJvbWlzZSwgdmFsdWUsIG9uZXJyb3JEZXRhaWxzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvbWlzZS5fc2V0U3RhdGUoc3RhdGVfZXJyb3Jfbm90aWZ5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90aWZ5U3VjY2Vzcyhwcm9taXNlLCBxdWV1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92YWx1ZTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB2YXIgaSwgbGVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBBcnJheS5pc0FycmF5KGxpc3RlbmVycykgPyBsaXN0ZW5lcnMubGVuZ3RoIDogMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsZW4gPT09IDEgPyBsaXN0ZW5lcnMgOiBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICB2YXIgb25Db21wbGV0ZSA9IGxpc3RlbmVyLmM7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbGlzdGVuZXIucHJvbWlzZTtcblxuICAgICAgICAgICAgX1RyYWNlLl90cmFjZUFzeW5jT3BlcmF0aW9uQ29tcGxldGVkKGxpc3RlbmVyLmFzeW5jT3BJRCwgX0dsb2JhbC5EZWJ1ZyAmJiBfR2xvYmFsLkRlYnVnLk1TX0FTWU5DX09QX1NUQVRVU19TVUNDRVNTKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIF9UcmFjZS5fdHJhY2VBc3luY0NhbGxiYWNrU3RhcnRpbmcobGlzdGVuZXIuYXN5bmNPcElEKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX3NldENvbXBsZXRlVmFsdWUob25Db21wbGV0ZSA/IG9uQ29tcGxldGUodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5fc2V0RXhjZXB0aW9uVmFsdWUoZXgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIF9UcmFjZS5fdHJhY2VBc3luY0NhbGxiYWNrQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuX3N0YXRlICE9PSBzdGF0ZV93YWl0aW5nICYmIHRhcmdldC5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIENvbXBsZXRlUHJvbWlzZS5wcm90b3R5cGUuZG9uZS5jYWxsKHByb21pc2UsIG9uQ29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdGlmeUVycm9yKHByb21pc2UsIHF1ZXVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIHZhciBpLCBsZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSA/IGxpc3RlbmVycy5sZW5ndGggOiAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxlbiA9PT0gMSA/IGxpc3RlbmVycyA6IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIHZhciBvbkVycm9yID0gbGlzdGVuZXIuZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBsaXN0ZW5lci5wcm9taXNlO1xuXG4gICAgICAgICAgICB2YXIgZXJyb3JJRCA9IF9HbG9iYWwuRGVidWcgJiYgKHZhbHVlICYmIHZhbHVlLm5hbWUgPT09IGNhbmNlbGVkTmFtZSA/IF9HbG9iYWwuRGVidWcuTVNfQVNZTkNfT1BfU1RBVFVTX0NBTkNFTEVEIDogX0dsb2JhbC5EZWJ1Zy5NU19BU1lOQ19PUF9TVEFUVVNfRVJST1IpO1xuICAgICAgICAgICAgX1RyYWNlLl90cmFjZUFzeW5jT3BlcmF0aW9uQ29tcGxldGVkKGxpc3RlbmVyLmFzeW5jT3BJRCwgZXJyb3JJRCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXN5bmNDYWxsYmFja1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX1RyYWNlLl90cmFjZUFzeW5jQ2FsbGJhY2tTdGFydGluZyhsaXN0ZW5lci5hc3luY09wSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNDYWxsYmFja1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbkVycm9yLmhhbmRsZXNPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbG9uZXJyb3IodGFyZ2V0LCB2YWx1ZSwgZGV0YWlsc0ZvckhhbmRsZWRFcnJvciwgcHJvbWlzZSwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX3NldENvbXBsZXRlVmFsdWUob25FcnJvcih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll9zZXRDaGFpbmVkRXJyb3JWYWx1ZSh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX3NldEV4Y2VwdGlvblZhbHVlKGV4KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmNDYWxsYmFja1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9UcmFjZS5fdHJhY2VBc3luY0NhbGxiYWNrQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5fc3RhdGUgIT09IHN0YXRlX3dhaXRpbmcgJiYgdGFyZ2V0Ll9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRXJyb3JQcm9taXNlLnByb3RvdHlwZS5kb25lLmNhbGwocHJvbWlzZSwgbnVsbCwgb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbG9uZXJyb3IocHJvbWlzZSwgdmFsdWUsIG9uZXJyb3JEZXRhaWxzR2VuZXJhdG9yLCBjb250ZXh0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChwcm9taXNlRXZlbnRMaXN0ZW5lcnMuX2xpc3RlbmVyc1tlcnJvckVUXSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IgJiYgdmFsdWUubWVzc2FnZSA9PT0gY2FuY2VsZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZUV2ZW50TGlzdGVuZXJzLmRpc3BhdGNoRXZlbnQoZXJyb3JFVCwgb25lcnJvckRldGFpbHNHZW5lcmF0b3IocHJvbWlzZSwgdmFsdWUsIGNvbnRleHQsIGhhbmRsZXIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9ncmVzcyhwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpID8gbGlzdGVuZXJzLmxlbmd0aCA6IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxlbiA9PT0gMSA/IGxpc3RlbmVycyA6IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgb25Qcm9ncmVzcyA9IGxpc3RlbmVyLnA7XG4gICAgICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgb25Qcm9ncmVzcyh2YWx1ZSk7IH0gY2F0Y2ggKGV4KSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEobGlzdGVuZXIuYyB8fCBsaXN0ZW5lci5lKSAmJiBsaXN0ZW5lci5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLnByb21pc2UuX3Byb2dyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaExpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9taXNlLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8vIFdlIG1heSBoYXZlIGVpdGhlciBhIHNpbmdsZSBsaXN0ZW5lciAod2hpY2ggd2lsbCBuZXZlciBiZSB3cmFwcGVkIGluIGFuIGFycmF5KVxuICAgICAgICAgICAgLy8gb3IgMisgbGlzdGVuZXJzICh3aGljaCB3aWxsIGJlIHdyYXBwZWQpLiBTaW5jZSB3ZSBhcmUgbm93IGFkZGluZyBvbmUgbW9yZSBsaXN0ZW5lclxuICAgICAgICAgICAgLy8gd2UgbWF5IGhhdmUgdG8gd3JhcCB0aGUgc2luZ2xlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgdGhlIHNlY29uZC5cbiAgICAgICAgICAgIGxpc3RlbmVycyA9IEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSA/IGxpc3RlbmVycyA6IFtsaXN0ZW5lcnNdO1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIH1cbiAgICAvLyBUaGUgZGlmZmVyZW5jZSBiZXdlZW4gc2V0Q29tcGxldGVWYWx1ZSgpL3NldEVycm9yVmFsdWUoKSBhbmQgY29tcGxldGUoKS9lcnJvcigpIGlzIHRoYXQgc2V0WFhYVmFsdWUoKSBtb3Zlc1xuICAgIC8vIGEgcHJvbWlzZSBkaXJlY3RseSB0byB0aGUgc3VjY2Vzcy9lcnJvciBzdGF0ZSB3aXRob3V0IHN0YXJ0aW5nIGFub3RoZXIgbm90aWZpY2F0aW9uIHBhc3MgKGJlY2F1c2Ugb25lXG4gICAgLy8gaXMgYWxyZWFkeSBvbmdvaW5nKS5cbiAgICBmdW5jdGlvbiBzZXRFcnJvckluZm8ocHJvbWlzZSwgZXJyb3JJZCwgaXNFeGNlcHRpb24pIHtcbiAgICAgICAgcHJvbWlzZS5faXNFeGNlcHRpb24gPSBpc0V4Y2VwdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgcHJvbWlzZS5fZXJyb3JJZCA9IGVycm9ySWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEVycm9yVmFsdWUocHJvbWlzZSwgdmFsdWUsIG9uZXJyb3JEZXRhaWxzLCBjb250ZXh0KSB7XG4gICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNhbGxvbmVycm9yKHByb21pc2UsIHZhbHVlLCBvbmVycm9yRGV0YWlscywgY29udGV4dCk7XG4gICAgICAgIHByb21pc2UuX3NldFN0YXRlKHN0YXRlX2Vycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q29tcGxldGVWYWx1ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0U3RhdGU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGUgPSBzdGF0ZV93YWl0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGUgPSBzdGF0ZV9zdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByb21pc2UuX3NldFN0YXRlKHRhcmdldFN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhlbihwcm9taXNlLCBvbkNvbXBsZXRlLCBvbkVycm9yLCBvblByb2dyZXNzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVGhlblByb21pc2UocHJvbWlzZSk7XG4gICAgICAgIHZhciBhc3luY09wSUQgPSBfVHJhY2UuX3RyYWNlQXN5bmNPcGVyYXRpb25TdGFydGluZyhcIldpbkpTLlByb21pc2UudGhlblwiKTtcbiAgICAgICAgcHVzaExpc3RlbmVyKHByb21pc2UsIHsgcHJvbWlzZTogcmVzdWx0LCBjOiBvbkNvbXBsZXRlLCBlOiBvbkVycm9yLCBwOiBvblByb2dyZXNzLCBhc3luY09wSUQ6IGFzeW5jT3BJRCB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbCBwcm9taXNlLCBUaGVuUHJvbWlzZSBpcyBjcmVhdGVkIHdoZW4gYSBwcm9taXNlIG5lZWRzXG4gICAgLy8gdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHRoZW4oKSBtZXRob2QuXG4gICAgLy9cbiAgICB2YXIgVGhlblByb21pc2UgPSBfQmFzZS5DbGFzcy5kZXJpdmUoUHJvbWlzZVN0YXRlTWFjaGluZSxcbiAgICAgICAgZnVuY3Rpb24gKGNyZWF0b3IpIHtcblxuICAgICAgICAgICAgaWYgKHRhZ1dpdGhTdGFjayAmJiAodGFnV2l0aFN0YWNrID09PSB0cnVlIHx8ICh0YWdXaXRoU3RhY2sgJiB0YWcudGhlblByb21pc2UpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrID0gUHJvbWlzZS5fZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3JlYXRvciA9IGNyZWF0b3I7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShzdGF0ZV9jcmVhdGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3J1bigpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBfY3JlYXRvcjogbnVsbCxcblxuICAgICAgICAgICAgX2NhbmNlbEFjdGlvbjogZnVuY3Rpb24gKCkgeyBpZiAodGhpcy5fY3JlYXRvcikgeyB0aGlzLl9jcmVhdG9yLmNhbmNlbCgpOyB9IH0sXG4gICAgICAgICAgICBfY2xlYW51cEFjdGlvbjogZnVuY3Rpb24gKCkgeyB0aGlzLl9jcmVhdG9yID0gbnVsbDsgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRGb3JQcm9jZXNzaW5nOiBmYWxzZVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gU2xpbSBwcm9taXNlIGltcGxlbWVudGF0aW9ucyBmb3IgYWxyZWFkeSBjb21wbGV0ZWQgcHJvbWlzZXMsIHRoZXNlIGFyZSBjcmVhdGVkXG4gICAgLy8gdW5kZXIgdGhlIGhvb2Qgb24gc3luY2hyb25vdXMgY29tcGxldGlvbiBwYXRocyBhcyB3ZWxsIGFzIGJ5IFdpbkpTLlByb21pc2Uud3JhcFxuICAgIC8vIGFuZCBXaW5KUy5Qcm9taXNlLndyYXBFcnJvci5cbiAgICAvL1xuXG4gICAgdmFyIEVycm9yUHJvbWlzZSA9IF9CYXNlLkNsYXNzLmRlZmluZShcbiAgICAgICAgZnVuY3Rpb24gRXJyb3JQcm9taXNlX2N0b3IodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKHRhZ1dpdGhTdGFjayAmJiAodGFnV2l0aFN0YWNrID09PSB0cnVlIHx8ICh0YWdXaXRoU3RhY2sgJiB0YWcuZXJyb3JQcm9taXNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IFByb21pc2UuX2dldFN0YWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjYWxsb25lcnJvcih0aGlzLCB2YWx1ZSwgZGV0YWlsc0ZvckVycm9yKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmNhbmNlbFwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUuY2FuY2VsXCI+XG4gICAgICAgICAgICAgICAgLy8vIEF0dGVtcHRzIHRvIGNhbmNlbCB0aGUgZnVsZmlsbG1lbnQgb2YgYSBwcm9taXNlZCB2YWx1ZS4gSWYgdGhlIHByb21pc2UgaGFzbid0XG4gICAgICAgICAgICAgICAgLy8vIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgYW5kIGNhbmNlbGxhdGlvbiBpcyBzdXBwb3J0ZWQsIHRoZSBwcm9taXNlIGVudGVyc1xuICAgICAgICAgICAgICAgIC8vLyB0aGUgZXJyb3Igc3RhdGUgd2l0aCBhIHZhbHVlIG9mIEVycm9yKFwiQ2FuY2VsZWRcIikuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gRXJyb3JQcm9taXNlX2RvbmUodW51c2VkLCBvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVcIj5cbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVcIj5cbiAgICAgICAgICAgICAgICAvLy8gQWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSB3b3JrIHRvIGJlIGRvbmUgb24gdGhlIGZ1bGZpbGxtZW50IG9mIHRoZSBwcm9taXNlZCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAvLy8gdGhlIGVycm9yIGhhbmRsaW5nIHRvIGJlIHBlcmZvcm1lZCBpZiB0aGUgcHJvbWlzZSBmYWlscyB0byBmdWxmaWxsXG4gICAgICAgICAgICAgICAgLy8vIGEgdmFsdWUsIGFuZCB0aGUgaGFuZGxpbmcgb2YgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBhbG9uZyB0aGUgd2F5LlxuICAgICAgICAgICAgICAgIC8vL1xuICAgICAgICAgICAgICAgIC8vLyBBZnRlciB0aGUgaGFuZGxlcnMgaGF2ZSBmaW5pc2hlZCBleGVjdXRpbmcsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFueSBlcnJvciB0aGF0IHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZFxuICAgICAgICAgICAgICAgIC8vLyBmcm9tIHRoZW4oKSBhcyBhIHByb21pc2UgaW4gdGhlIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdvbkNvbXBsZXRlJyB0eXBlPSdGdW5jdGlvbicgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVfcDpvbkNvbXBsZXRlXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIHN1Y2Nlc3NmdWxseSB3aXRoIGEgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8vIFRoZSBmdWxmaWxsZWQgdmFsdWUgaXMgcGFzc2VkIGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIElmIHRoZSB2YWx1ZSBpcyBudWxsLFxuICAgICAgICAgICAgICAgIC8vLyB0aGUgZnVsZmlsbGVkIHZhbHVlIGlzIHJldHVybmVkLiBUaGUgdmFsdWUgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAvLy8gZnJvbSB0aGUgZnVuY3Rpb24gYmVjb21lcyB0aGUgZnVsZmlsbGVkIHZhbHVlIG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8vIHRoZW4oKS4gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBleGVjdXRpbmcgdGhlIGZ1bmN0aW9uLCB0aGUgcHJvbWlzZSByZXR1cm5lZFxuICAgICAgICAgICAgICAgIC8vLyBieSB0aGVuKCkgbW92ZXMgaW50byB0aGUgZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdvbkVycm9yJyB0eXBlPSdGdW5jdGlvbicgb3B0aW9uYWw9J3RydWUnIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lX3A6b25FcnJvclwiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGVycm9yLiBUaGUgZXJyb3JcbiAgICAgICAgICAgICAgICAvLy8gaXMgcGFzc2VkIGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIElmIGl0IGlzIG51bGwsIHRoZSBlcnJvciBpcyBmb3J3YXJkZWQuXG4gICAgICAgICAgICAgICAgLy8vIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbiBpcyB0aGUgZnVsZmlsbGVkIHZhbHVlIG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZW4oKS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J29uUHJvZ3Jlc3MnIHR5cGU9J0Z1bmN0aW9uJyBvcHRpb25hbD0ndHJ1ZScgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmRvbmVfcDpvblByb2dyZXNzXCI+XG4gICAgICAgICAgICAgICAgLy8vIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgcmVwb3J0cyBwcm9ncmVzcy4gRGF0YSBhYm91dCB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAvLy8gaXMgcGFzc2VkIGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIFByb21pc2VzIGFyZSBub3QgcmVxdWlyZWQgdG8gc3VwcG9ydFxuICAgICAgICAgICAgICAgIC8vLyBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb25FcnJvci5oYW5kbGVzT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxvbmVycm9yKG51bGwsIHZhbHVlLCBkZXRhaWxzRm9ySGFuZGxlZEVycm9yLCB0aGlzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvbkVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVzdWx0LmRvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCB3ZSBuZWVkIHRvIHdhaXQgb24gaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IgJiYgdmFsdWUubWVzc2FnZSA9PT0gY2FuY2VsZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1cHByZXNzIGNhbmNlbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBleGNlcHRpb24gdG8gYmUgdGhyb3duIGFzeW5jcm9ub3VzbHkgdG8gYXZvaWQgYW55IHRyeS9jYXRjaCBibG9ja3NcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIFByb21pc2UuX2RvbmVIYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiBFcnJvclByb21pc2VfdGhlbih1bnVzZWQsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUudGhlblwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUudGhlblwiPlxuICAgICAgICAgICAgICAgIC8vLyBBbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHdvcmsgdG8gYmUgZG9uZSBvbiB0aGUgZnVsZmlsbG1lbnQgb2YgdGhlIHByb21pc2VkIHZhbHVlLFxuICAgICAgICAgICAgICAgIC8vLyB0aGUgZXJyb3IgaGFuZGxpbmcgdG8gYmUgcGVyZm9ybWVkIGlmIHRoZSBwcm9taXNlIGZhaWxzIHRvIGZ1bGZpbGxcbiAgICAgICAgICAgICAgICAvLy8gYSB2YWx1ZSwgYW5kIHRoZSBoYW5kbGluZyBvZiBwcm9ncmVzcyBub3RpZmljYXRpb25zIGFsb25nIHRoZSB3YXkuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J29uQ29tcGxldGUnIHR5cGU9J0Z1bmN0aW9uJyBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUudGhlbl9wOm9uQ29tcGxldGVcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgc3VjY2Vzc2Z1bGx5IHdpdGggYSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIHZhbHVlIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBJZiB0aGUgdmFsdWUgaXMgbnVsbCwgdGhlIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgZnVuY3Rpb24gYmVjb21lcyB0aGUgZnVsZmlsbGVkIHZhbHVlIG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8vIHRoZW4oKS4gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSB0aGlzIGZ1bmN0aW9uIGlzIGJlaW5nIGV4ZWN1dGVkLCB0aGUgcHJvbWlzZSByZXR1cm5lZFxuICAgICAgICAgICAgICAgIC8vLyBieSB0aGVuKCkgbW92ZXMgaW50byB0aGUgZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdvbkVycm9yJyB0eXBlPSdGdW5jdGlvbicgb3B0aW9uYWw9J3RydWUnIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3A6b25FcnJvclwiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGVycm9yLiBUaGUgZXJyb3JcbiAgICAgICAgICAgICAgICAvLy8gaXMgcGFzc2VkIGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIElmIGl0IGlzIG51bGwsIHRoZSBlcnJvciBpcyBmb3J3YXJkZWQuXG4gICAgICAgICAgICAgICAgLy8vIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbiBiZWNvbWVzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2YgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlbigpLlxuICAgICAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25Qcm9ncmVzcycgdHlwZT0nRnVuY3Rpb24nIG9wdGlvbmFsPSd0cnVlJyBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUudGhlbl9wOm9uUHJvZ3Jlc3NcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSByZXBvcnRzIHByb2dyZXNzLiBEYXRhIGFib3V0IHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIC8vLyBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC4gUHJvbWlzZXMgYXJlIG5vdCByZXF1aXJlZCB0byBzdXBwb3J0XG4gICAgICAgICAgICAgICAgLy8vIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiV2luSlMuUHJvbWlzZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3JldHVyblZhbHVlXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSBwcm9taXNlIHdob3NlIHZhbHVlIGlzIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBjb21wbGV0ZSBvclxuICAgICAgICAgICAgICAgIC8vLyBlcnJvciBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgICAgIC8vLyA8L3NpZ25hdHVyZT5cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgaW4gYSBlcnJvciBzdGF0ZSBhbmQgbm8gZXJyb3IgaGFuZGxlciBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIC8vIHdlIG9wdGltaXplIGJ5IHNpbXBseSByZXR1cm5pbmcgdGhlIHByb21pc2UgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb25FcnJvci5oYW5kbGVzT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbG9uZXJyb3IobnVsbCwgdmFsdWUsIGRldGFpbHNGb3JIYW5kbGVkRXJyb3IsIHRoaXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDb21wbGV0ZVByb21pc2Uob25FcnJvcih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSB0aHJvdyBmcm9tIHRoZSBlcnJvciBoYW5kbGVyIGlzIHRoZSBzYW1lIGFzIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlZCB0byB0aGUgZXJyb3IgaGFuZGxlciB0aGVuIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGEgbmV3IHByb21pc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmIChleCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRXhjZXB0aW9uUHJvbWlzZShleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc3VwcG9ydGVkRm9yUHJvY2Vzc2luZzogZmFsc2VcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgRXhjZXB0aW9uUHJvbWlzZSA9IF9CYXNlLkNsYXNzLmRlcml2ZShFcnJvclByb21pc2UsXG4gICAgICAgIGZ1bmN0aW9uIEV4Y2VwdGlvblByb21pc2VfY3Rvcih2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodGFnV2l0aFN0YWNrICYmICh0YWdXaXRoU3RhY2sgPT09IHRydWUgfHwgKHRhZ1dpdGhTdGFjayAmIHRhZy5leGNlcHRpb25Qcm9taXNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IFByb21pc2UuX2dldFN0YWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjYWxsb25lcnJvcih0aGlzLCB2YWx1ZSwgZGV0YWlsc0ZvckV4Y2VwdGlvbik7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIC8qIGVtcHR5ICovXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZEZvclByb2Nlc3Npbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIENvbXBsZXRlUHJvbWlzZSA9IF9CYXNlLkNsYXNzLmRlZmluZShcbiAgICAgICAgZnVuY3Rpb24gQ29tcGxldGVQcm9taXNlX2N0b3IodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKHRhZ1dpdGhTdGFjayAmJiAodGFnV2l0aFN0YWNrID09PSB0cnVlIHx8ICh0YWdXaXRoU3RhY2sgJiB0YWcuY29tcGxldGVQcm9taXNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IFByb21pc2UuX2dldFN0YWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgVGhlblByb21pc2UobnVsbCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Ll9zZXRDb21wbGV0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLmNhbmNlbFwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUuY2FuY2VsXCI+XG4gICAgICAgICAgICAgICAgLy8vIEF0dGVtcHRzIHRvIGNhbmNlbCB0aGUgZnVsZmlsbG1lbnQgb2YgYSBwcm9taXNlZCB2YWx1ZS4gSWYgdGhlIHByb21pc2UgaGFzbid0XG4gICAgICAgICAgICAgICAgLy8vIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgYW5kIGNhbmNlbGxhdGlvbiBpcyBzdXBwb3J0ZWQsIHRoZSBwcm9taXNlIGVudGVyc1xuICAgICAgICAgICAgICAgIC8vLyB0aGUgZXJyb3Igc3RhdGUgd2l0aCBhIHZhbHVlIG9mIEVycm9yKFwiQ2FuY2VsZWRcIikuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gQ29tcGxldGVQcm9taXNlX2RvbmUob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lXCI+XG4gICAgICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lXCI+XG4gICAgICAgICAgICAgICAgLy8vIEFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgd29yayB0byBiZSBkb25lIG9uIHRoZSBmdWxmaWxsbWVudCBvZiB0aGUgcHJvbWlzZWQgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8vIHRoZSBlcnJvciBoYW5kbGluZyB0byBiZSBwZXJmb3JtZWQgaWYgdGhlIHByb21pc2UgZmFpbHMgdG8gZnVsZmlsbFxuICAgICAgICAgICAgICAgIC8vLyBhIHZhbHVlLCBhbmQgdGhlIGhhbmRsaW5nIG9mIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgYWxvbmcgdGhlIHdheS5cbiAgICAgICAgICAgICAgICAvLy9cbiAgICAgICAgICAgICAgICAvLy8gQWZ0ZXIgdGhlIGhhbmRsZXJzIGhhdmUgZmluaXNoZWQgZXhlY3V0aW5nLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbnkgZXJyb3IgdGhhdCB3b3VsZCBoYXZlIGJlZW4gcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAvLy8gZnJvbSB0aGVuKCkgYXMgYSBwcm9taXNlIGluIHRoZSBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25Db21wbGV0ZScgdHlwZT0nRnVuY3Rpb24nIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lX3A6b25Db21wbGV0ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBzdWNjZXNzZnVsbHkgd2l0aCBhIHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVsZmlsbGVkIHZhbHVlIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBJZiB0aGUgdmFsdWUgaXMgbnVsbCxcbiAgICAgICAgICAgICAgICAvLy8gdGhlIGZ1bGZpbGxlZCB2YWx1ZSBpcyByZXR1cm5lZC4gVGhlIHZhbHVlIHJldHVybmVkXG4gICAgICAgICAgICAgICAgLy8vIGZyb20gdGhlIGZ1bmN0aW9uIGJlY29tZXMgdGhlIGZ1bGZpbGxlZCB2YWx1ZSBvZiB0aGUgcHJvbWlzZSByZXR1cm5lZCBieVxuICAgICAgICAgICAgICAgIC8vLyB0aGVuKCkuIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgZXhlY3V0aW5nIHRoZSBmdW5jdGlvbiwgdGhlIHByb21pc2UgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAvLy8gYnkgdGhlbigpIG1vdmVzIGludG8gdGhlIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25FcnJvcicgdHlwZT0nRnVuY3Rpb24nIG9wdGlvbmFsPSd0cnVlJyBsb2NpZD1cIldpbkpTLlByb21pc2VTdGF0ZU1hY2hpbmUuZG9uZV9wOm9uRXJyb3JcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhbiBlcnJvci4gVGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBJZiBpdCBpcyBudWxsLCB0aGUgZXJyb3IgaXMgZm9yd2FyZGVkLlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgZnVuY3Rpb24gaXMgdGhlIGZ1bGZpbGxlZCB2YWx1ZSBvZiB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGVuKCkuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdvblByb2dyZXNzJyB0eXBlPSdGdW5jdGlvbicgb3B0aW9uYWw9J3RydWUnIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS5kb25lX3A6b25Qcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgIC8vLyB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIHJlcG9ydHMgcHJvZ3Jlc3MuIERhdGEgYWJvdXQgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBQcm9taXNlcyBhcmUgbm90IHJlcXVpcmVkIHRvIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLy8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIGlmICghb25Db21wbGV0ZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb25Db21wbGV0ZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVzdWx0LmRvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBleGNlcHRpb24gdG8gYmUgdGhyb3duIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIGFueSB0cnkvY2F0Y2ggYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX2RvbmVIYW5kbGVyKGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gQ29tcGxldGVQcm9taXNlX3RoZW4ob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuXCI+XG4gICAgICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuXCI+XG4gICAgICAgICAgICAgICAgLy8vIEFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgd29yayB0byBiZSBkb25lIG9uIHRoZSBmdWxmaWxsbWVudCBvZiB0aGUgcHJvbWlzZWQgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8vIHRoZSBlcnJvciBoYW5kbGluZyB0byBiZSBwZXJmb3JtZWQgaWYgdGhlIHByb21pc2UgZmFpbHMgdG8gZnVsZmlsbFxuICAgICAgICAgICAgICAgIC8vLyBhIHZhbHVlLCBhbmQgdGhlIGhhbmRsaW5nIG9mIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgYWxvbmcgdGhlIHdheS5cbiAgICAgICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT0nb25Db21wbGV0ZScgdHlwZT0nRnVuY3Rpb24nIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3A6b25Db21wbGV0ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBzdWNjZXNzZnVsbHkgd2l0aCBhIHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgdmFsdWUgaXMgcGFzc2VkIGFzIHRoZSBzaW5nbGUgYXJndW1lbnQuIElmIHRoZSB2YWx1ZSBpcyBudWxsLCB0aGUgdmFsdWUgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICAgLy8vIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbiBiZWNvbWVzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2YgdGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICAgICAgICAgICAgICAvLy8gdGhlbigpLiBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIHRoaXMgZnVuY3Rpb24gaXMgYmVpbmcgZXhlY3V0ZWQsIHRoZSBwcm9taXNlIHJldHVybmVkXG4gICAgICAgICAgICAgICAgLy8vIGJ5IHRoZW4oKSBtb3ZlcyBpbnRvIHRoZSBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J29uRXJyb3InIHR5cGU9J0Z1bmN0aW9uJyBvcHRpb25hbD0ndHJ1ZScgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLnRoZW5fcDpvbkVycm9yXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gZXJyb3IuIFRoZSBlcnJvclxuICAgICAgICAgICAgICAgIC8vLyBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC4gSWYgaXQgaXMgbnVsbCwgdGhlIGVycm9yIGlzIGZvcndhcmRlZC5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIGZ1bmN0aW9uIGJlY29tZXMgdGhlIGZ1bGZpbGxlZCB2YWx1ZSBvZiB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGVuKCkuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdvblByb2dyZXNzJyB0eXBlPSdGdW5jdGlvbicgb3B0aW9uYWw9J3RydWUnIGxvY2lkPVwiV2luSlMuUHJvbWlzZVN0YXRlTWFjaGluZS50aGVuX3A6b25Qcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIHJlcG9ydHMgcHJvZ3Jlc3MuIERhdGEgYWJvdXQgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBQcm9taXNlcyBhcmUgbm90IHJlcXVpcmVkIHRvIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLy8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJXaW5KUy5Qcm9taXNlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlU3RhdGVNYWNoaW5lLnRoZW5fcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIHByb21pc2Ugd2hvc2UgdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhlIGNvbXBsZXRlIG9yXG4gICAgICAgICAgICAgICAgLy8vIGVycm9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBjb21wbGV0aW9uIGhhbmRsZXIgaXMgdGhlIHNhbWUgYXMgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3ZpZGVkIHRvIHRoZSBjb21wbGV0aW9uIGhhbmRsZXIgdGhlbiB0aGVyZSBpcyBubyBuZWVkIGZvciBhIG5ldyBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBvbkNvbXBsZXRlID8gb25Db21wbGV0ZSh0aGlzLl92YWx1ZSkgOiB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlID09PSB0aGlzLl92YWx1ZSA/IHRoaXMgOiBuZXcgQ29tcGxldGVQcm9taXNlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4Y2VwdGlvblByb21pc2UoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc3VwcG9ydGVkRm9yUHJvY2Vzc2luZzogZmFsc2VcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIFByb21pc2UgaXMgdGhlIHVzZXItY3JlYXRhYmxlIFdpbkpTLlByb21pc2Ugb2JqZWN0LlxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiB0aW1lb3V0KHRpbWVvdXRNUykge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRNUykge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IF9HbG9iYWwuc2V0VGltZW91dChjLCB0aW1lb3V0TVMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9CYXNlQ29yZVV0aWxzLl9zZXRJbW1lZGlhdGUoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX0dsb2JhbC5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lb3V0V2l0aFByb21pc2UodGltZW91dCwgcHJvbWlzZSkge1xuICAgICAgICB2YXIgY2FuY2VsUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHsgcHJvbWlzZS5jYW5jZWwoKTsgfTtcbiAgICAgICAgdmFyIGNhbmNlbFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7IHRpbWVvdXQuY2FuY2VsKCk7IH07XG4gICAgICAgIHRpbWVvdXQudGhlbihjYW5jZWxQcm9taXNlKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbmNlbFRpbWVvdXQsIGNhbmNlbFRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGljQ2FuY2VsZWRQcm9taXNlO1xuXG4gICAgdmFyIFByb21pc2UgPSBfQmFzZS5DbGFzcy5kZXJpdmUoUHJvbWlzZVN0YXRlTWFjaGluZSxcbiAgICAgICAgZnVuY3Rpb24gUHJvbWlzZV9jdG9yKGluaXQsIG9uY2FuY2VsKSB7XG4gICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2VcIj5cbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2VcIj5cbiAgICAgICAgICAgIC8vLyBBIHByb21pc2UgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gc2NoZWR1bGUgd29yayB0byBiZSBkb25lIG9uIGEgdmFsdWUgdGhhdFxuICAgICAgICAgICAgLy8vIGhhcyBub3QgeWV0IGJlZW4gY29tcHV0ZWQuIEl0IGlzIGEgY29udmVuaWVudCBhYnN0cmFjdGlvbiBmb3IgbWFuYWdpbmdcbiAgICAgICAgICAgIC8vLyBpbnRlcmFjdGlvbnMgd2l0aCBhc3luY2hyb25vdXMgQVBJcy5cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbml0XCIgdHlwZT1cIkZ1bmN0aW9uXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlX3A6aW5pdFwiPlxuICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uIG9mIHRoZSAgcHJvbWlzZS4gVGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLy8gaXMgZ2l2ZW4gdGhyZWUgYXJndW1lbnRzIChjb21wbGV0ZSwgZXJyb3IsIHByb2dyZXNzKS4gSW5zaWRlIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vLyB5b3Ugc2hvdWxkIGFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBub3RpZmljYXRpb25zIHN1cHBvcnRlZCBieSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvbmNhbmNlbFwiIG9wdGlvbmFsPVwidHJ1ZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZV9wOm9uY2FuY2VsXCI+XG4gICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYSBjb25zdW1lciBvZiB0aGlzIHByb21pc2Ugd2FudHNcbiAgICAgICAgICAgIC8vLyB0byBjYW5jZWwgaXRzIHVuZG9uZSB3b3JrLiBQcm9taXNlcyBhcmUgbm90IHJlcXVpcmVkIHRvXG4gICAgICAgICAgICAvLy8gc3VwcG9ydCBjYW5jZWxsYXRpb24uXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIC8vLyA8L3NpZ25hdHVyZT5cblxuICAgICAgICAgICAgaWYgKHRhZ1dpdGhTdGFjayAmJiAodGFnV2l0aFN0YWNrID09PSB0cnVlIHx8ICh0YWdXaXRoU3RhY2sgJiB0YWcucHJvbWlzZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2sgPSBQcm9taXNlLl9nZXRTdGFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9vbmNhbmNlbCA9IG9uY2FuY2VsO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoc3RhdGVfY3JlYXRlZCk7XG4gICAgICAgICAgICB0aGlzLl9ydW4oKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGUgPSB0aGlzLl9jb21wbGV0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9lcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuX3Byb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgaW5pdChjb21wbGV0ZSwgZXJyb3IsIHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RXhjZXB0aW9uVmFsdWUoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBfb25jYW5jZWw6IG51bGwsXG5cbiAgICAgICAgICAgIF9jYW5jZWxBY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBCRUdJTiBtb25hY28gY2hhbmdlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9taXNlIGRpZCBub3QgaW1wbGVtZW50IG9uY2FuY2VsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBY2Nlc3MgZmllbGRzIHRvIGdldCB0aGVtIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGV4Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGV4LnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlRXZlbnRMaXN0ZW5lcnMuZGlzcGF0Y2hFdmVudCgnZXJyb3InLCBleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVORCBtb25hY28gY2hhbmdlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NsZWFudXBBY3Rpb246IGZ1bmN0aW9uICgpIHsgdGhpcy5fb25jYW5jZWwgPSBudWxsOyB9XG4gICAgICAgIH0sIHtcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gUHJvbWlzZV9hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2UuYWRkRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2UuYWRkRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgICAgIC8vLyBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb250cm9sLlxuICAgICAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXZlbnRUeXBlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmFkZEV2ZW50TGlzdGVuZXJfcDpldmVudFR5cGVcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIHR5cGUgKG5hbWUpIG9mIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsaXN0ZW5lclwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5hZGRFdmVudExpc3RlbmVyX3A6bGlzdGVuZXJcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGxpc3RlbmVyIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBpcyByYWlzZWQuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2FwdHVyZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5hZGRFdmVudExpc3RlbmVyX3A6Y2FwdHVyZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gaW5pdGlhdGUgY2FwdHVyZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICAgICAgcHJvbWlzZUV2ZW50TGlzdGVuZXJzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW55OiBmdW5jdGlvbiBQcm9taXNlX2FueSh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2UuYW55XCI+XG4gICAgICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuUHJvbWlzZS5hbnlcIj5cbiAgICAgICAgICAgICAgICAvLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBvbmUgb2YgdGhlIGlucHV0IHByb21pc2VzXG4gICAgICAgICAgICAgICAgLy8vIGhhcyBiZWVuIGZ1bGZpbGxlZC5cbiAgICAgICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlc1wiIHR5cGU9XCJBcnJheVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5hbnlfcDp2YWx1ZXNcIj5cbiAgICAgICAgICAgICAgICAvLy8gQW4gYXJyYXkgdGhhdCBjb250YWlucyBwcm9taXNlIG9iamVjdHMgb3Igb2JqZWN0cyB3aG9zZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vLyB2YWx1ZXMgaW5jbHVkZSBwcm9taXNlIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJXaW5KUy5Qcm9taXNlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmFueV9yZXR1cm5WYWx1ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBBIHByb21pc2UgdGhhdCBvbiBmdWxmaWxsbWVudCB5aWVsZHMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAoY29tcGxldGUgb3IgZXJyb3IpLlxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbXBsZXRlLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYXModmFsdWVzW2tleV0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgY29tcGxldGUoeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlc1trZXldIH0pOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09IGNhbmNlbGVkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKytjYW5jZWxlZCkgPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKFByb21pc2UuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlc1trZXldIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5hcyh2YWx1ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9taXNlLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzOiBmdW5jdGlvbiBQcm9taXNlX2FzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlLmFzXCI+XG4gICAgICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuUHJvbWlzZS5hc1wiPlxuICAgICAgICAgICAgICAgIC8vLyBSZXR1cm5zIGEgcHJvbWlzZS4gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgcHJvbWlzZSBpdCBpcyByZXR1cm5lZDtcbiAgICAgICAgICAgICAgICAvLy8gb3RoZXJ3aXNlIHRoZSBvYmplY3QgaXMgd3JhcHBlZCBpbiBhIHByb21pc2UuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5hc19wOnZhbHVlXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSB2YWx1ZSB0byBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIldpbkpTLlByb21pc2VcIiBsb2NpZD1cIldpbkpTLlByb21pc2UuYXNfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgICAgICAvLy8gQSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxldGVQcm9taXNlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLy8gPGZpZWxkIHR5cGU9XCJXaW5KUy5Qcm9taXNlXCIgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlLmNhbmNlbFwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5jYW5jZWxcIj5cbiAgICAgICAgICAgIC8vLyBDYW5jZWxlZCBwcm9taXNlIHZhbHVlLCBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIHByb21pc2UgY29tcGxldGlvbiBoYW5kbGVyXG4gICAgICAgICAgICAvLy8gdG8gaW5kaWNhdGUgY2FuY2VsYXRpb24gb2YgdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICAgICAgICAvLy8gPC9maWVsZD5cbiAgICAgICAgICAgIGNhbmNlbDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0YXRpY0NhbmNlbGVkUHJvbWlzZSA9IHN0YXRpY0NhbmNlbGVkUHJvbWlzZSB8fCBuZXcgRXJyb3JQcm9taXNlKG5ldyBfRXJyb3JGcm9tTmFtZShjYW5jZWxlZE5hbWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIFByb21pc2VfZGlzcGF0Y2hFdmVudChldmVudFR5cGUsIGRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2UuZGlzcGF0Y2hFdmVudFwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2UuZGlzcGF0Y2hFdmVudFwiPlxuICAgICAgICAgICAgICAgIC8vLyBSYWlzZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXZlbnRUeXBlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmRpc3BhdGNoRXZlbnRfcDpldmVudFR5cGVcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIHR5cGUgKG5hbWUpIG9mIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZXRhaWxzXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmRpc3BhdGNoRXZlbnRfcDpkZXRhaWxzXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSBzZXQgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBldmVudCBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJCb29sZWFuXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmRpc3BhdGNoRXZlbnRfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgICAgICAvLy8gU3BlY2lmaWVzIHdoZXRoZXIgcHJldmVudERlZmF1bHQgd2FzIGNhbGxlZCBvbiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8vIDwvcmV0dXJucz5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VFdmVudExpc3RlbmVycy5kaXNwYXRjaEV2ZW50KGV2ZW50VHlwZSwgZGV0YWlscyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXM6IGZ1bmN0aW9uIFByb21pc2VfaXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2UuaXNcIj5cbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmlzXCI+XG4gICAgICAgICAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGZ1bGZpbGxzIHRoZSBwcm9taXNlIGNvbnRyYWN0LlxuICAgICAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVcIiBsb2NpZD1cIldpbkpTLlByb21pc2UuaXNfcDp2YWx1ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBBIHZhbHVlIHRoYXQgbWF5IGJlIGEgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIkJvb2xlYW5cIiBsb2NpZD1cIldpbkpTLlByb21pc2UuaXNfcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgICAgICAvLy8gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgcHJvbWlzZSwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBqb2luOiBmdW5jdGlvbiBQcm9taXNlX2pvaW4odmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlLmpvaW5cIj5cbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLmpvaW5cIj5cbiAgICAgICAgICAgICAgICAvLy8gQ3JlYXRlcyBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgdGhlIHZhbHVlcyBhcmUgZnVsZmlsbGVkLlxuICAgICAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVzXCIgdHlwZT1cIk9iamVjdFwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5qb2luX3A6dmFsdWVzXCI+XG4gICAgICAgICAgICAgICAgLy8vIEFuIG9iamVjdCB3aG9zZSBmaWVsZHMgY29udGFpbiB2YWx1ZXMsIHNvbWUgb2Ygd2hpY2ggbWF5IGJlIHByb21pc2VzLlxuICAgICAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiV2luSlMuUHJvbWlzZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5qb2luX3JldHVyblZhbHVlXCI+XG4gICAgICAgICAgICAgICAgLy8vIEEgcHJvbWlzZSB3aG9zZSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBmaWVsZCBuYW1lcyBhcyB0aG9zZSBvZiB0aGUgb2JqZWN0IGluIHRoZSB2YWx1ZXMgcGFyYW1ldGVyLCB3aGVyZVxuICAgICAgICAgICAgICAgIC8vLyBlYWNoIGZpZWxkIHZhbHVlIGlzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2YgYSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbXBsZXRlLCBlcnJvciwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZGVmaW5lZHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlbmRpbmcgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdEb25lID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoLS1wZW5kaW5nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JDb3VudCA9IE9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZXJyb3JzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09IGNhbmNlbGVkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsZWRDb3VudCA9PT0gZXJyb3JDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKFByb21pc2UuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKHsgS2V5OiBrZXksIERvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UudGhlbih2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXN1bHRzW2tleV0gPSB2YWx1ZTsgYXJnRG9uZShrZXkpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IGVycm9yc1trZXldID0gdmFsdWU7IGFyZ0RvbmUoa2V5KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZyAtPSB1bmRlZmluZWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLmFzKHZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb21pc2UuY2FuY2VsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gUHJvbWlzZV9yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2UucmVtb3ZlRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2UucmVtb3ZlRXZlbnRMaXN0ZW5lclwiPlxuICAgICAgICAgICAgICAgIC8vLyBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J2V2ZW50VHlwZScgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnJlbW92ZUV2ZW50TGlzdGVuZXJfZXZlbnRUeXBlXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSB0eXBlIChuYW1lKSBvZiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPSdsaXN0ZW5lcicgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnJlbW92ZUV2ZW50TGlzdGVuZXJfbGlzdGVuZXJcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9J2NhcHR1cmUnIGxvY2lkPVwiV2luSlMuUHJvbWlzZS5yZW1vdmVFdmVudExpc3RlbmVyX2NhcHR1cmVcIj5cbiAgICAgICAgICAgICAgICAvLy8gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGluaXRpYXRlIGNhcHR1cmUuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHByb21pc2VFdmVudExpc3RlbmVycy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1cHBvcnRlZEZvclByb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gUHJvbWlzZV90aGVuKHZhbHVlLCBvbkNvbXBsZXRlLCBvbkVycm9yLCBvblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5cIj5cbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5cIj5cbiAgICAgICAgICAgICAgICAvLy8gQSBzdGF0aWMgdmVyc2lvbiBvZiB0aGUgcHJvbWlzZSBpbnN0YW5jZSBtZXRob2QgdGhlbigpLlxuICAgICAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVcIiBsb2NpZD1cIldpbkpTLlByb21pc2UudGhlbl9wOnZhbHVlXCI+XG4gICAgICAgICAgICAgICAgLy8vIHRoZSB2YWx1ZSB0byBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvbkNvbXBsZXRlXCIgdHlwZT1cIkZ1bmN0aW9uXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5fcDpjb21wbGV0ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGEgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8vIElmIGl0IGlzIG51bGwsIHRoZSBwcm9taXNlIHNpbXBseVxuICAgICAgICAgICAgICAgIC8vLyByZXR1cm5zIHRoZSB2YWx1ZS4gVGhlIHZhbHVlIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9uRXJyb3JcIiB0eXBlPVwiRnVuY3Rpb25cIiBvcHRpb25hbD1cInRydWVcIiBsb2NpZD1cIldpbkpTLlByb21pc2UudGhlbl9wOmVycm9yXCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gZXJyb3IuIFRoZSBlcnJvclxuICAgICAgICAgICAgICAgIC8vLyBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvblByb2dyZXNzXCIgdHlwZT1cIkZ1bmN0aW9uXCIgb3B0aW9uYWw9XCJ0cnVlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5fcDpwcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIHJlcG9ydHMgcHJvZ3Jlc3MuIERhdGEgYWJvdXQgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBQcm9taXNlcyBhcmUgbm90IHJlcXVpcmVkIHRvIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLy8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJXaW5KUy5Qcm9taXNlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5fcmV0dXJuVmFsdWVcIj5cbiAgICAgICAgICAgICAgICAvLy8gQSBwcm9taXNlIHdob3NlIHZhbHVlIGlzIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBwcm92aWRlZCBjb21wbGV0ZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAvLy8gPC9yZXR1cm5zPlxuICAgICAgICAgICAgICAgIC8vLyA8L3NpZ25hdHVyZT5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hcyh2YWx1ZSkudGhlbihvbkNvbXBsZXRlLCBvbkVycm9yLCBvblByb2dyZXNzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVuRWFjaDogZnVuY3Rpb24gUHJvbWlzZV90aGVuRWFjaCh2YWx1ZXMsIG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHNpZ25hdHVyZSBoZWxwS2V5d29yZD1cIldpbkpTLlByb21pc2UudGhlbkVhY2hcIj5cbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5FYWNoXCI+XG4gICAgICAgICAgICAgICAgLy8vIFBlcmZvcm1zIGFuIG9wZXJhdGlvbiBvbiBhbGwgdGhlIGlucHV0IHByb21pc2VzIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxuICAgICAgICAgICAgICAgIC8vLyB0aGF0IGhhcyB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IGFuZCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAvLy8gdGhhdCBoYXMgYmVlbiBwZXJmb3JtZWQgb24gZWFjaCBpbnB1dC5cbiAgICAgICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlc1wiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS50aGVuRWFjaF9wOnZhbHVlc1wiPlxuICAgICAgICAgICAgICAgIC8vLyBBIHNldCBvZiB2YWx1ZXMgKHdoaWNoIGNvdWxkIGJlIGVpdGhlciBhbiBhcnJheSBvciBhbiBvYmplY3QpIG9mIHdoaWNoIHNvbWUgb3IgYWxsIGFyZSBwcm9taXNlcy5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvbkNvbXBsZXRlXCIgdHlwZT1cIkZ1bmN0aW9uXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5FYWNoX3A6Y29tcGxldGVcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhIHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCwgdGhlIHByb21pc2UgcmV0dXJucyB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8vIFRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgdGhlIHNpbmdsZSBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvbkVycm9yXCIgdHlwZT1cIkZ1bmN0aW9uXCIgb3B0aW9uYWw9XCJ0cnVlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5FYWNoX3A6ZXJyb3JcIj5cbiAgICAgICAgICAgICAgICAvLy8gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhbiBlcnJvci4gVGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9uUHJvZ3Jlc3NcIiB0eXBlPVwiRnVuY3Rpb25cIiBvcHRpb25hbD1cInRydWVcIiBsb2NpZD1cIldpbkpTLlByb21pc2UudGhlbkVhY2hfcDpwcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgIC8vLyBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIHJlcG9ydHMgcHJvZ3Jlc3MuIERhdGEgYWJvdXQgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8vIGlzIHBhc3NlZCBhcyB0aGUgc2luZ2xlIGFyZ3VtZW50LiBQcm9taXNlcyBhcmUgbm90IHJlcXVpcmVkIHRvIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLy8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJXaW5KUy5Qcm9taXNlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRoZW5FYWNoX3JldHVyblZhbHVlXCI+XG4gICAgICAgICAgICAgICAgLy8vIEEgcHJvbWlzZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBQcm9taXNlLmpvaW4gb24gdGhlIHZhbHVlcyBwYXJhbWV0ZXIuXG4gICAgICAgICAgICAgICAgLy8vIDwvcmV0dXJucz5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBQcm9taXNlLmFzKHZhbHVlc1trZXldKS50aGVuKG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmpvaW4ocmVzdWx0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbiBQcm9taXNlX3RpbWVvdXQodGltZSwgcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIC8vLyA8c2lnbmF0dXJlIGhlbHBLZXl3b3JkPVwiV2luSlMuUHJvbWlzZS50aW1lb3V0XCI+XG4gICAgICAgICAgICAgICAgLy8vIDxzdW1tYXJ5IGxvY2lkPVwiV2luSlMuUHJvbWlzZS50aW1lb3V0XCI+XG4gICAgICAgICAgICAgICAgLy8vIENyZWF0ZXMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIGFmdGVyIGEgdGltZW91dC5cbiAgICAgICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRpbWVvdXRcIiB0eXBlPVwiTnVtYmVyXCIgb3B0aW9uYWw9XCJ0cnVlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLnRpbWVvdXRfcDp0aW1lb3V0XCI+XG4gICAgICAgICAgICAgICAgLy8vIFRoZSB0aW1lb3V0IHBlcmlvZCBpbiBtaWxsaXNlY29uZHMuIElmIHRoaXMgdmFsdWUgaXMgemVybyBvciBub3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgLy8vIHNldEltbWVkaWF0ZSBpcyBjYWxsZWQsIG90aGVyd2lzZSBzZXRUaW1lb3V0IGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm9taXNlXCIgdHlwZT1cIlByb21pc2VcIiBvcHRpb25hbD1cInRydWVcIiBsb2NpZD1cIldpbkpTLlByb21pc2UudGltZW91dF9wOnByb21pc2VcIj5cbiAgICAgICAgICAgICAgICAvLy8gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSBjYW5jZWxlZCBpZiBpdCBkb2Vzbid0IGNvbXBsZXRlIGJlZm9yZSB0aGVcbiAgICAgICAgICAgICAgICAvLy8gdGltZW91dCBoYXMgZXhwaXJlZC5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIldpbkpTLlByb21pc2VcIiBsb2NpZD1cIldpbkpTLlByb21pc2UudGltZW91dF9yZXR1cm5WYWx1ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBBIHByb21pc2UgdGhhdCBpcyBjb21wbGV0ZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIHNwZWNpZmllZCB0aW1lb3V0LlxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHZhciB0byA9IHRpbWVvdXQodGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UgPyB0aW1lb3V0V2l0aFByb21pc2UodG8sIHByb21pc2UpIDogdG87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JhcDogZnVuY3Rpb24gUHJvbWlzZV93cmFwKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlLndyYXBcIj5cbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnkgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLndyYXBcIj5cbiAgICAgICAgICAgICAgICAvLy8gV3JhcHMgYSBub24tcHJvbWlzZSB2YWx1ZSBpbiBhIHByb21pc2UuIFlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gaWYgeW91IG5lZWRcbiAgICAgICAgICAgICAgICAvLy8gdG8gcGFzcyBhIHZhbHVlIHRvIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBhIHByb21pc2UuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiIGxvY2lkPVwiV2luSlMuUHJvbWlzZS53cmFwX3A6dmFsdWVcIj5cbiAgICAgICAgICAgICAgICAvLy8gU29tZSBub24tcHJvbWlzZSB2YWx1ZSB0byBiZSB3cmFwcGVkIGluIGEgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIldpbkpTLlByb21pc2VcIiBsb2NpZD1cIldpbkpTLlByb21pc2Uud3JhcF9yZXR1cm5WYWx1ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBBIHByb21pc2UgdGhhdCBpcyBzdWNjZXNzZnVsbHkgZnVsZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vLyA8L3JldHVybnM+XG4gICAgICAgICAgICAgICAgLy8vIDwvc2lnbmF0dXJlPlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxldGVQcm9taXNlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cmFwRXJyb3I6IGZ1bmN0aW9uIFByb21pc2Vfd3JhcEVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxzaWduYXR1cmUgaGVscEtleXdvcmQ9XCJXaW5KUy5Qcm9taXNlLndyYXBFcnJvclwiPlxuICAgICAgICAgICAgICAgIC8vLyA8c3VtbWFyeSBsb2NpZD1cIldpbkpTLlByb21pc2Uud3JhcEVycm9yXCI+XG4gICAgICAgICAgICAgICAgLy8vIFdyYXBzIGEgbm9uLXByb21pc2UgZXJyb3IgdmFsdWUgaW4gYSBwcm9taXNlLiBZb3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIGlmIHlvdSBuZWVkXG4gICAgICAgICAgICAgICAgLy8vIHRvIHBhc3MgYW4gZXJyb3IgdG8gYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIGEgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVycm9yXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLndyYXBFcnJvcl9wOmVycm9yXCI+XG4gICAgICAgICAgICAgICAgLy8vIEEgbm9uLXByb21pc2UgZXJyb3IgdmFsdWUgdG8gYmUgd3JhcHBlZCBpbiBhIHByb21pc2UuXG4gICAgICAgICAgICAgICAgLy8vIDwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJXaW5KUy5Qcm9taXNlXCIgbG9jaWQ9XCJXaW5KUy5Qcm9taXNlLndyYXBFcnJvcl9yZXR1cm5WYWx1ZVwiPlxuICAgICAgICAgICAgICAgIC8vLyBBIHByb21pc2UgdGhhdCBpcyBpbiBhbiBlcnJvciBzdGF0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8vIDwvcmV0dXJucz5cbiAgICAgICAgICAgICAgICAvLy8gPC9zaWduYXR1cmU+XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclByb21pc2UoZXJyb3IpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX3ZlcnlFeHBlbnNpdmVUYWdXaXRoU3RhY2s6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhZ1dpdGhTdGFjazsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0YWdXaXRoU3RhY2sgPSB2YWx1ZTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92ZXJ5RXhwZW5zaXZlVGFnV2l0aFN0YWNrX3RhZzogdGFnLFxuICAgICAgICAgICAgX2dldFN0YWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9HbG9iYWwuRGVidWcgJiYgX0dsb2JhbC5EZWJ1Zy5kZWJ1Z2dlckVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGUuc3RhY2s7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfY2FuY2VsQmxvY2tlcjogZnVuY3Rpb24gUHJvbWlzZV9fY2FuY2VsQmxvY2tlcihpbnB1dCwgb25jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIG9uIGNhbmNlbGF0aW9uIHdpbGwgc3RpbGwgcmVzdWx0IGluIGRvd25zdHJlYW0gY2FuY2VsYXRpb24gd2hpbGVcbiAgICAgICAgICAgICAgICAvLyAgcHJvdGVjdGluZyB0aGUgcHJvbWlzZSAnaW5wdXQnIGZyb20gYmVpbmcgIGNhbmNlbGVkIHdoaWNoIGhhcyB0aGUgZWZmZWN0IG9mIGFsbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gICdpbnB1dCcgdG8gYmUgc2hhcmVkIGFtb3VuZyB2YXJpb3VzIGNvbnN1bWVycy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICghUHJvbWlzZS5pcyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2Uud3JhcChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNhbmNlbCAmJiBvbmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbnB1dC50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikgeyBjb21wbGV0ZSAmJiBjb21wbGV0ZSh2KTsgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHsgZXJyb3IgJiYgZXJyb3IoZSk7IH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIH1cbiAgICApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFByb21pc2UsIF9FdmVudHMuY3JlYXRlRXZlbnRQcm9wZXJ0aWVzKGVycm9yRVQpKTtcblxuICAgIFByb21pc2UuX2RvbmVIYW5kbGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9CYXNlQ29yZVV0aWxzLl9zZXRJbW1lZGlhdGUoZnVuY3Rpb24gUHJvbWlzZV9kb25lX3JldGhyb3coKSB7XG4gICAgICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIFByb21pc2VTdGF0ZU1hY2hpbmU6IFByb21pc2VTdGF0ZU1hY2hpbmUsXG4gICAgICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgICAgIHN0YXRlX2NyZWF0ZWQ6IHN0YXRlX2NyZWF0ZWRcbiAgICB9O1xufSk7XG5cbl93aW5qcyhcIldpbkpTL1Byb21pc2VcIiwgW1wiV2luSlMvQ29yZS9fQmFzZVwiLFwiV2luSlMvUHJvbWlzZS9fU3RhdGVNYWNoaW5lXCJdLCBmdW5jdGlvbiBwcm9taXNlSW5pdCggX0Jhc2UsIF9TdGF0ZU1hY2hpbmUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIF9CYXNlLk5hbWVzcGFjZS5kZWZpbmUoXCJXaW5KU1wiLCB7XG4gICAgICAgIFByb21pc2U6IF9TdGF0ZU1hY2hpbmUuUHJvbWlzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9TdGF0ZU1hY2hpbmUuUHJvbWlzZTtcbn0pO1xuXG5fX3dpbmpzX2V4cG9ydHMgPSBfbW9kdWxlc1tcIldpbkpTL0NvcmUvX1dpbkpTXCJdO1xuX193aW5qc19leHBvcnRzLlRQcm9taXNlID0gX193aW5qc19leHBvcnRzLlByb21pc2U7XG5fX3dpbmpzX2V4cG9ydHMuUFByb21pc2UgPSBfX3dpbmpzX2V4cG9ydHMuUHJvbWlzZTtcblxuLy8gRVNNLWNvbW1lbnQtYmVnaW5cbi8vIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4vLyAgICAgZGVmaW5lKFtdLCBfX3dpbmpzX2V4cG9ydHMpO1xuLy8gfSBlbHNlIHtcbi8vICAgICBtb2R1bGUuZXhwb3J0cyA9IF9fd2luanNfZXhwb3J0cztcbi8vIH1cbi8vIEVTTS1jb21tZW50LWVuZFxuXG59KSgpO1xuXG4vLyBFU00tdW5jb21tZW50LWJlZ2luXG5leHBvcnQgdmFyIFByb21pc2UgPSBfX3dpbmpzX2V4cG9ydHMuUHJvbWlzZTtcbmV4cG9ydCB2YXIgVFByb21pc2UgPSBfX3dpbmpzX2V4cG9ydHMuVFByb21pc2U7XG5leHBvcnQgdmFyIFBQcm9taXNlID0gX193aW5qc19leHBvcnRzLlBQcm9taXNlO1xuLy8gRVNNLXVuY29tbWVudC1lbmRcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js ***!
  \******************************************************************************/
/*! exports provided: logOnceWebWorkerWarning, SimpleWorkerClient, SimpleWorkerServer, create */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logOnceWebWorkerWarning\", function() { return logOnceWebWorkerWarning; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleWorkerClient\", function() { return SimpleWorkerClient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleWorkerServer\", function() { return SimpleWorkerServer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/monaco-editor/esm/vs/base/common/errors.js\");\n/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle.js */ \"./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\");\n/* harmony import */ var _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../winjs.base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\");\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../async.js */ \"./node_modules/monaco-editor/esm/vs/base/common/async.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform.js */ \"./node_modules/monaco-editor/esm/vs/base/common/platform.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar INITIALIZE = '$initialize';\nvar webWorkerWarningLogged = false;\nfunction logOnceWebWorkerWarning(err) {\n    if (!_platform_js__WEBPACK_IMPORTED_MODULE_4__[\"isWeb\"]) {\n        // running tests\n        return;\n    }\n    if (!webWorkerWarningLogged) {\n        webWorkerWarningLogged = true;\n        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq');\n    }\n    console.warn(err.message);\n}\nvar SimpleWorkerProtocol = /** @class */ (function () {\n    function SimpleWorkerProtocol(handler) {\n        this._workerId = -1;\n        this._handler = handler;\n        this._lastSentReq = 0;\n        this._pendingReplies = Object.create(null);\n    }\n    SimpleWorkerProtocol.prototype.setWorkerId = function (workerId) {\n        this._workerId = workerId;\n    };\n    SimpleWorkerProtocol.prototype.sendMessage = function (method, args) {\n        var req = String(++this._lastSentReq);\n        var reply = {\n            c: null,\n            e: null\n        };\n        var result = new _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"](function (c, e, p) {\n            reply.c = c;\n            reply.e = e;\n        }, function () {\n            // Cancel not supported\n        });\n        this._pendingReplies[req] = reply;\n        this._send({\n            vsWorker: this._workerId,\n            req: req,\n            method: method,\n            args: args\n        });\n        return result;\n    };\n    SimpleWorkerProtocol.prototype.handleMessage = function (serializedMessage) {\n        var message;\n        try {\n            message = JSON.parse(serializedMessage);\n        }\n        catch (e) {\n            // nothing\n        }\n        if (!message || !message.vsWorker) {\n            return;\n        }\n        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n            return;\n        }\n        this._handleMessage(message);\n    };\n    SimpleWorkerProtocol.prototype._handleMessage = function (msg) {\n        var _this = this;\n        if (msg.seq) {\n            var replyMessage = msg;\n            if (!this._pendingReplies[replyMessage.seq]) {\n                console.warn('Got reply to unknown seq');\n                return;\n            }\n            var reply = this._pendingReplies[replyMessage.seq];\n            delete this._pendingReplies[replyMessage.seq];\n            if (replyMessage.err) {\n                var err = replyMessage.err;\n                if (replyMessage.err.$isError) {\n                    err = new Error();\n                    err.name = replyMessage.err.name;\n                    err.message = replyMessage.err.message;\n                    err.stack = replyMessage.err.stack;\n                }\n                reply.e(err);\n                return;\n            }\n            reply.c(replyMessage.res);\n            return;\n        }\n        var requestMessage = msg;\n        var req = requestMessage.req;\n        var result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\n        result.then(function (r) {\n            _this._send({\n                vsWorker: _this._workerId,\n                seq: req,\n                res: r,\n                err: undefined\n            });\n        }, function (e) {\n            if (e.detail instanceof Error) {\n                // Loading errors have a detail property that points to the actual error\n                e.detail = Object(_errors_js__WEBPACK_IMPORTED_MODULE_0__[\"transformErrorForSerialization\"])(e.detail);\n            }\n            _this._send({\n                vsWorker: _this._workerId,\n                seq: req,\n                res: undefined,\n                err: Object(_errors_js__WEBPACK_IMPORTED_MODULE_0__[\"transformErrorForSerialization\"])(e)\n            });\n        });\n    };\n    SimpleWorkerProtocol.prototype._send = function (msg) {\n        var strMsg = JSON.stringify(msg);\n        // console.log('SENDING: ' + strMsg);\n        this._handler.sendMessage(strMsg);\n    };\n    return SimpleWorkerProtocol;\n}());\n/**\n * Main thread side\n */\nvar SimpleWorkerClient = /** @class */ (function (_super) {\n    __extends(SimpleWorkerClient, _super);\n    function SimpleWorkerClient(workerFactory, moduleId) {\n        var _this = _super.call(this) || this;\n        var lazyProxyFulfill = null;\n        var lazyProxyReject = null;\n        _this._worker = _this._register(workerFactory.create('vs/base/common/worker/simpleWorker', function (msg) {\n            _this._protocol.handleMessage(msg);\n        }, function (err) {\n            // in Firefox, web workers fail lazily :(\n            // we will reject the proxy\n            lazyProxyReject(err);\n        }));\n        _this._protocol = new SimpleWorkerProtocol({\n            sendMessage: function (msg) {\n                _this._worker.postMessage(msg);\n            },\n            handleMessage: function (method, args) {\n                // Intentionally not supporting worker -> main requests\n                return _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"].as(null);\n            }\n        });\n        _this._protocol.setWorkerId(_this._worker.getId());\n        // Gather loader configuration\n        var loaderConfiguration = null;\n        if (typeof self.require !== 'undefined' && typeof self.require.getConfig === 'function') {\n            // Get the configuration from the Monaco AMD Loader\n            loaderConfiguration = self.require.getConfig();\n        }\n        else if (typeof self.requirejs !== 'undefined') {\n            // Get the configuration from requirejs\n            loaderConfiguration = self.requirejs.s.contexts._.config;\n        }\n        _this._lazyProxy = new _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"](function (c, e, p) {\n            lazyProxyFulfill = c;\n            lazyProxyReject = e;\n        }, function () { });\n        // Send initialize message\n        _this._onModuleLoaded = _this._protocol.sendMessage(INITIALIZE, [\n            _this._worker.getId(),\n            moduleId,\n            loaderConfiguration\n        ]);\n        _this._onModuleLoaded.then(function (availableMethods) {\n            var proxy = {};\n            for (var i = 0; i < availableMethods.length; i++) {\n                proxy[availableMethods[i]] = createProxyMethod(availableMethods[i], proxyMethodRequest);\n            }\n            lazyProxyFulfill(proxy);\n        }, function (e) {\n            lazyProxyReject(e);\n            _this._onError('Worker failed to load ' + moduleId, e);\n        });\n        // Create proxy to loaded code\n        var proxyMethodRequest = function (method, args) {\n            return _this._request(method, args);\n        };\n        var createProxyMethod = function (method, proxyMethodRequest) {\n            return function () {\n                var args = Array.prototype.slice.call(arguments, 0);\n                return proxyMethodRequest(method, args);\n            };\n        };\n        return _this;\n    }\n    SimpleWorkerClient.prototype.getProxyObject = function () {\n        // Do not allow chaining promises to cancel the proxy creation\n        return new _async_js__WEBPACK_IMPORTED_MODULE_3__[\"ShallowCancelThenPromise\"](this._lazyProxy);\n    };\n    SimpleWorkerClient.prototype._request = function (method, args) {\n        var _this = this;\n        return new _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"](function (c, e, p) {\n            _this._onModuleLoaded.then(function () {\n                _this._protocol.sendMessage(method, args).then(c, e);\n            }, e);\n        }, function () {\n            // Cancel intentionally not supported\n        });\n    };\n    SimpleWorkerClient.prototype._onError = function (message, error) {\n        console.error(message);\n        console.info(error);\n    };\n    return SimpleWorkerClient;\n}(_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__[\"Disposable\"]));\n\n/**\n * Worker side\n */\nvar SimpleWorkerServer = /** @class */ (function () {\n    function SimpleWorkerServer(postSerializedMessage, requestHandler) {\n        var _this = this;\n        this._requestHandler = requestHandler;\n        this._protocol = new SimpleWorkerProtocol({\n            sendMessage: function (msg) {\n                postSerializedMessage(msg);\n            },\n            handleMessage: function (method, args) { return _this._handleMessage(method, args); }\n        });\n    }\n    SimpleWorkerServer.prototype.onmessage = function (msg) {\n        this._protocol.handleMessage(msg);\n    };\n    SimpleWorkerServer.prototype._handleMessage = function (method, args) {\n        if (method === INITIALIZE) {\n            return this.initialize(args[0], args[1], args[2]);\n        }\n        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\n            return _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"].wrapError(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"].as(this._requestHandler[method].apply(this._requestHandler, args));\n        }\n        catch (e) {\n            return _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"].wrapError(e);\n        }\n    };\n    SimpleWorkerServer.prototype.initialize = function (workerId, moduleId, loaderConfig) {\n        var _this = this;\n        this._protocol.setWorkerId(workerId);\n        if (this._requestHandler) {\n            // static request handler\n            var methods = [];\n            for (var prop in this._requestHandler) {\n                if (typeof this._requestHandler[prop] === 'function') {\n                    methods.push(prop);\n                }\n            }\n            return _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"].as(methods);\n        }\n        if (loaderConfig) {\n            // Remove 'baseUrl', handling it is beyond scope for now\n            if (typeof loaderConfig.baseUrl !== 'undefined') {\n                delete loaderConfig['baseUrl'];\n            }\n            if (typeof loaderConfig.paths !== 'undefined') {\n                if (typeof loaderConfig.paths.vs !== 'undefined') {\n                    delete loaderConfig.paths['vs'];\n                }\n            }\n            // Since this is in a web worker, enable catching errors\n            loaderConfig.catchError = true;\n            self.require.config(loaderConfig);\n        }\n        var cc;\n        var ee;\n        var r = new _winjs_base_js__WEBPACK_IMPORTED_MODULE_2__[\"TPromise\"](function (c, e, p) {\n            cc = c;\n            ee = e;\n        });\n        // Use the global require to be sure to get the global config\n        self.require([moduleId], function () {\n            var result = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                result[_i] = arguments[_i];\n            }\n            var handlerModule = result[0];\n            _this._requestHandler = handlerModule.create();\n            var methods = [];\n            for (var prop in _this._requestHandler) {\n                if (typeof _this._requestHandler[prop] === 'function') {\n                    methods.push(prop);\n                }\n            }\n            cc(methods);\n        }, ee);\n        return r;\n    };\n    return SimpleWorkerServer;\n}());\n\n/**\n * Called on the worker side\n */\nfunction create(postMessage) {\n    return new SimpleWorkerServer(postMessage, null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyLmpzPzFiMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbiB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IFRQcm9taXNlIH0gZnJvbSAnLi4vd2luanMuYmFzZS5qcyc7XG5pbXBvcnQgeyBTaGFsbG93Q2FuY2VsVGhlblByb21pc2UgfSBmcm9tICcuLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBpc1dlYiB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbnZhciBJTklUSUFMSVpFID0gJyRpbml0aWFsaXplJztcbnZhciB3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gbG9nT25jZVdlYldvcmtlcldhcm5pbmcoZXJyKSB7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgICAvLyBydW5uaW5nIHRlc3RzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkKSB7XG4gICAgICAgIHdlYldvcmtlcldhcm5pbmdMb2dnZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjcmVhdGUgd2ViIHdvcmtlcihzKS4gRmFsbGluZyBiYWNrIHRvIGxvYWRpbmcgd2ViIHdvcmtlciBjb2RlIGluIG1haW4gdGhyZWFkLCB3aGljaCBtaWdodCBjYXVzZSBVSSBmcmVlemVzLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvbW9uYWNvLWVkaXRvciNmYXEnKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKGVyci5tZXNzYWdlKTtcbn1cbnZhciBTaW1wbGVXb3JrZXJQcm90b2NvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW1wbGVXb3JrZXJQcm90b2NvbChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gLTE7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLl9sYXN0U2VudFJlcSA9IDA7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXBsaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2ltcGxlV29ya2VyUHJvdG9jb2wucHJvdG90eXBlLnNldFdvcmtlcklkID0gZnVuY3Rpb24gKHdvcmtlcklkKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gd29ya2VySWQ7XG4gICAgfTtcbiAgICBTaW1wbGVXb3JrZXJQcm90b2NvbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XG4gICAgICAgIHZhciByZXBseSA9IHtcbiAgICAgICAgICAgIGM6IG51bGwsXG4gICAgICAgICAgICBlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVFByb21pc2UoZnVuY3Rpb24gKGMsIGUsIHApIHtcbiAgICAgICAgICAgIHJlcGx5LmMgPSBjO1xuICAgICAgICAgICAgcmVwbHkuZSA9IGU7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENhbmNlbCBub3Qgc3VwcG9ydGVkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXFdID0gcmVwbHk7XG4gICAgICAgIHRoaXMuX3NlbmQoe1xuICAgICAgICAgICAgdnNXb3JrZXI6IHRoaXMuX3dvcmtlcklkLFxuICAgICAgICAgICAgcmVxOiByZXEsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTaW1wbGVXb3JrZXJQcm90b2NvbC5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCAhbWVzc2FnZS52c1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93b3JrZXJJZCAhPT0gLTEgJiYgbWVzc2FnZS52c1dvcmtlciAhPT0gdGhpcy5fd29ya2VySWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgU2ltcGxlV29ya2VyUHJvdG9jb2wucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXNnLnNlcSkge1xuICAgICAgICAgICAgdmFyIHJlcGx5TWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCByZXBseSB0byB1bmtub3duIHNlcScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXBseSA9IHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xuICAgICAgICAgICAgaWYgKHJlcGx5TWVzc2FnZS5lcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVwbHlNZXNzYWdlLmVycjtcbiAgICAgICAgICAgICAgICBpZiAocmVwbHlNZXNzYWdlLmVyci4kaXNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPSByZXBseU1lc3NhZ2UuZXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gcmVwbHlNZXNzYWdlLmVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgPSByZXBseU1lc3NhZ2UuZXJyLnN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBseS5lKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbHkuYyhyZXBseU1lc3NhZ2UucmVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdE1lc3NhZ2UgPSBtc2c7XG4gICAgICAgIHZhciByZXEgPSByZXF1ZXN0TWVzc2FnZS5yZXE7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZU1lc3NhZ2UocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5hcmdzKTtcbiAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIF90aGlzLl9zZW5kKHtcbiAgICAgICAgICAgICAgICB2c1dvcmtlcjogX3RoaXMuX3dvcmtlcklkLFxuICAgICAgICAgICAgICAgIHNlcTogcmVxLFxuICAgICAgICAgICAgICAgIHJlczogcixcbiAgICAgICAgICAgICAgICBlcnI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIExvYWRpbmcgZXJyb3JzIGhhdmUgYSBkZXRhaWwgcHJvcGVydHkgdGhhdCBwb2ludHMgdG8gdGhlIGFjdHVhbCBlcnJvclxuICAgICAgICAgICAgICAgIGUuZGV0YWlsID0gdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uKGUuZGV0YWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9zZW5kKHtcbiAgICAgICAgICAgICAgICB2c1dvcmtlcjogX3RoaXMuX3dvcmtlcklkLFxuICAgICAgICAgICAgICAgIHNlcTogcmVxLFxuICAgICAgICAgICAgICAgIHJlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGVycjogdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uKGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaW1wbGVXb3JrZXJQcm90b2NvbC5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBzdHJNc2cgPSBKU09OLnN0cmluZ2lmeShtc2cpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnU0VORElORzogJyArIHN0ck1zZyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIuc2VuZE1lc3NhZ2Uoc3RyTXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVXb3JrZXJQcm90b2NvbDtcbn0oKSk7XG4vKipcbiAqIE1haW4gdGhyZWFkIHNpZGVcbiAqL1xudmFyIFNpbXBsZVdvcmtlckNsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2ltcGxlV29ya2VyQ2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZVdvcmtlckNsaWVudCh3b3JrZXJGYWN0b3J5LCBtb2R1bGVJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbGF6eVByb3h5RnVsZmlsbCA9IG51bGw7XG4gICAgICAgIHZhciBsYXp5UHJveHlSZWplY3QgPSBudWxsO1xuICAgICAgICBfdGhpcy5fd29ya2VyID0gX3RoaXMuX3JlZ2lzdGVyKHdvcmtlckZhY3RvcnkuY3JlYXRlKCd2cy9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyJywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgX3RoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gaW4gRmlyZWZveCwgd2ViIHdvcmtlcnMgZmFpbCBsYXppbHkgOihcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVqZWN0IHRoZSBwcm94eVxuICAgICAgICAgICAgbGF6eVByb3h5UmVqZWN0KGVycik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX3RoaXMuX3Byb3RvY29sID0gbmV3IFNpbXBsZVdvcmtlclByb3RvY29sKHtcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU1lc3NhZ2U6IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCBzdXBwb3J0aW5nIHdvcmtlciAtPiBtYWluIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRQcm9taXNlLmFzKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX3Byb3RvY29sLnNldFdvcmtlcklkKF90aGlzLl93b3JrZXIuZ2V0SWQoKSk7XG4gICAgICAgIC8vIEdhdGhlciBsb2FkZXIgY29uZmlndXJhdGlvblxuICAgICAgICB2YXIgbG9hZGVyQ29uZmlndXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5yZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2VsZi5yZXF1aXJlLmdldENvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIE1vbmFjbyBBTUQgTG9hZGVyXG4gICAgICAgICAgICBsb2FkZXJDb25maWd1cmF0aW9uID0gc2VsZi5yZXF1aXJlLmdldENvbmZpZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxmLnJlcXVpcmVqcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHJlcXVpcmVqc1xuICAgICAgICAgICAgbG9hZGVyQ29uZmlndXJhdGlvbiA9IHNlbGYucmVxdWlyZWpzLnMuY29udGV4dHMuXy5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX2xhenlQcm94eSA9IG5ldyBUUHJvbWlzZShmdW5jdGlvbiAoYywgZSwgcCkge1xuICAgICAgICAgICAgbGF6eVByb3h5RnVsZmlsbCA9IGM7XG4gICAgICAgICAgICBsYXp5UHJveHlSZWplY3QgPSBlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAvLyBTZW5kIGluaXRpYWxpemUgbWVzc2FnZVxuICAgICAgICBfdGhpcy5fb25Nb2R1bGVMb2FkZWQgPSBfdGhpcy5fcHJvdG9jb2wuc2VuZE1lc3NhZ2UoSU5JVElBTElaRSwgW1xuICAgICAgICAgICAgX3RoaXMuX3dvcmtlci5nZXRJZCgpLFxuICAgICAgICAgICAgbW9kdWxlSWQsXG4gICAgICAgICAgICBsb2FkZXJDb25maWd1cmF0aW9uXG4gICAgICAgIF0pO1xuICAgICAgICBfdGhpcy5fb25Nb2R1bGVMb2FkZWQudGhlbihmdW5jdGlvbiAoYXZhaWxhYmxlTWV0aG9kcykge1xuICAgICAgICAgICAgdmFyIHByb3h5ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZU1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm94eVthdmFpbGFibGVNZXRob2RzW2ldXSA9IGNyZWF0ZVByb3h5TWV0aG9kKGF2YWlsYWJsZU1ldGhvZHNbaV0sIHByb3h5TWV0aG9kUmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXp5UHJveHlGdWxmaWxsKHByb3h5KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxhenlQcm94eVJlamVjdChlKTtcbiAgICAgICAgICAgIF90aGlzLl9vbkVycm9yKCdXb3JrZXIgZmFpbGVkIHRvIGxvYWQgJyArIG1vZHVsZUlkLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBwcm94eSB0byBsb2FkZWQgY29kZVxuICAgICAgICB2YXIgcHJveHlNZXRob2RSZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZXF1ZXN0KG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjcmVhdGVQcm94eU1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIHByb3h5TWV0aG9kUmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5TWV0aG9kUmVxdWVzdChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTaW1wbGVXb3JrZXJDbGllbnQucHJvdG90eXBlLmdldFByb3h5T2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgY2hhaW5pbmcgcHJvbWlzZXMgdG8gY2FuY2VsIHRoZSBwcm94eSBjcmVhdGlvblxuICAgICAgICByZXR1cm4gbmV3IFNoYWxsb3dDYW5jZWxUaGVuUHJvbWlzZSh0aGlzLl9sYXp5UHJveHkpO1xuICAgIH07XG4gICAgU2ltcGxlV29ya2VyQ2xpZW50LnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBUUHJvbWlzZShmdW5jdGlvbiAoYywgZSwgcCkge1xuICAgICAgICAgICAgX3RoaXMuX29uTW9kdWxlTG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShtZXRob2QsIGFyZ3MpLnRoZW4oYywgZSk7XG4gICAgICAgICAgICB9LCBlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGludGVudGlvbmFsbHkgbm90IHN1cHBvcnRlZFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpbXBsZVdvcmtlckNsaWVudC5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5pbmZvKGVycm9yKTtcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVXb3JrZXJDbGllbnQ7XG59KERpc3Bvc2FibGUpKTtcbmV4cG9ydCB7IFNpbXBsZVdvcmtlckNsaWVudCB9O1xuLyoqXG4gKiBXb3JrZXIgc2lkZVxuICovXG52YXIgU2ltcGxlV29ya2VyU2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZVdvcmtlclNlcnZlcihwb3N0U2VyaWFsaXplZE1lc3NhZ2UsIHJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gbmV3IFNpbXBsZVdvcmtlclByb3RvY29sKHtcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgcG9zdFNlcmlhbGl6ZWRNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZTogZnVuY3Rpb24gKG1ldGhvZCwgYXJncykgeyByZXR1cm4gX3RoaXMuX2hhbmRsZU1lc3NhZ2UobWV0aG9kLCBhcmdzKTsgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgU2ltcGxlV29ya2VyU2VydmVyLnByb3RvdHlwZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICB9O1xuICAgIFNpbXBsZVdvcmtlclNlcnZlci5wcm90b3R5cGUuX2hhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IElOSVRJQUxJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemUoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0SGFuZGxlciB8fCB0eXBlb2YgdGhpcy5fcmVxdWVzdEhhbmRsZXJbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIFRQcm9taXNlLndyYXBFcnJvcihuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWVzdEhhbmRsZXIgb3IgbWV0aG9kOiAnICsgbWV0aG9kKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBUUHJvbWlzZS5hcyh0aGlzLl9yZXF1ZXN0SGFuZGxlclttZXRob2RdLmFwcGx5KHRoaXMuX3JlcXVlc3RIYW5kbGVyLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBUUHJvbWlzZS53cmFwRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZVdvcmtlclNlcnZlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3b3JrZXJJZCwgbW9kdWxlSWQsIGxvYWRlckNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh3b3JrZXJJZCk7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgLy8gc3RhdGljIHJlcXVlc3QgaGFuZGxlclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3JlcXVlc3RIYW5kbGVyW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVFByb21pc2UuYXMobWV0aG9kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvYWRlckNvbmZpZykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlICdiYXNlVXJsJywgaGFuZGxpbmcgaXQgaXMgYmV5b25kIHNjb3BlIGZvciBub3dcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLmJhc2VVcmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRlckNvbmZpZ1snYmFzZVVybCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcucGF0aHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcucGF0aHMudnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWcucGF0aHNbJ3ZzJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBpbiBhIHdlYiB3b3JrZXIsIGVuYWJsZSBjYXRjaGluZyBlcnJvcnNcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZy5jYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYucmVxdWlyZS5jb25maWcobG9hZGVyQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2M7XG4gICAgICAgIHZhciBlZTtcbiAgICAgICAgdmFyIHIgPSBuZXcgVFByb21pc2UoZnVuY3Rpb24gKGMsIGUsIHApIHtcbiAgICAgICAgICAgIGNjID0gYztcbiAgICAgICAgICAgIGVlID0gZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVzZSB0aGUgZ2xvYmFsIHJlcXVpcmUgdG8gYmUgc3VyZSB0byBnZXQgdGhlIGdsb2JhbCBjb25maWdcbiAgICAgICAgc2VsZi5yZXF1aXJlKFttb2R1bGVJZF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGFuZGxlck1vZHVsZSA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0SGFuZGxlciA9IGhhbmRsZXJNb2R1bGUuY3JlYXRlKCk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBfdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLl9yZXF1ZXN0SGFuZGxlcltwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2MobWV0aG9kcyk7XG4gICAgICAgIH0sIGVlKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlV29ya2VyU2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFNpbXBsZVdvcmtlclNlcnZlciB9O1xuLyoqXG4gKiBDYWxsZWQgb24gdGhlIHdvcmtlciBzaWRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUocG9zdE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVdvcmtlclNlcnZlcihwb3N0TWVzc2FnZSwgbnVsbCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js ***!
  \*************************************************************************************/
/*! exports provided: CharacterClassifier, CharacterSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CharacterClassifier\", function() { return CharacterClassifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CharacterSet\", function() { return CharacterSet; });\n/* harmony import */ var _uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uint.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/uint.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nvar CharacterClassifier = /** @class */ (function () {\n    function CharacterClassifier(_defaultValue) {\n        var defaultValue = Object(_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint8\"])(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    CharacterClassifier._createAsciiMap = function (defaultValue) {\n        var asciiMap = new Uint8Array(256);\n        for (var i = 0; i < 256; i++) {\n            asciiMap[i] = defaultValue;\n        }\n        return asciiMap;\n    };\n    CharacterClassifier.prototype.set = function (charCode, _value) {\n        var value = Object(_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint8\"])(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    };\n    CharacterClassifier.prototype.get = function (charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    };\n    return CharacterClassifier;\n}());\n\nvar CharacterSet = /** @class */ (function () {\n    function CharacterSet() {\n        this._actual = new CharacterClassifier(0 /* False */);\n    }\n    CharacterSet.prototype.add = function (charCode) {\n        this._actual.set(charCode, 1 /* True */);\n    };\n    CharacterSet.prototype.has = function (charCode) {\n        return (this._actual.get(charCode) === 1 /* True */);\n    };\n    return CharacterSet;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanM/MzE3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IHRvVWludDggfSBmcm9tICcuL3VpbnQuanMnO1xuLyoqXG4gKiBBIGZhc3QgY2hhcmFjdGVyIGNsYXNzaWZpZXIgdGhhdCB1c2VzIGEgY29tcGFjdCBhcnJheSBmb3IgQVNDSUkgdmFsdWVzLlxuICovXG52YXIgQ2hhcmFjdGVyQ2xhc3NpZmllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFyYWN0ZXJDbGFzc2lmaWVyKF9kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRvVWludDgoX2RlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5fYXNjaWlNYXAgPSBDaGFyYWN0ZXJDbGFzc2lmaWVyLl9jcmVhdGVBc2NpaU1hcChkZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIENoYXJhY3RlckNsYXNzaWZpZXIuX2NyZWF0ZUFzY2lpTWFwID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgYXNjaWlNYXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBhc2NpaU1hcFtpXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNjaWlNYXA7XG4gICAgfTtcbiAgICBDaGFyYWN0ZXJDbGFzc2lmaWVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoY2hhckNvZGUsIF92YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0b1VpbnQ4KF92YWx1ZSk7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAwICYmIGNoYXJDb2RlIDwgMjU2KSB7XG4gICAgICAgICAgICB0aGlzLl9hc2NpaU1hcFtjaGFyQ29kZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoY2hhckNvZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhcmFjdGVyQ2xhc3NpZmllci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAwICYmIGNoYXJDb2RlIDwgMjU2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXNjaWlNYXBbY2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9tYXAuZ2V0KGNoYXJDb2RlKSB8fCB0aGlzLl9kZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQ2xhc3NpZmllcjtcbn0oKSk7XG5leHBvcnQgeyBDaGFyYWN0ZXJDbGFzc2lmaWVyIH07XG52YXIgQ2hhcmFjdGVyU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJhY3RlclNldCgpIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gbmV3IENoYXJhY3RlckNsYXNzaWZpZXIoMCAvKiBGYWxzZSAqLyk7XG4gICAgfVxuICAgIENoYXJhY3RlclNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIHRoaXMuX2FjdHVhbC5zZXQoY2hhckNvZGUsIDEgLyogVHJ1ZSAqLyk7XG4gICAgfTtcbiAgICBDaGFyYWN0ZXJTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2FjdHVhbC5nZXQoY2hhckNvZGUpID09PSAxIC8qIFRydWUgKi8pO1xuICAgIH07XG4gICAgcmV0dXJuIENoYXJhY3RlclNldDtcbn0oKSk7XG5leHBvcnQgeyBDaGFyYWN0ZXJTZXQgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/position.js":
/*!**************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js ***!
  \**************************************************************************/
/*! exports provided: Position */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A position in the editor.\n */\nvar Position = /** @class */ (function () {\n    function Position(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Test if this position equals other position\n     */\n    Position.prototype.equals = function (other) {\n        return Position.equals(this, other);\n    };\n    /**\n     * Test if position `a` equals position `b`\n     */\n    Position.equals = function (a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    };\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    Position.prototype.isBefore = function (other) {\n        return Position.isBefore(this, other);\n    };\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    Position.isBefore = function (a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    };\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    Position.prototype.isBeforeOrEqual = function (other) {\n        return Position.isBeforeOrEqual(this, other);\n    };\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    Position.isBeforeOrEqual = function (a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    };\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    Position.compare = function (a, b) {\n        var aLineNumber = a.lineNumber | 0;\n        var bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            var aColumn = a.column | 0;\n            var bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    };\n    /**\n     * Clone this position.\n     */\n    Position.prototype.clone = function () {\n        return new Position(this.lineNumber, this.column);\n    };\n    /**\n     * Convert to a human-readable representation.\n     */\n    Position.prototype.toString = function () {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    };\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    Position.lift = function (pos) {\n        return new Position(pos.lineNumber, pos.column);\n    };\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    Position.isIPosition = function (obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    };\n    return Position;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9wb3NpdGlvbi5qcz83MDYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBBIHBvc2l0aW9uIGluIHRoZSBlZGl0b3IuXG4gKi9cbnZhciBQb3NpdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3NpdGlvbihsaW5lTnVtYmVyLCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBlcXVhbHMgb3RoZXIgcG9zaXRpb25cbiAgICAgKi9cbiAgICBQb3NpdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5lcXVhbHModGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgZXF1YWxzIHBvc2l0aW9uIGBiYFxuICAgICAqL1xuICAgIFBvc2l0aW9uLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICghIWEgJiZcbiAgICAgICAgICAgICEhYiAmJlxuICAgICAgICAgICAgYS5saW5lTnVtYmVyID09PSBiLmxpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuY29sdW1uID09PSBiLmNvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcG9zaXRpb24gaXMgYmVmb3JlIG90aGVyIHBvc2l0aW9uLlxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIGZhbHNlLlxuICAgICAqL1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5pc0JlZm9yZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uaXNCZWZvcmUodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cbiAgICAgKi9cbiAgICBQb3NpdGlvbi5pc0JlZm9yZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLmxpbmVOdW1iZXIgPCBiLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmxpbmVOdW1iZXIgPCBhLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5jb2x1bW4gPCBiLmNvbHVtbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgdHJ1ZS5cbiAgICAgKi9cbiAgICBQb3NpdGlvbi5wcm90b3R5cGUuaXNCZWZvcmVPckVxdWFsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5pc0JlZm9yZU9yRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVlLlxuICAgICAqL1xuICAgIFBvc2l0aW9uLmlzQmVmb3JlT3JFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLmxpbmVOdW1iZXIgPCBiLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmxpbmVOdW1iZXIgPCBhLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5jb2x1bW4gPD0gYi5jb2x1bW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcG9zaXRpb25zLCB1c2VmdWwgZm9yIHNvcnRpbmdcbiAgICAgKi9cbiAgICBQb3NpdGlvbi5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGFMaW5lTnVtYmVyID0gYS5saW5lTnVtYmVyIHwgMDtcbiAgICAgICAgdmFyIGJMaW5lTnVtYmVyID0gYi5saW5lTnVtYmVyIHwgMDtcbiAgICAgICAgaWYgKGFMaW5lTnVtYmVyID09PSBiTGluZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIGFDb2x1bW4gPSBhLmNvbHVtbiB8IDA7XG4gICAgICAgICAgICB2YXIgYkNvbHVtbiA9IGIuY29sdW1uIHwgMDtcbiAgICAgICAgICAgIHJldHVybiBhQ29sdW1uIC0gYkNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYUxpbmVOdW1iZXIgLSBiTGluZU51bWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgcG9zaXRpb24uXG4gICAgICovXG4gICAgUG9zaXRpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZU51bWJlciwgdGhpcy5jb2x1bW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBhIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHRoaXMubGluZU51bWJlciArICcsJyArIHRoaXMuY29sdW1uICsgJyknO1xuICAgIH07XG4gICAgLy8gLS0tXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYFBvc2l0aW9uYCBmcm9tIGFuIGBJUG9zaXRpb25gLlxuICAgICAqL1xuICAgIFBvc2l0aW9uLmxpZnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zLmxpbmVOdW1iZXIsIHBvcy5jb2x1bW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgb2JqYCBpcyBhbiBgSVBvc2l0aW9uYC5cbiAgICAgKi9cbiAgICBQb3NpdGlvbi5pc0lQb3NpdGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmpcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouY29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvc2l0aW9uO1xufSgpKTtcbmV4cG9ydCB7IFBvc2l0aW9uIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js ***!
  \***********************************************************************/
/*! exports provided: Range */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Range\", function() { return Range; });\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nvar Range = /** @class */ (function () {\n    function Range(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    Range.prototype.isEmpty = function () {\n        return Range.isEmpty(this);\n    };\n    /**\n     * Test if `range` is empty.\n     */\n    Range.isEmpty = function (range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    };\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    Range.prototype.containsPosition = function (position) {\n        return Range.containsPosition(this, position);\n    };\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    Range.containsPosition = function (range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    Range.prototype.containsRange = function (range) {\n        return Range.containsRange(this, range);\n    };\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    Range.containsRange = function (range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    Range.prototype.plusRange = function (range) {\n        return Range.plusRange(this, range);\n    };\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    Range.plusRange = function (a, b) {\n        var startLineNumber;\n        var startColumn;\n        var endLineNumber;\n        var endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    };\n    /**\n     * A intersection of the two ranges.\n     */\n    Range.prototype.intersectRanges = function (range) {\n        return Range.intersectRanges(this, range);\n    };\n    /**\n     * A intersection of the two ranges.\n     */\n    Range.intersectRanges = function (a, b) {\n        var resultStartLineNumber = a.startLineNumber;\n        var resultStartColumn = a.startColumn;\n        var resultEndLineNumber = a.endLineNumber;\n        var resultEndColumn = a.endColumn;\n        var otherStartLineNumber = b.startLineNumber;\n        var otherStartColumn = b.startColumn;\n        var otherEndLineNumber = b.endLineNumber;\n        var otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    };\n    /**\n     * Test if this range equals other.\n     */\n    Range.prototype.equalsRange = function (other) {\n        return Range.equalsRange(this, other);\n    };\n    /**\n     * Test if range `a` equals `b`.\n     */\n    Range.equalsRange = function (a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    };\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    Range.prototype.getEndPosition = function () {\n        return new _position_js__WEBPACK_IMPORTED_MODULE_0__[\"Position\"](this.endLineNumber, this.endColumn);\n    };\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    Range.prototype.getStartPosition = function () {\n        return new _position_js__WEBPACK_IMPORTED_MODULE_0__[\"Position\"](this.startLineNumber, this.startColumn);\n    };\n    /**\n     * Transform to a user presentable string representation.\n     */\n    Range.prototype.toString = function () {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    };\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    Range.prototype.setEndPosition = function (endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    };\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    Range.prototype.setStartPosition = function (startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    };\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    Range.prototype.collapseToStart = function () {\n        return Range.collapseToStart(this);\n    };\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    Range.collapseToStart = function (range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    };\n    // ---\n    Range.fromPositions = function (start, end) {\n        if (end === void 0) { end = start; }\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    };\n    /**\n     * Create a `Range` from an `IRange`.\n     */\n    Range.lift = function (range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    };\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    Range.isIRange = function (obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    };\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    Range.areIntersectingOrTouching = function (a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    };\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    Range.compareRangesUsingStarts = function (a, b) {\n        var aStartLineNumber = a.startLineNumber | 0;\n        var bStartLineNumber = b.startLineNumber | 0;\n        if (aStartLineNumber === bStartLineNumber) {\n            var aStartColumn = a.startColumn | 0;\n            var bStartColumn = b.startColumn | 0;\n            if (aStartColumn === bStartColumn) {\n                var aEndLineNumber = a.endLineNumber | 0;\n                var bEndLineNumber = b.endLineNumber | 0;\n                if (aEndLineNumber === bEndLineNumber) {\n                    var aEndColumn = a.endColumn | 0;\n                    var bEndColumn = b.endColumn | 0;\n                    return aEndColumn - bEndColumn;\n                }\n                return aEndLineNumber - bEndLineNumber;\n            }\n            return aStartColumn - bStartColumn;\n        }\n        return aStartLineNumber - bStartLineNumber;\n    };\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    Range.compareRangesUsingEnds = function (a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    };\n    /**\n     * Test if the range spans multiple lines.\n     */\n    Range.spansMultipleLines = function (range) {\n        return range.endLineNumber > range.startLineNumber;\n    };\n    return Range;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3JhbmdlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9yYW5nZS5qcz82YTg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcbi8qKlxuICogQSByYW5nZSBpbiB0aGUgZWRpdG9yLiAoc3RhcnRMaW5lTnVtYmVyLHN0YXJ0Q29sdW1uKSBpcyA8PSAoZW5kTGluZU51bWJlcixlbmRDb2x1bW4pXG4gKi9cbnZhciBSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKChzdGFydExpbmVOdW1iZXIgPiBlbmRMaW5lTnVtYmVyKSB8fCAoc3RhcnRMaW5lTnVtYmVyID09PSBlbmRMaW5lTnVtYmVyICYmIHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgaXMgZW1wdHkuXG4gICAgICovXG4gICAgUmFuZ2UucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5pc0VtcHR5KHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIFJhbmdlLmlzRW1wdHkgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgZWRnZXMsIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgcG9zaXRpb25gIGlzIGluIGByYW5nZWAuIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgZWRnZXMsIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgUmFuZ2UuY29udGFpbnNQb3NpdGlvbiA9IGZ1bmN0aW9uIChyYW5nZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgcG9zaXRpb24ubGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA8IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uID4gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHJhbmdlIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSByYW5nZSBpcyBlcXVhbCB0byB0aGlzIHJhbmdlLCB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb250YWluc1JhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5jb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG90aGVyUmFuZ2VgIGlzIGluIGByYW5nZWAuIElmIHRoZSByYW5nZXMgYXJlIGVxdWFsLCB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIFJhbmdlLmNvbnRhaW5zUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIG90aGVyUmFuZ2UpIHtcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPCByYW5nZS5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgcmV1bmlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cbiAgICAgKiBUaGUgc21hbGxlc3QgcG9zaXRpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBzdGFydCBwb2ludCwgYW5kIHRoZSBsYXJnZXN0IG9uZSBhcyB0aGUgZW5kIHBvaW50LlxuICAgICAqL1xuICAgIFJhbmdlLnByb3RvdHlwZS5wbHVzUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLnBsdXNSYW5nZSh0aGlzLCByYW5nZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICogVGhlIHNtYWxsZXN0IHBvc2l0aW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9pbnQsIGFuZCB0aGUgbGFyZ2VzdCBvbmUgYXMgdGhlIGVuZCBwb2ludC5cbiAgICAgKi9cbiAgICBSYW5nZS5wbHVzUmFuZ2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgc3RhcnRDb2x1bW47XG4gICAgICAgIHZhciBlbmRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgZW5kQ29sdW1uO1xuICAgICAgICBpZiAoYi5zdGFydExpbmVOdW1iZXIgPCBhLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5zdGFydExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYi5zdGFydENvbHVtbiwgYS5zdGFydENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBhLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyID4gYS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5lbmRMaW5lTnVtYmVyID09PSBhLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBNYXRoLm1heChiLmVuZENvbHVtbiwgYS5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IGEuZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxuICAgICAqL1xuICAgIFJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RSYW5nZXMgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmludGVyc2VjdFJhbmdlcyh0aGlzLCByYW5nZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cbiAgICAgKi9cbiAgICBSYW5nZS5pbnRlcnNlY3RSYW5nZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcmVzdWx0U3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHZhciByZXN1bHRTdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW47XG4gICAgICAgIHZhciByZXN1bHRFbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgcmVzdWx0RW5kQ29sdW1uID0gYS5lbmRDb2x1bW47XG4gICAgICAgIHZhciBvdGhlclN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgb3RoZXJTdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XG4gICAgICAgIHZhciBvdGhlckVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XG4gICAgICAgIHZhciBvdGhlckVuZENvbHVtbiA9IGIuZW5kQ29sdW1uO1xuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyIDwgb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IG90aGVyU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgcmVzdWx0U3RhcnRDb2x1bW4gPSBvdGhlclN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0Q29sdW1uID0gTWF0aC5tYXgocmVzdWx0U3RhcnRDb2x1bW4sIG90aGVyU3RhcnRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID4gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHRFbmRMaW5lTnVtYmVyID0gb3RoZXJFbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgcmVzdWx0RW5kQ29sdW1uID0gb3RoZXJFbmRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0RW5kTGluZU51bWJlciA9PT0gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHRFbmRDb2x1bW4gPSBNYXRoLm1pbihyZXN1bHRFbmRDb2x1bW4sIG90aGVyRW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBzZWxlY3Rpb24gaXMgbm93IGVtcHR5XG4gICAgICAgIGlmIChyZXN1bHRTdGFydExpbmVOdW1iZXIgPiByZXN1bHRFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID09PSByZXN1bHRFbmRMaW5lTnVtYmVyICYmIHJlc3VsdFN0YXJ0Q29sdW1uID4gcmVzdWx0RW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJlc3VsdFN0YXJ0TGluZU51bWJlciwgcmVzdWx0U3RhcnRDb2x1bW4sIHJlc3VsdEVuZExpbmVOdW1iZXIsIHJlc3VsdEVuZENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgZXF1YWxzIG90aGVyLlxuICAgICAqL1xuICAgIFJhbmdlLnByb3RvdHlwZS5lcXVhbHNSYW5nZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZXF1YWxzUmFuZ2UodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiByYW5nZSBgYWAgZXF1YWxzIGBiYC5cbiAgICAgKi9cbiAgICBSYW5nZS5lcXVhbHNSYW5nZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoISFhICYmXG4gICAgICAgICAgICAhIWIgJiZcbiAgICAgICAgICAgIGEuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5zdGFydENvbHVtbiA9PT0gYi5zdGFydENvbHVtbiAmJlxuICAgICAgICAgICAgYS5lbmRMaW5lTnVtYmVyID09PSBiLmVuZExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVuZCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBhZnRlciBvciBlcXVhbCB0byB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICovXG4gICAgUmFuZ2UucHJvdG90eXBlLmdldEVuZFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuZW5kTGluZU51bWJlciwgdGhpcy5lbmRDb2x1bW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBSYW5nZS5wcm90b3R5cGUuZ2V0U3RhcnRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5zdGFydENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdG8gYSB1c2VyIHByZXNlbnRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0aGlzLnN0YXJ0TGluZU51bWJlciArICcsJyArIHRoaXMuc3RhcnRDb2x1bW4gKyAnIC0+ICcgKyB0aGlzLmVuZExpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLmVuZENvbHVtbiArICddJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24sIGFuZCB1c2luZyBlbmRMaW5lTnVtYmVyIGFuZCBlbmRDb2x1bW4gYXMgdGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBSYW5nZS5wcm90b3R5cGUuc2V0RW5kUG9zaXRpb24gPSBmdW5jdGlvbiAoZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIGVuZCBwb3NpdGlvbiwgYW5kIHVzaW5nIHN0YXJ0TGluZU51bWJlciBhbmQgc3RhcnRDb2x1bW4gYXMgdGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFJhbmdlLnByb3RvdHlwZS5zZXRTdGFydFBvc2l0aW9uID0gZnVuY3Rpb24gKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCB0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbGxhcHNlVG9TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbGxhcHNlVG9TdGFydCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgUmFuZ2UuY29sbGFwc2VUb1N0YXJ0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbiwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbik7XG4gICAgfTtcbiAgICAvLyAtLS1cbiAgICBSYW5nZS5mcm9tUG9zaXRpb25zID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHN0YXJ0OyB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQubGluZU51bWJlciwgc3RhcnQuY29sdW1uLCBlbmQubGluZU51bWJlciwgZW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgUmFuZ2VgIGZyb20gYW4gYElSYW5nZWAuXG4gICAgICovXG4gICAgUmFuZ2UubGlmdCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4sIHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUmFuZ2VgLlxuICAgICAqL1xuICAgIFJhbmdlLmlzSVJhbmdlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gKG9ialxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnN0YXJ0Q29sdW1uID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmVuZExpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouZW5kQ29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHJhbmdlcyBhcmUgdG91Y2hpbmcgaW4gYW55IHdheS5cbiAgICAgKi9cbiAgICBSYW5nZS5hcmVJbnRlcnNlY3RpbmdPclRvdWNoaW5nID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGFgIGlzIGJlZm9yZSBgYmBcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA8IGIuc3RhcnRMaW5lTnVtYmVyIHx8IChhLmVuZExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmIGEuZW5kQ29sdW1uIDwgYi5zdGFydENvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBgYmAgaXMgYmVmb3JlIGBhYFxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIgfHwgKGIuZW5kTGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIgJiYgYi5lbmRDb2x1bW4gPCBhLnN0YXJ0Q29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIHJhbmdlcyBtdXN0IGludGVyc2VjdFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyByYW5nZXMsIHVzZWZ1bCBmb3Igc29ydGluZyByYW5nZXNcbiAgICAgKiBJdCB3aWxsIGZpcnN0IGNvbXBhcmUgcmFuZ2VzIG9uIHRoZSBzdGFydFBvc2l0aW9uIGFuZCB0aGVuIG9uIHRoZSBlbmRQb3NpdGlvblxuICAgICAqL1xuICAgIFJhbmdlLmNvbXBhcmVSYW5nZXNVc2luZ1N0YXJ0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhU3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXIgfCAwO1xuICAgICAgICB2YXIgYlN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyIHwgMDtcbiAgICAgICAgaWYgKGFTdGFydExpbmVOdW1iZXIgPT09IGJTdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBhU3RhcnRDb2x1bW4gPSBhLnN0YXJ0Q29sdW1uIHwgMDtcbiAgICAgICAgICAgIHZhciBiU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uIHwgMDtcbiAgICAgICAgICAgIGlmIChhU3RhcnRDb2x1bW4gPT09IGJTdGFydENvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBhRW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlciB8IDA7XG4gICAgICAgICAgICAgICAgdmFyIGJFbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoYUVuZExpbmVOdW1iZXIgPT09IGJFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhRW5kQ29sdW1uID0gYS5lbmRDb2x1bW4gfCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYkVuZENvbHVtbiA9IGIuZW5kQ29sdW1uIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFFbmRDb2x1bW4gLSBiRW5kQ29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYUVuZExpbmVOdW1iZXIgLSBiRW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhU3RhcnRDb2x1bW4gLSBiU3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFTdGFydExpbmVOdW1iZXIgLSBiU3RhcnRMaW5lTnVtYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHJhbmdlcywgdXNlZnVsIGZvciBzb3J0aW5nIHJhbmdlc1xuICAgICAqIEl0IHdpbGwgZmlyc3QgY29tcGFyZSByYW5nZXMgb24gdGhlIGVuZFBvc2l0aW9uIGFuZCB0aGVuIG9uIHRoZSBzdGFydFBvc2l0aW9uXG4gICAgICovXG4gICAgUmFuZ2UuY29tcGFyZVJhbmdlc1VzaW5nRW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLmVuZExpbmVOdW1iZXIgPT09IGIuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgaWYgKGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgIGlmIChhLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnRDb2x1bW4gLSBiLnN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydExpbmVOdW1iZXIgLSBiLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLmVuZENvbHVtbiAtIGIuZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVuZExpbmVOdW1iZXIgLSBiLmVuZExpbmVOdW1iZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoZSByYW5nZSBzcGFucyBtdWx0aXBsZSBsaW5lcy5cbiAgICAgKi9cbiAgICBSYW5nZS5zcGFuc011bHRpcGxlTGluZXMgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVuZExpbmVOdW1iZXIgPiByYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2U7XG59KCkpO1xuZXhwb3J0IHsgUmFuZ2UgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js ***!
  \***************************************************************************/
/*! exports provided: SelectionDirection, Selection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionDirection\", function() { return SelectionDirection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Selection\", function() { return Selection; });\n/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n/**\n * The direction of a selection.\n */\nvar SelectionDirection;\n(function (SelectionDirection) {\n    /**\n     * The selection starts above where it ends.\n     */\n    SelectionDirection[SelectionDirection[\"LTR\"] = 0] = \"LTR\";\n    /**\n     * The selection starts below where it ends.\n     */\n    SelectionDirection[SelectionDirection[\"RTL\"] = 1] = \"RTL\";\n})(SelectionDirection || (SelectionDirection = {}));\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nvar Selection = /** @class */ (function (_super) {\n    __extends(Selection, _super);\n    function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        var _this = _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) || this;\n        _this.selectionStartLineNumber = selectionStartLineNumber;\n        _this.selectionStartColumn = selectionStartColumn;\n        _this.positionLineNumber = positionLineNumber;\n        _this.positionColumn = positionColumn;\n        return _this;\n    }\n    /**\n     * Clone this selection.\n     */\n    Selection.prototype.clone = function () {\n        return new Selection(this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn);\n    };\n    /**\n     * Transform to a human-readable representation.\n     */\n    Selection.prototype.toString = function () {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    };\n    /**\n     * Test if equals other selection.\n     */\n    Selection.prototype.equalsSelection = function (other) {\n        return (Selection.selectionsEqual(this, other));\n    };\n    /**\n     * Test if the two selections are equal.\n     */\n    Selection.selectionsEqual = function (a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    };\n    /**\n     * Get directions (LTR or RTL).\n     */\n    Selection.prototype.getDirection = function () {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return SelectionDirection.LTR;\n        }\n        return SelectionDirection.RTL;\n    };\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {\n        if (this.getDirection() === SelectionDirection.LTR) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    };\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    Selection.prototype.getPosition = function () {\n        return new _position_js__WEBPACK_IMPORTED_MODULE_1__[\"Position\"](this.positionLineNumber, this.positionColumn);\n    };\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {\n        if (this.getDirection() === SelectionDirection.LTR) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    };\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    Selection.fromPositions = function (start, end) {\n        if (end === void 0) { end = start; }\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    };\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    Selection.liftSelection = function (sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    };\n    /**\n     * `a` equals `b`.\n     */\n    Selection.selectionsArrEqual = function (a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (var i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    Selection.isISelection = function (obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    };\n    /**\n     * Create with a direction.\n     */\n    Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === SelectionDirection.LTR) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    };\n    return Selection;\n}(_range_js__WEBPACK_IMPORTED_MODULE_0__[\"Range\"]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3NlbGVjdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvc2VsZWN0aW9uLmpzPzgwMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRpb24uanMnO1xuLyoqXG4gKiBUaGUgZGlyZWN0aW9uIG9mIGEgc2VsZWN0aW9uLlxuICovXG5leHBvcnQgdmFyIFNlbGVjdGlvbkRpcmVjdGlvbjtcbihmdW5jdGlvbiAoU2VsZWN0aW9uRGlyZWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBzdGFydHMgYWJvdmUgd2hlcmUgaXQgZW5kcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25EaXJlY3Rpb25bU2VsZWN0aW9uRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhcnRzIGJlbG93IHdoZXJlIGl0IGVuZHMuXG4gICAgICovXG4gICAgU2VsZWN0aW9uRGlyZWN0aW9uW1NlbGVjdGlvbkRpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbn0pKFNlbGVjdGlvbkRpcmVjdGlvbiB8fCAoU2VsZWN0aW9uRGlyZWN0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvci5cbiAqIFRoZSBzZWxlY3Rpb24gaXMgYSByYW5nZSB0aGF0IGhhcyBhbiBvcmllbnRhdGlvbi5cbiAqL1xudmFyIFNlbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VsZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbihzZWxlY3Rpb25TdGFydExpbmVOdW1iZXIsIHNlbGVjdGlvblN0YXJ0Q29sdW1uLCBwb3NpdGlvbkxpbmVOdW1iZXIsIHBvc2l0aW9uQ29sdW1uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsZWN0aW9uU3RhcnRDb2x1bW4sIHBvc2l0aW9uTGluZU51bWJlciwgcG9zaXRpb25Db2x1bW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9IHNlbGVjdGlvblN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgX3RoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPSBzZWxlY3Rpb25TdGFydENvbHVtbjtcbiAgICAgICAgX3RoaXMucG9zaXRpb25MaW5lTnVtYmVyID0gcG9zaXRpb25MaW5lTnVtYmVyO1xuICAgICAgICBfdGhpcy5wb3NpdGlvbkNvbHVtbiA9IHBvc2l0aW9uQ29sdW1uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCB0aGlzLnBvc2l0aW9uTGluZU51bWJlciwgdGhpcy5wb3NpdGlvbkNvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdG8gYSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1snICsgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uICsgJyAtPiAnICsgdGhpcy5wb3NpdGlvbkxpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLnBvc2l0aW9uQ29sdW1uICsgJ10nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBlcXVhbHMgb3RoZXIgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzU2VsZWN0aW9uID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAoU2VsZWN0aW9uLnNlbGVjdGlvbnNFcXVhbCh0aGlzLCBvdGhlcikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHNlbGVjdGlvbnMgYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbi5zZWxlY3Rpb25zRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSBiLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gYi5zZWxlY3Rpb25TdGFydENvbHVtbiAmJlxuICAgICAgICAgICAgYS5wb3NpdGlvbkxpbmVOdW1iZXIgPT09IGIucG9zaXRpb25MaW5lTnVtYmVyICYmXG4gICAgICAgICAgICBhLnBvc2l0aW9uQ29sdW1uID09PSBiLnBvc2l0aW9uQ29sdW1uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBkaXJlY3Rpb25zIChMVFIgb3IgUlRMKS5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSB0aGlzLnN0YXJ0TGluZU51bWJlciAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uID09PSB0aGlzLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2VsZWN0aW9uRGlyZWN0aW9uLlJUTDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzZWxlY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBgcG9zaXRpb25MaW5lTnVtYmVyYCBhbmQgYHBvc2l0aW9uQ29sdW1uYC5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNldEVuZFBvc2l0aW9uID0gZnVuY3Rpb24gKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gU2VsZWN0aW9uRGlyZWN0aW9uLkxUUikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCB0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5zdGFydENvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGF0IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5wb3NpdGlvbkxpbmVOdW1iZXIsIHRoaXMucG9zaXRpb25Db2x1bW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXJgIGFuZCBgc2VsZWN0aW9uU3RhcnRDb2x1bW5gLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUuc2V0U3RhcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmdldERpcmVjdGlvbigpID09PSBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCB0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcbiAgICB9O1xuICAgIC8vIC0tLS1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIG9uZSBvciB0d28gcG9zaXRpb25zXG4gICAgICovXG4gICAgU2VsZWN0aW9uLmZyb21Qb3NpdGlvbnMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gc3RhcnQ7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnQubGluZU51bWJlciwgc3RhcnQuY29sdW1uLCBlbmQubGluZU51bWJlciwgZW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIGFuIGBJU2VsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb24ubGlmdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCBzZWwucG9zaXRpb25MaW5lTnVtYmVyLCBzZWwucG9zaXRpb25Db2x1bW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYGFgIGVxdWFscyBgYmAuXG4gICAgICovXG4gICAgU2VsZWN0aW9uLnNlbGVjdGlvbnNBcnJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhICYmICFiIHx8ICFhICYmIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbnNFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG9iamAgaXMgYW4gYElTZWxlY3Rpb25gLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbi5pc0lTZWxlY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmoucG9zaXRpb25MaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnBvc2l0aW9uQ29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHdpdGggYSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgU2VsZWN0aW9uLmNyZWF0ZVdpdGhEaXJlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gU2VsZWN0aW9uRGlyZWN0aW9uLkxUUikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4sIHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdGlvbjtcbn0oUmFuZ2UpKTtcbmV4cG9ydCB7IFNlbGVjdGlvbiB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/token.js":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/token.js ***!
  \***********************************************************************/
/*! exports provided: Token, TokenizationResult, TokenizationResult2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenizationResult\", function() { return TokenizationResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenizationResult2\", function() { return TokenizationResult2; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar Token = /** @class */ (function () {\n    function Token(offset, type, language) {\n        this.offset = offset | 0; // @perf\n        this.type = type;\n        this.language = language;\n    }\n    Token.prototype.toString = function () {\n        return '(' + this.offset + ', ' + this.type + ')';\n    };\n    return Token;\n}());\n\nvar TokenizationResult = /** @class */ (function () {\n    function TokenizationResult(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n    return TokenizationResult;\n}());\n\nvar TokenizationResult2 = /** @class */ (function () {\n    function TokenizationResult2(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n    return TokenizationResult2;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Rva2VuLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS90b2tlbi5qcz80ZGM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xudmFyIFRva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuKG9mZnNldCwgdHlwZSwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQgfCAwOyAvLyBAcGVyZlxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgfVxuICAgIFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHRoaXMub2Zmc2V0ICsgJywgJyArIHRoaXMudHlwZSArICcpJztcbiAgICB9O1xuICAgIHJldHVybiBUb2tlbjtcbn0oKSk7XG5leHBvcnQgeyBUb2tlbiB9O1xudmFyIFRva2VuaXphdGlvblJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6YXRpb25SZXN1bHQodG9rZW5zLCBlbmRTdGF0ZSkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5pemF0aW9uUmVzdWx0O1xufSgpKTtcbmV4cG9ydCB7IFRva2VuaXphdGlvblJlc3VsdCB9O1xudmFyIFRva2VuaXphdGlvblJlc3VsdDIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5pemF0aW9uUmVzdWx0Mih0b2tlbnMsIGVuZFN0YXRlKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmVuZFN0YXRlID0gZW5kU3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBUb2tlbml6YXRpb25SZXN1bHQyO1xufSgpKTtcbmV4cG9ydCB7IFRva2VuaXphdGlvblJlc3VsdDIgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/token.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/core/uint.js":
/*!**********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/core/uint.js ***!
  \**********************************************************************/
/*! exports provided: Uint8Matrix, toUint8, toUint32, toUint32Array */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8Matrix\", function() { return Uint8Matrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toUint8\", function() { return toUint8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toUint32\", function() { return toUint32; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toUint32Array\", function() { return toUint32Array; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar Uint8Matrix = /** @class */ (function () {\n    function Uint8Matrix(rows, cols, defaultValue) {\n        var data = new Uint8Array(rows * cols);\n        for (var i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    Uint8Matrix.prototype.get = function (row, col) {\n        return this._data[row * this.cols + col];\n    };\n    Uint8Matrix.prototype.set = function (row, col, value) {\n        this._data[row * this.cols + col] = value;\n    };\n    return Uint8Matrix;\n}());\n\nfunction toUint8(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 255 /* MAX_UINT_8 */) {\n        return 255 /* MAX_UINT_8 */;\n    }\n    return v | 0;\n}\nfunction toUint32(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 4294967295 /* MAX_UINT_32 */) {\n        return 4294967295 /* MAX_UINT_32 */;\n    }\n    return v | 0;\n}\nfunction toUint32Array(arr) {\n    var len = arr.length;\n    var r = new Uint32Array(len);\n    for (var i = 0; i < len; i++) {\n        r[i] = toUint32(arr[i]);\n    }\n    return r;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3VpbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3VpbnQuanM/NTA3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbnZhciBVaW50OE1hdHJpeCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVaW50OE1hdHJpeChyb3dzLCBjb2xzLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShyb3dzICogY29scyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3dzICogY29sczsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHMgPSBjb2xzO1xuICAgIH1cbiAgICBVaW50OE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhW3JvdyAqIHRoaXMuY29scyArIGNvbF07XG4gICAgfTtcbiAgICBVaW50OE1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHJvdywgY29sLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIHRoaXMuY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBVaW50OE1hdHJpeDtcbn0oKSk7XG5leHBvcnQgeyBVaW50OE1hdHJpeCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDgodikge1xuICAgIGlmICh2IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHYgPiAyNTUgLyogTUFYX1VJTlRfOCAqLykge1xuICAgICAgICByZXR1cm4gMjU1IC8qIE1BWF9VSU5UXzggKi87XG4gICAgfVxuICAgIHJldHVybiB2IHwgMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1VpbnQzMih2KSB7XG4gICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodiA+IDQyOTQ5NjcyOTUgLyogTUFYX1VJTlRfMzIgKi8pIHtcbiAgICAgICAgcmV0dXJuIDQyOTQ5NjcyOTUgLyogTUFYX1VJTlRfMzIgKi87XG4gICAgfVxuICAgIHJldHVybiB2IHwgMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1VpbnQzMkFycmF5KGFycikge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciByID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByW2ldID0gdG9VaW50MzIoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/core/uint.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js ***!
  \******************************************************************************/
/*! exports provided: DiffComputer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiffComputer\", function() { return DiffComputer; });\n/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ \"./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\");\n/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/strings.js */ \"./node_modules/monaco-editor/esm/vs/base/common/strings.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar MAXIMUM_RUN_TIME = 5000; // 5 seconds\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    var diffAlgo = new _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__[\"LcsDiff\"](originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nvar MarkerSequence = /** @class */ (function () {\n    function MarkerSequence(buffer, startMarkers, endMarkers) {\n        this.buffer = buffer;\n        this.startMarkers = startMarkers;\n        this.endMarkers = endMarkers;\n    }\n    MarkerSequence.prototype.getLength = function () {\n        return this.startMarkers.length;\n    };\n    MarkerSequence.prototype.getElementHash = function (i) {\n        return this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);\n    };\n    MarkerSequence.prototype.getStartLineNumber = function (i) {\n        if (i === this.startMarkers.length) {\n            // This is the special case where a change happened after the last marker\n            return this.startMarkers[i - 1].lineNumber + 1;\n        }\n        return this.startMarkers[i].lineNumber;\n    };\n    MarkerSequence.prototype.getStartColumn = function (i) {\n        return this.startMarkers[i].column;\n    };\n    MarkerSequence.prototype.getEndLineNumber = function (i) {\n        return this.endMarkers[i].lineNumber;\n    };\n    MarkerSequence.prototype.getEndColumn = function (i) {\n        return this.endMarkers[i].column;\n    };\n    return MarkerSequence;\n}());\nvar LineMarkerSequence = /** @class */ (function (_super) {\n    __extends(LineMarkerSequence, _super);\n    function LineMarkerSequence(lines) {\n        var _this = this;\n        var buffer = '';\n        var startMarkers = [];\n        var endMarkers = [];\n        for (var pos = 0, i = 0, length_1 = lines.length; i < length_1; i++) {\n            buffer += lines[i];\n            var startColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);\n            var endColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);\n            startMarkers.push({\n                offset: pos + startColumn - 1,\n                lineNumber: i + 1,\n                column: startColumn\n            });\n            endMarkers.push({\n                offset: pos + endColumn - 1,\n                lineNumber: i + 1,\n                column: endColumn\n            });\n            pos += lines[i].length;\n        }\n        _this = _super.call(this, buffer, startMarkers, endMarkers) || this;\n        return _this;\n    }\n    LineMarkerSequence._getFirstNonBlankColumn = function (txt, defaultValue) {\n        var r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__[\"firstNonWhitespaceIndex\"](txt);\n        if (r === -1) {\n            return defaultValue;\n        }\n        return r + 1;\n    };\n    LineMarkerSequence._getLastNonBlankColumn = function (txt, defaultValue) {\n        var r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__[\"lastNonWhitespaceIndex\"](txt);\n        if (r === -1) {\n            return defaultValue;\n        }\n        return r + 2;\n    };\n    LineMarkerSequence.prototype.getCharSequence = function (startIndex, endIndex) {\n        var startMarkers = [];\n        var endMarkers = [];\n        for (var index = startIndex; index <= endIndex; index++) {\n            var startMarker = this.startMarkers[index];\n            var endMarker = this.endMarkers[index];\n            for (var i = startMarker.offset; i < endMarker.offset; i++) {\n                startMarkers.push({\n                    offset: i,\n                    lineNumber: startMarker.lineNumber,\n                    column: startMarker.column + (i - startMarker.offset)\n                });\n                endMarkers.push({\n                    offset: i + 1,\n                    lineNumber: startMarker.lineNumber,\n                    column: startMarker.column + (i - startMarker.offset) + 1\n                });\n            }\n        }\n        return new MarkerSequence(this.buffer, startMarkers, endMarkers);\n    };\n    return LineMarkerSequence;\n}(MarkerSequence));\nvar CharChange = /** @class */ (function () {\n    function CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    CharChange.createFromDiffChange = function (diffChange, originalCharSequence, modifiedCharSequence) {\n        var originalStartLineNumber;\n        var originalStartColumn;\n        var originalEndLineNumber;\n        var originalEndColumn;\n        var modifiedStartLineNumber;\n        var modifiedStartColumn;\n        var modifiedEndLineNumber;\n        var modifiedEndColumn;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = 0;\n            originalStartColumn = 0;\n            originalEndLineNumber = 0;\n            originalEndColumn = 0;\n        }\n        else {\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = 0;\n            modifiedStartColumn = 0;\n            modifiedEndLineNumber = 0;\n            modifiedEndColumn = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    };\n    return CharChange;\n}());\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    var result = [rawChanges[0]];\n    var prevChange = result[0];\n    for (var i = 1, len = rawChanges.length; i < len; i++) {\n        var currChange = rawChanges[i];\n        var originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        var modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        var matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nvar LineChange = /** @class */ (function () {\n    function LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    LineChange.createFromDiffResult = function (diffChange, originalLineSequence, modifiedLineSequence, continueProcessingPredicate, shouldPostProcessCharChanges) {\n        var originalStartLineNumber;\n        var originalEndLineNumber;\n        var modifiedStartLineNumber;\n        var modifiedEndLineNumber;\n        var charChanges;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {\n            var originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            var modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            var rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate, false);\n            if (shouldPostProcessCharChanges) {\n                rawChanges = postProcessCharChanges(rawChanges);\n            }\n            charChanges = [];\n            for (var i = 0, length_2 = rawChanges.length; i < length_2; i++) {\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    };\n    return LineChange;\n}());\nvar DiffComputer = /** @class */ (function () {\n    function DiffComputer(originalLines, modifiedLines, opts) {\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.maximumRunTimeMs = MAXIMUM_RUN_TIME;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineMarkerSequence(originalLines);\n        this.modified = new LineMarkerSequence(modifiedLines);\n    }\n    DiffComputer.prototype.computeDiff = function () {\n        if (this.original.getLength() === 1 && this.original.getElementHash(0).length === 0) {\n            // empty original => fast path\n            return [{\n                    originalStartLineNumber: 1,\n                    originalEndLineNumber: 1,\n                    modifiedStartLineNumber: 1,\n                    modifiedEndLineNumber: this.modified.getLength(),\n                    charChanges: [{\n                            modifiedEndColumn: 0,\n                            modifiedEndLineNumber: 0,\n                            modifiedStartColumn: 0,\n                            modifiedStartLineNumber: 0,\n                            originalEndColumn: 0,\n                            originalEndLineNumber: 0,\n                            originalStartColumn: 0,\n                            originalStartLineNumber: 0\n                        }]\n                }];\n        }\n        if (this.modified.getLength() === 1 && this.modified.getElementHash(0).length === 0) {\n            // empty modified => fast path\n            return [{\n                    originalStartLineNumber: 1,\n                    originalEndLineNumber: this.original.getLength(),\n                    modifiedStartLineNumber: 1,\n                    modifiedEndLineNumber: 1,\n                    charChanges: [{\n                            modifiedEndColumn: 0,\n                            modifiedEndLineNumber: 0,\n                            modifiedStartColumn: 0,\n                            modifiedStartLineNumber: 0,\n                            originalEndColumn: 0,\n                            originalEndLineNumber: 0,\n                            originalStartColumn: 0,\n                            originalStartLineNumber: 0\n                        }]\n                }];\n        }\n        this.computationStartTime = (new Date()).getTime();\n        var rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldMakePrettyDiff);\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            var lineChanges = [];\n            for (var i = 0, length_3 = rawChanges.length; i < length_3; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));\n            }\n            return lineChanges;\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        var result = [];\n        var originalLineIndex = 0;\n        var modifiedLineIndex = 0;\n        for (var i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            var nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            var originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            var modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                var originalLine = this.originalLines[originalLineIndex];\n                var modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        var originalStartColumn = LineMarkerSequence._getFirstNonBlankColumn(originalLine, 1);\n                        var modifiedStartColumn = LineMarkerSequence._getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            var originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            var modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        var originalEndColumn = LineMarkerSequence._getLastNonBlankColumn(originalLine, 1);\n                        var modifiedEndColumn = LineMarkerSequence._getLastNonBlankColumn(modifiedLine, 1);\n                        var originalMaxColumn = originalLine.length + 1;\n                        var modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            var originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            var modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(nextChange, this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return result;\n    };\n    DiffComputer.prototype._pushTrimWhitespaceCharChange = function (result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, [\n            new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)\n        ]));\n    };\n    DiffComputer.prototype._mergeTrimWhitespaceCharChange = function (result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        var len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        var prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            return true;\n        }\n        return false;\n    };\n    DiffComputer.prototype._continueProcessingPredicate = function () {\n        if (this.maximumRunTimeMs === 0) {\n            return true;\n        }\n        var now = (new Date()).getTime();\n        return now - this.computationStartTime < this.maximumRunTimeMs;\n    };\n    return DiffComputer;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RpZmZDb21wdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGlmZkNvbXB1dGVyLmpzPzIyZTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IExjc0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbnZhciBNQVhJTVVNX1JVTl9USU1FID0gNTAwMDsgLy8gNSBzZWNvbmRzXG52YXIgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIID0gMztcbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSwgcHJldHR5KSB7XG4gICAgdmFyIGRpZmZBbGdvID0gbmV3IExjc0RpZmYob3JpZ2luYWxTZXF1ZW5jZSwgbW9kaWZpZWRTZXF1ZW5jZSwgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKTtcbiAgICByZXR1cm4gZGlmZkFsZ28uQ29tcHV0ZURpZmYocHJldHR5KTtcbn1cbnZhciBNYXJrZXJTZXF1ZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrZXJTZXF1ZW5jZShidWZmZXIsIHN0YXJ0TWFya2VycywgZW5kTWFya2Vycykge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5zdGFydE1hcmtlcnMgPSBzdGFydE1hcmtlcnM7XG4gICAgICAgIHRoaXMuZW5kTWFya2VycyA9IGVuZE1hcmtlcnM7XG4gICAgfVxuICAgIE1hcmtlclNlcXVlbmNlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TWFya2Vycy5sZW5ndGg7XG4gICAgfTtcbiAgICBNYXJrZXJTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0RWxlbWVudEhhc2ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMuc3RhcnRNYXJrZXJzW2ldLm9mZnNldCwgdGhpcy5lbmRNYXJrZXJzW2ldLm9mZnNldCk7XG4gICAgfTtcbiAgICBNYXJrZXJTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0U3RhcnRMaW5lTnVtYmVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKGkgPT09IHRoaXMuc3RhcnRNYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIGEgY2hhbmdlIGhhcHBlbmVkIGFmdGVyIHRoZSBsYXN0IG1hcmtlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRNYXJrZXJzW2kgLSAxXS5saW5lTnVtYmVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE1hcmtlcnNbaV0ubGluZU51bWJlcjtcbiAgICB9O1xuICAgIE1hcmtlclNlcXVlbmNlLnByb3RvdHlwZS5nZXRTdGFydENvbHVtbiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TWFya2Vyc1tpXS5jb2x1bW47XG4gICAgfTtcbiAgICBNYXJrZXJTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0RW5kTGluZU51bWJlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1hcmtlcnNbaV0ubGluZU51bWJlcjtcbiAgICB9O1xuICAgIE1hcmtlclNlcXVlbmNlLnByb3RvdHlwZS5nZXRFbmRDb2x1bW4gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRNYXJrZXJzW2ldLmNvbHVtbjtcbiAgICB9O1xuICAgIHJldHVybiBNYXJrZXJTZXF1ZW5jZTtcbn0oKSk7XG52YXIgTGluZU1hcmtlclNlcXVlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5lTWFya2VyU2VxdWVuY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZU1hcmtlclNlcXVlbmNlKGxpbmVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBidWZmZXIgPSAnJztcbiAgICAgICAgdmFyIHN0YXJ0TWFya2VycyA9IFtdO1xuICAgICAgICB2YXIgZW5kTWFya2VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwb3MgPSAwLCBpID0gMCwgbGVuZ3RoXzEgPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gbGluZXNbaV07XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBMaW5lTWFya2VyU2VxdWVuY2UuX2dldEZpcnN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xuICAgICAgICAgICAgdmFyIGVuZENvbHVtbiA9IExpbmVNYXJrZXJTZXF1ZW5jZS5fZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKGxpbmVzW2ldLCAxKTtcbiAgICAgICAgICAgIHN0YXJ0TWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvcyArIHN0YXJ0Q29sdW1uIC0gMSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBpICsgMSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0Q29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVuZE1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3MgKyBlbmRDb2x1bW4gLSAxLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGkgKyAxLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBidWZmZXIsIHN0YXJ0TWFya2VycywgZW5kTWFya2VycykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaW5lTWFya2VyU2VxdWVuY2UuX2dldEZpcnN0Tm9uQmxhbmtDb2x1bW4gPSBmdW5jdGlvbiAodHh0LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdmFyIHIgPSBzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KHR4dCk7XG4gICAgICAgIGlmIChyID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gciArIDE7XG4gICAgfTtcbiAgICBMaW5lTWFya2VyU2VxdWVuY2UuX2dldExhc3ROb25CbGFua0NvbHVtbiA9IGZ1bmN0aW9uICh0eHQsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgciA9IHN0cmluZ3MubGFzdE5vbldoaXRlc3BhY2VJbmRleCh0eHQpO1xuICAgICAgICBpZiAociA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIgKyAyO1xuICAgIH07XG4gICAgTGluZU1hcmtlclNlcXVlbmNlLnByb3RvdHlwZS5nZXRDaGFyU2VxdWVuY2UgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIHN0YXJ0TWFya2VycyA9IFtdO1xuICAgICAgICB2YXIgZW5kTWFya2VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDw9IGVuZEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRNYXJrZXIgPSB0aGlzLnN0YXJ0TWFya2Vyc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZW5kTWFya2VyID0gdGhpcy5lbmRNYXJrZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydE1hcmtlci5vZmZzZXQ7IGkgPCBlbmRNYXJrZXIub2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdGFydE1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogaSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogc3RhcnRNYXJrZXIubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydE1hcmtlci5jb2x1bW4gKyAoaSAtIHN0YXJ0TWFya2VyLm9mZnNldClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGkgKyAxLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBzdGFydE1hcmtlci5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0TWFya2VyLmNvbHVtbiArIChpIC0gc3RhcnRNYXJrZXIub2Zmc2V0KSArIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcmtlclNlcXVlbmNlKHRoaXMuYnVmZmVyLCBzdGFydE1hcmtlcnMsIGVuZE1hcmtlcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVNYXJrZXJTZXF1ZW5jZTtcbn0oTWFya2VyU2VxdWVuY2UpKTtcbnZhciBDaGFyQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJDaGFuZ2Uob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxTdGFydENvbHVtbjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRDb2x1bW4gPSBvcmlnaW5hbEVuZENvbHVtbjtcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRDb2x1bW4gPSBtb2RpZmllZFN0YXJ0Q29sdW1uO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZENvbHVtbiA9IG1vZGlmaWVkRW5kQ29sdW1uO1xuICAgIH1cbiAgICBDaGFyQ2hhbmdlLmNyZWF0ZUZyb21EaWZmQ2hhbmdlID0gZnVuY3Rpb24gKGRpZmZDaGFuZ2UsIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHZhciBvcmlnaW5hbFN0YXJ0Q29sdW1uO1xuICAgICAgICB2YXIgb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgb3JpZ2luYWxFbmRDb2x1bW47XG4gICAgICAgIHZhciBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdmFyIG1vZGlmaWVkU3RhcnRDb2x1bW47XG4gICAgICAgIHZhciBtb2RpZmllZEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHZhciBtb2RpZmllZEVuZENvbHVtbjtcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0U3RhcnRDb2x1bW4oZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW4gPSBvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRFbmRDb2x1bW4oZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IDA7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0Q29sdW1uID0gMDtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IDA7XG4gICAgICAgICAgICBtb2RpZmllZEVuZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xuICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XG4gICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0RW5kQ29sdW1uKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYXJDaGFuZ2Uob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFyQ2hhbmdlO1xufSgpKTtcbmZ1bmN0aW9uIHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcykge1xuICAgIGlmIChyYXdDaGFuZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiByYXdDaGFuZ2VzO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW3Jhd0NoYW5nZXNbMF1dO1xuICAgIHZhciBwcmV2Q2hhbmdlID0gcmVzdWx0WzBdO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyQ2hhbmdlID0gcmF3Q2hhbmdlc1tpXTtcbiAgICAgICAgdmFyIG9yaWdpbmFsTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm9yaWdpbmFsU3RhcnQgLSAocHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCk7XG4gICAgICAgIHZhciBtb2RpZmllZE1hdGNoaW5nTGVuZ3RoID0gY3VyckNoYW5nZS5tb2RpZmllZFN0YXJ0IC0gKHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydCArIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xuICAgICAgICAvLyBCb3RoIG9mIHRoZSBhYm92ZSBzaG91bGQgYmUgZXF1YWwsIGJ1dCB0aGUgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlIG1heSBwcmV2ZW50IHRoaXMgZnJvbSBiZWluZyB0cnVlXG4gICAgICAgIHZhciBtYXRjaGluZ0xlbmd0aCA9IE1hdGgubWluKG9yaWdpbmFsTWF0Y2hpbmdMZW5ndGgsIG1vZGlmaWVkTWF0Y2hpbmdMZW5ndGgpO1xuICAgICAgICBpZiAobWF0Y2hpbmdMZW5ndGggPCBNSU5JTVVNX01BVENISU5HX0NIQVJBQ1RFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBjdXJyZW50IGNoYW5nZSBpbnRvIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgICAgIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSAoY3VyckNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY3VyckNoYW5nZS5vcmlnaW5hbExlbmd0aCkgLSBwcmV2Q2hhbmdlLm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm1vZGlmaWVkTGVuZ3RoID0gKGN1cnJDaGFuZ2UubW9kaWZpZWRTdGFydCArIGN1cnJDaGFuZ2UubW9kaWZpZWRMZW5ndGgpIC0gcHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBjdXJyZW50IGNoYW5nZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyckNoYW5nZSk7XG4gICAgICAgICAgICBwcmV2Q2hhbmdlID0gY3VyckNoYW5nZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIExpbmVDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZUNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmNoYXJDaGFuZ2VzID0gY2hhckNoYW5nZXM7XG4gICAgfVxuICAgIExpbmVDaGFuZ2UuY3JlYXRlRnJvbURpZmZSZXN1bHQgPSBmdW5jdGlvbiAoZGlmZkNoYW5nZSwgb3JpZ2luYWxMaW5lU2VxdWVuY2UsIG1vZGlmaWVkTGluZVNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUsIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xuICAgICAgICB2YXIgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHZhciBtb2RpZmllZEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHZhciBjaGFyQ2hhbmdlcztcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCkgLSAxO1xuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRFbmRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KSAtIDE7XG4gICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoICE9PSAwICYmIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggIT09IDAgJiYgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKCkpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbENoYXJTZXF1ZW5jZSA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldENoYXJTZXF1ZW5jZShkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHZhciBtb2RpZmllZENoYXJTZXF1ZW5jZSA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldENoYXJTZXF1ZW5jZShkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQsIGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCArIGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHZhciByYXdDaGFuZ2VzID0gY29tcHV0ZURpZmYob3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmF3Q2hhbmdlcyA9IHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFyQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8yID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGhfMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hhckNoYW5nZXMucHVzaChDaGFyQ2hhbmdlLmNyZWF0ZUZyb21EaWZmQ2hhbmdlKHJhd0NoYW5nZXNbaV0sIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZUNoYW5nZTtcbn0oKSk7XG52YXIgRGlmZkNvbXB1dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpZmZDb21wdXRlcihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcztcbiAgICAgICAgdGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSA9IG9wdHMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2U7XG4gICAgICAgIHRoaXMuc2hvdWxkTWFrZVByZXR0eURpZmYgPSBvcHRzLnNob3VsZE1ha2VQcmV0dHlEaWZmO1xuICAgICAgICB0aGlzLm1heGltdW1SdW5UaW1lTXMgPSBNQVhJTVVNX1JVTl9USU1FO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTGluZXMgPSBvcmlnaW5hbExpbmVzO1xuICAgICAgICB0aGlzLm1vZGlmaWVkTGluZXMgPSBtb2RpZmllZExpbmVzO1xuICAgICAgICB0aGlzLm9yaWdpbmFsID0gbmV3IExpbmVNYXJrZXJTZXF1ZW5jZShvcmlnaW5hbExpbmVzKTtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG5ldyBMaW5lTWFya2VyU2VxdWVuY2UobW9kaWZpZWRMaW5lcyk7XG4gICAgfVxuICAgIERpZmZDb21wdXRlci5wcm90b3R5cGUuY29tcHV0ZURpZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbmFsLmdldExlbmd0aCgpID09PSAxICYmIHRoaXMub3JpZ2luYWwuZ2V0RWxlbWVudEhhc2goMCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBvcmlnaW5hbCA9PiBmYXN0IHBhdGhcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyOiB0aGlzLm1vZGlmaWVkLmdldExlbmd0aCgpLFxuICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZENvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZENvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RpZmllZC5nZXRMZW5ndGgoKSA9PT0gMSAmJiB0aGlzLm1vZGlmaWVkLmdldEVsZW1lbnRIYXNoKDApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbW9kaWZpZWQgPT4gZmFzdCBwYXRoXG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlcjogdGhpcy5vcmlnaW5hbC5nZXRMZW5ndGgoKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgY2hhckNoYW5nZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wdXRhdGlvblN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciByYXdDaGFuZ2VzID0gY29tcHV0ZURpZmYodGhpcy5vcmlnaW5hbCwgdGhpcy5tb2RpZmllZCwgdGhpcy5fY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlLmJpbmQodGhpcyksIHRoaXMuc2hvdWxkTWFrZVByZXR0eURpZmYpO1xuICAgICAgICAvLyBUaGUgZGlmZiBpcyBhbHdheXMgY29tcHV0ZWQgd2l0aCBpZ25vcmluZyB0cmltIHdoaXRlc3BhY2VcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGdldCB0aGUgcHJldHRpZXN0IGRpZmZcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBsaW5lQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8zID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGhfMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZUNoYW5nZXMucHVzaChMaW5lQ2hhbmdlLmNyZWF0ZUZyb21EaWZmUmVzdWx0KHJhd0NoYW5nZXNbaV0sIHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZS5iaW5kKHRoaXMpLCB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lQ2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWVkIHRvIHBvc3QtcHJvY2VzcyBhbmQgaW50cm9kdWNlIGNoYW5nZXMgd2hlcmUgdGhlIHRyaW0gd2hpdGVzcGFjZSBpcyBkaWZmZXJlbnRcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFyZSBsb29waW5nIHN0YXJ0aW5nIGF0IC0xIHRvIGFsc28gY292ZXIgdGhlIGxpbmVzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZUluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1vZGlmaWVkTGluZUluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IC0xIC8qICEhISEgKi8sIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhbmdlID0gKGkgKyAxIDwgbGVuID8gcmF3Q2hhbmdlc1tpICsgMV0gOiBudWxsKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFN0b3AgPSAobmV4dENoYW5nZSA/IG5leHRDaGFuZ2Uub3JpZ2luYWxTdGFydCA6IHRoaXMub3JpZ2luYWxMaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIG1vZGlmaWVkU3RvcCA9IChuZXh0Q2hhbmdlID8gbmV4dENoYW5nZS5tb2RpZmllZFN0YXJ0IDogdGhpcy5tb2RpZmllZExpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxMaW5lSW5kZXggPCBvcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRMaW5lSW5kZXggPCBtb2RpZmllZFN0b3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gdGhpcy5vcmlnaW5hbExpbmVzW29yaWdpbmFsTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRMaW5lID0gdGhpcy5tb2RpZmllZExpbmVzW21vZGlmaWVkTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxMaW5lICE9PSBtb2RpZmllZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgbGluZXMgZGlmZmVyIG9ubHkgaW4gdHJpbSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3RhcnRDb2x1bW4gPSBMaW5lTWFya2VyU2VxdWVuY2UuX2dldEZpcnN0Tm9uQmxhbmtDb2x1bW4ob3JpZ2luYWxMaW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZFN0YXJ0Q29sdW1uID0gTGluZU1hcmtlclNlcXVlbmNlLl9nZXRGaXJzdE5vbkJsYW5rQ29sdW1uKG1vZGlmaWVkTGluZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydENvbHVtbiA+IDEgJiYgbW9kaWZpZWRTdGFydENvbHVtbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQob3JpZ2luYWxTdGFydENvbHVtbiAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZENoYXIgPSBtb2RpZmllZExpbmUuY2hhckNvZGVBdChtb2RpZmllZFN0YXJ0Q29sdW1uIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ2hhciAhPT0gbW9kaWZpZWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnRDb2x1bW4gPiAxIHx8IG1vZGlmaWVkU3RhcnRDb2x1bW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgMSwgb3JpZ2luYWxTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lSW5kZXggKyAxLCAxLCBtb2RpZmllZFN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFbmRDb2x1bW4gPSBMaW5lTWFya2VyU2VxdWVuY2UuX2dldExhc3ROb25CbGFua0NvbHVtbihvcmlnaW5hbExpbmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkRW5kQ29sdW1uID0gTGluZU1hcmtlclNlcXVlbmNlLl9nZXRMYXN0Tm9uQmxhbmtDb2x1bW4obW9kaWZpZWRMaW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbE1heENvbHVtbiA9IG9yaWdpbmFsTGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkTWF4Q29sdW1uID0gbW9kaWZpZWRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxFbmRDb2x1bW4gPCBvcmlnaW5hbE1heENvbHVtbiAmJiBtb2RpZmllZEVuZENvbHVtbiA8IG1vZGlmaWVkTWF4Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG9yaWdpbmFsRW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG1vZGlmaWVkRW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ2hhciAhPT0gbW9kaWZpZWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZENvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxFbmRDb2x1bW4gPCBvcmlnaW5hbE1heENvbHVtbiB8fCBtb2RpZmllZEVuZENvbHVtbiA8IG1vZGlmaWVkTWF4Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgb3JpZ2luYWxFbmRDb2x1bW4sIG9yaWdpbmFsTWF4Q29sdW1uLCBtb2RpZmllZExpbmVJbmRleCArIDEsIG1vZGlmaWVkRW5kQ29sdW1uLCBtb2RpZmllZE1heENvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMaW5lSW5kZXgrKztcbiAgICAgICAgICAgICAgICBtb2RpZmllZExpbmVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBFbWl0IHRoZSBhY3R1YWwgY2hhbmdlXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTGluZUNoYW5nZS5jcmVhdGVGcm9tRGlmZlJlc3VsdChuZXh0Q2hhbmdlLCB0aGlzLm9yaWdpbmFsLCB0aGlzLm1vZGlmaWVkLCB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUuYmluZCh0aGlzKSwgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMaW5lSW5kZXggKz0gbmV4dENoYW5nZS5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgICAgICBtb2RpZmllZExpbmVJbmRleCArPSBuZXh0Q2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBEaWZmQ29tcHV0ZXIucHJvdG90eXBlLl9wdXNoVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlID0gZnVuY3Rpb24gKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5fbWVyZ2VUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSkge1xuICAgICAgICAgICAgLy8gTWVyZ2VkIGludG8gcHJldmlvdXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZUNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsTGluZU51bWJlciwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVOdW1iZXIsIFtcbiAgICAgICAgICAgIG5ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKVxuICAgICAgICBdKSk7XG4gICAgfTtcbiAgICBEaWZmQ29tcHV0ZXIucHJvdG90eXBlLl9tZXJnZVRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZSA9IGZ1bmN0aW9uIChyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcbiAgICAgICAgdmFyIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoYW5nZSA9IHJlc3VsdFtsZW4gLSAxXTtcbiAgICAgICAgaWYgKHByZXZDaGFuZ2Uub3JpZ2luYWxFbmRMaW5lTnVtYmVyID09PSAwIHx8IHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBtZXJnZSB3aXRoIGluc2VydHMvZGVsZXRlc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciArIDEgPT09IG9yaWdpbmFsTGluZU51bWJlciAmJiBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciArIDEgPT09IG1vZGlmaWVkTGluZU51bWJlcikge1xuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVOdW1iZXI7XG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZU51bWJlcjtcbiAgICAgICAgICAgIHByZXZDaGFuZ2UuY2hhckNoYW5nZXMucHVzaChuZXcgQ2hhckNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbikpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRGlmZkNvbXB1dGVyLnByb3RvdHlwZS5fY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXhpbXVtUnVuVGltZU1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIG5vdyAtIHRoaXMuY29tcHV0YXRpb25TdGFydFRpbWUgPCB0aGlzLm1heGltdW1SdW5UaW1lTXM7XG4gICAgfTtcbiAgICByZXR1cm4gRGlmZkNvbXB1dGVyO1xufSgpKTtcbmV4cG9ydCB7IERpZmZDb21wdXRlciB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js ***!
  \**********************************************************************************/
/*! exports provided: MirrorTextModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MirrorTextModel\", function() { return MirrorTextModel; });\n/* harmony import */ var _viewModel_prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../viewModel/prefixSumComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nvar MirrorTextModel = /** @class */ (function () {\n    function MirrorTextModel(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n    }\n    MirrorTextModel.prototype.dispose = function () {\n        this._lines.length = 0;\n    };\n    Object.defineProperty(MirrorTextModel.prototype, \"version\", {\n        get: function () {\n            return this._versionId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MirrorTextModel.prototype.getText = function () {\n        return this._lines.join(this._eol);\n    };\n    MirrorTextModel.prototype.onEvents = function (e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        var changes = e.changes;\n        for (var i = 0, len = changes.length; i < len; i++) {\n            var change = changes[i];\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_1__[\"Position\"](change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n    };\n    MirrorTextModel.prototype._ensureLineStarts = function () {\n        if (!this._lineStarts) {\n            var eolLength = this._eol.length;\n            var linesLength = this._lines.length;\n            var lineStartValues = new Uint32Array(linesLength);\n            for (var i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new _viewModel_prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_0__[\"PrefixSumComputer\"](lineStartValues);\n        }\n    };\n    /**\n     * All changes to a line's text go through this method\n     */\n    MirrorTextModel.prototype._setLineText = function (lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    };\n    MirrorTextModel.prototype._acceptDeleteRange = function (range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    };\n    MirrorTextModel.prototype._acceptInsertText = function (position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        var insertLines = insertText.split(/\\r\\n|\\r|\\n/);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        var newLengths = new Uint32Array(insertLines.length - 1);\n        for (var i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    };\n    return MirrorTextModel;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanM/YTQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IFByZWZpeFN1bUNvbXB1dGVyIH0gZnJvbSAnLi4vdmlld01vZGVsL3ByZWZpeFN1bUNvbXB1dGVyLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG52YXIgTWlycm9yVGV4dE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1pcnJvclRleHRNb2RlbCh1cmksIGxpbmVzLCBlb2wsIHZlcnNpb25JZCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuX2VvbCA9IGVvbDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gdmVyc2lvbklkO1xuICAgIH1cbiAgICBNaXJyb3JUZXh0TW9kZWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWlycm9yVGV4dE1vZGVsLnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbklkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNaXJyb3JUZXh0TW9kZWwucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5qb2luKHRoaXMuX2VvbCk7XG4gICAgfTtcbiAgICBNaXJyb3JUZXh0TW9kZWwucHJvdG90eXBlLm9uRXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZW9sICYmIGUuZW9sICE9PSB0aGlzLl9lb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX2VvbCA9IGUuZW9sO1xuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIG15IGxpbmVzXG4gICAgICAgIHZhciBjaGFuZ2VzID0gZS5jaGFuZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICB0aGlzLl9hY2NlcHREZWxldGVSYW5nZShjaGFuZ2UucmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5fYWNjZXB0SW5zZXJ0VGV4dChuZXcgUG9zaXRpb24oY2hhbmdlLnJhbmdlLnN0YXJ0TGluZU51bWJlciwgY2hhbmdlLnJhbmdlLnN0YXJ0Q29sdW1uKSwgY2hhbmdlLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlcnNpb25JZCA9IGUudmVyc2lvbklkO1xuICAgIH07XG4gICAgTWlycm9yVGV4dE1vZGVsLnByb3RvdHlwZS5fZW5zdXJlTGluZVN0YXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZW9sTGVuZ3RoID0gdGhpcy5fZW9sLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsaW5lc0xlbmd0aCA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsaW5lU3RhcnRWYWx1ZXMgPSBuZXcgVWludDMyQXJyYXkobGluZXNMZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0VmFsdWVzW2ldID0gdGhpcy5fbGluZXNbaV0ubGVuZ3RoICsgZW9sTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG5ldyBQcmVmaXhTdW1Db21wdXRlcihsaW5lU3RhcnRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGwgY2hhbmdlcyB0byBhIGxpbmUncyB0ZXh0IGdvIHRocm91Z2ggdGhpcyBtZXRob2RcbiAgICAgKi9cbiAgICBNaXJyb3JUZXh0TW9kZWwucHJvdG90eXBlLl9zZXRMaW5lVGV4dCA9IGZ1bmN0aW9uIChsaW5lSW5kZXgsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVTdGFydHMpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLmNoYW5nZVZhbHVlKGxpbmVJbmRleCwgdGhpcy5fbGluZXNbbGluZUluZGV4XS5sZW5ndGggKyB0aGlzLl9lb2wubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWlycm9yVGV4dE1vZGVsLnByb3RvdHlwZS5fYWNjZXB0RGVsZXRlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRlbGV0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSB0ZXh0IG9uIHRoZSBhZmZlY3RlZCBsaW5lXG4gICAgICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKVxuICAgICAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUYWtlIHJlbWFpbmluZyB0ZXh0IG9uIGxhc3QgbGluZSBhbmQgYXBwZW5kIGl0IHRvIHJlbWFpbmluZyB0ZXh0IG9uIGZpcnN0IGxpbmVcbiAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSlcbiAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcmFuZ2UuZW5kTGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5lbmRDb2x1bW4gLSAxKSk7XG4gICAgICAgIC8vIERlbGV0ZSBtaWRkbGUgbGluZXNcbiAgICAgICAgdGhpcy5fbGluZXMuc3BsaWNlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlciAtIHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cy5yZW1vdmVWYWx1ZXMocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWlycm9yVGV4dE1vZGVsLnByb3RvdHlwZS5fYWNjZXB0SW5zZXJ0VGV4dCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgaW5zZXJ0VGV4dCkge1xuICAgICAgICBpZiAoaW5zZXJ0VGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gaW5zZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc2VydExpbmVzID0gaW5zZXJ0VGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbiAgICAgICAgaWYgKGluc2VydExpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW5nIHRleHQgb24gb25lIGxpbmVcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXG4gICAgICAgICAgICAgICAgKyBpbnNlcnRMaW5lc1swXVxuICAgICAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIG92ZXJmbG93aW5nIHRleHQgZnJvbSBmaXJzdCBsaW5lIHRvIHRoZSBlbmQgb2YgdGV4dCB0byBpbnNlcnRcbiAgICAgICAgaW5zZXJ0TGluZXNbaW5zZXJ0TGluZXMubGVuZ3RoIC0gMV0gKz0gdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICAgICAgLy8gRGVsZXRlIG92ZXJmbG93aW5nIHRleHQgZnJvbSBmaXJzdCBsaW5lIGFuZCBpbnNlcnQgdGV4dCBvbiBmaXJzdCBsaW5lXG4gICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXG4gICAgICAgICAgICArIGluc2VydExpbmVzWzBdKTtcbiAgICAgICAgLy8gSW5zZXJ0IG5ldyBsaW5lcyAmIHN0b3JlIGxlbmd0aHNcbiAgICAgICAgdmFyIG5ld0xlbmd0aHMgPSBuZXcgVWludDMyQXJyYXkoaW5zZXJ0TGluZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaW5zZXJ0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnNwbGljZShwb3NpdGlvbi5saW5lTnVtYmVyICsgaSAtIDEsIDAsIGluc2VydExpbmVzW2ldKTtcbiAgICAgICAgICAgIG5ld0xlbmd0aHNbaSAtIDFdID0gaW5zZXJ0TGluZXNbaV0ubGVuZ3RoICsgdGhpcy5fZW9sLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHByZWZpeCBzdW1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuaW5zZXJ0VmFsdWVzKHBvc2l0aW9uLmxpbmVOdW1iZXIsIG5ld0xlbmd0aHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWlycm9yVGV4dE1vZGVsO1xufSgpKTtcbmV4cG9ydCB7IE1pcnJvclRleHRNb2RlbCB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js ***!
  \*****************************************************************************/
/*! exports provided: USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, ensureValidWordDefinition, getWordAtText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"USUAL_WORD_SEPARATORS\", function() { return USUAL_WORD_SEPARATORS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_WORD_REGEXP\", function() { return DEFAULT_WORD_REGEXP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ensureValidWordDefinition\", function() { return ensureValidWordDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getWordAtText\", function() { return getWordAtText; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords) {\n    if (allowInWords === void 0) { allowInWords = ''; }\n    var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (var i = 0; i < USUAL_WORD_SEPARATORS.length; i++) {\n        if (allowInWords.indexOf(USUAL_WORD_SEPARATORS[i]) >= 0) {\n            continue;\n        }\n        source += '\\\\' + USUAL_WORD_SEPARATORS[i];\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nvar DEFAULT_WORD_REGEXP = createWordRegExp();\nfunction ensureValidWordDefinition(wordDefinition) {\n    var result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            var flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\n    // find whitespace enclosed text around column and match from there\n    var pos = column - 1 - textOffset;\n    var start = text.lastIndexOf(' ', pos - 1) + 1;\n    var end = text.indexOf(' ', pos);\n    if (end === -1) {\n        end = text.length;\n    }\n    wordDefinition.lastIndex = start;\n    var match;\n    while (match = wordDefinition.exec(text)) {\n        if (match.index <= pos && wordDefinition.lastIndex >= pos) {\n            return {\n                word: match[0],\n                startColumn: textOffset + 1 + match.index,\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\n            };\n        }\n    }\n    return null;\n}\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\n    // matches all words starting at the beginning\n    // of the input until it finds a match that encloses\n    // the desired column. slow but correct\n    var pos = column - 1 - textOffset;\n    wordDefinition.lastIndex = 0;\n    var match;\n    while (match = wordDefinition.exec(text)) {\n        if (match.index > pos) {\n            // |nW -> matched only after the pos\n            return null;\n        }\n        else if (wordDefinition.lastIndex >= pos) {\n            // W|W -> match encloses pos\n            return {\n                word: match[0],\n                startColumn: textOffset + 1 + match.index,\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\n            };\n        }\n    }\n    return null;\n}\nfunction getWordAtText(column, wordDefinition, text, textOffset) {\n    // if `words` can contain whitespace character we have to use the slow variant\n    // otherwise we use the fast variant of finding a word\n    wordDefinition.lastIndex = 0;\n    var match = wordDefinition.exec(text);\n    if (!match) {\n        return null;\n    }\n    // todo@joh the `match` could already be the (first) word\n    var ret = match[0].indexOf(' ') >= 0\n        // did match a word which contains a space character -> use slow word find\n        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\n        // sane word definition -> use fast word find\n        : getWordAtPosFast(column, wordDefinition, text, textOffset);\n    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\n    // in an undefined state and to not confuse other users of the wordDefinition\n    // we reset the lastIndex\n    wordDefinition.lastIndex = 0;\n    return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC93b3JkSGVscGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvd29yZEhlbHBlci5qcz9kMDkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuZXhwb3J0IHZhciBVU1VBTF9XT1JEX1NFUEFSQVRPUlMgPSAnYH4hQCMkJV4mKigpLT0rW3tdfVxcXFx8OzpcXCdcIiwuPD4vPyc7XG4vKipcbiAqIENyZWF0ZSBhIHdvcmQgZGVmaW5pdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gYmFzZWQgb24gZGVmYXVsdCB3b3JkIHNlcGFyYXRvcnMuXG4gKiBPcHRpb25hbGx5IHByb3ZpZGUgYWxsb3dlZCBzZXBhcmF0b3JzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHdvcmRzLlxuICpcbiAqIFRoZSBkZWZhdWx0IHdvdWxkIGxvb2sgbGlrZSB0aGlzOlxuICogLygtP1xcZCpcXC5cXGRcXHcqKXwoW15cXGBcXH5cXCFcXEBcXCNcXCRcXCVcXF5cXCZcXCpcXChcXClcXC1cXD1cXCtcXFtcXHtcXF1cXH1cXFxcXFx8XFw7XFw6XFwnXFxcIlxcLFxcLlxcPFxcPlxcL1xcP1xcc10rKS9nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdvcmRSZWdFeHAoYWxsb3dJbldvcmRzKSB7XG4gICAgaWYgKGFsbG93SW5Xb3JkcyA9PT0gdm9pZCAwKSB7IGFsbG93SW5Xb3JkcyA9ICcnOyB9XG4gICAgdmFyIHNvdXJjZSA9ICcoLT9cXFxcZCpcXFxcLlxcXFxkXFxcXHcqKXwoW14nO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVVNVQUxfV09SRF9TRVBBUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbGxvd0luV29yZHMuaW5kZXhPZihVU1VBTF9XT1JEX1NFUEFSQVRPUlNbaV0pID49IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSArPSAnXFxcXCcgKyBVU1VBTF9XT1JEX1NFUEFSQVRPUlNbaV07XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxcXHNdKyknO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbn1cbi8vIGNhdGNoZXMgbnVtYmVycyAoaW5jbHVkaW5nIGZsb2F0aW5nIG51bWJlcnMpIGluIHRoZSBmaXJzdCBncm91cCwgYW5kIGFscGhhbnVtIGluIHRoZSBzZWNvbmRcbmV4cG9ydCB2YXIgREVGQVVMVF9XT1JEX1JFR0VYUCA9IGNyZWF0ZVdvcmRSZWdFeHAoKTtcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKSB7XG4gICAgdmFyIHJlc3VsdCA9IERFRkFVTFRfV09SRF9SRUdFWFA7XG4gICAgaWYgKHdvcmREZWZpbml0aW9uICYmICh3b3JkRGVmaW5pdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgaWYgKCF3b3JkRGVmaW5pdGlvbi5nbG9iYWwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9ICdnJztcbiAgICAgICAgICAgIGlmICh3b3JkRGVmaW5pdGlvbi5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLm11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgIGZsYWdzICs9ICdtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAod29yZERlZmluaXRpb24uc291cmNlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB3b3JkRGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0V29yZEF0UG9zRmFzdChjb2x1bW4sIHdvcmREZWZpbml0aW9uLCB0ZXh0LCB0ZXh0T2Zmc2V0KSB7XG4gICAgLy8gZmluZCB3aGl0ZXNwYWNlIGVuY2xvc2VkIHRleHQgYXJvdW5kIGNvbHVtbiBhbmQgbWF0Y2ggZnJvbSB0aGVyZVxuICAgIHZhciBwb3MgPSBjb2x1bW4gLSAxIC0gdGV4dE9mZnNldDtcbiAgICB2YXIgc3RhcnQgPSB0ZXh0Lmxhc3RJbmRleE9mKCcgJywgcG9zIC0gMSkgKyAxO1xuICAgIHZhciBlbmQgPSB0ZXh0LmluZGV4T2YoJyAnLCBwb3MpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIGVuZCA9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSBzdGFydDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKG1hdGNoID0gd29yZERlZmluaXRpb24uZXhlYyh0ZXh0KSkge1xuICAgICAgICBpZiAobWF0Y2guaW5kZXggPD0gcG9zICYmIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd29yZDogbWF0Y2hbMF0sXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFdvcmRBdFBvc1Nsb3coY29sdW1uLCB3b3JkRGVmaW5pdGlvbiwgdGV4dCwgdGV4dE9mZnNldCkge1xuICAgIC8vIG1hdGNoZXMgYWxsIHdvcmRzIHN0YXJ0aW5nIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAvLyBvZiB0aGUgaW5wdXQgdW50aWwgaXQgZmluZHMgYSBtYXRjaCB0aGF0IGVuY2xvc2VzXG4gICAgLy8gdGhlIGRlc2lyZWQgY29sdW1uLiBzbG93IGJ1dCBjb3JyZWN0XG4gICAgdmFyIHBvcyA9IGNvbHVtbiAtIDEgLSB0ZXh0T2Zmc2V0O1xuICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoO1xuICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWModGV4dCkpIHtcbiAgICAgICAgaWYgKG1hdGNoLmluZGV4ID4gcG9zKSB7XG4gICAgICAgICAgICAvLyB8blcgLT4gbWF0Y2hlZCBvbmx5IGFmdGVyIHRoZSBwb3NcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAgIC8vIFd8VyAtPiBtYXRjaCBlbmNsb3NlcyBwb3NcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd29yZDogbWF0Y2hbMF0sXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JkQXRUZXh0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQpIHtcbiAgICAvLyBpZiBgd29yZHNgIGNhbiBjb250YWluIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHdlIGhhdmUgdG8gdXNlIHRoZSBzbG93IHZhcmlhbnRcbiAgICAvLyBvdGhlcndpc2Ugd2UgdXNlIHRoZSBmYXN0IHZhcmlhbnQgb2YgZmluZGluZyBhIHdvcmRcbiAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWModGV4dCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gdG9kb0Bqb2ggdGhlIGBtYXRjaGAgY291bGQgYWxyZWFkeSBiZSB0aGUgKGZpcnN0KSB3b3JkXG4gICAgdmFyIHJldCA9IG1hdGNoWzBdLmluZGV4T2YoJyAnKSA+PSAwXG4gICAgICAgIC8vIGRpZCBtYXRjaCBhIHdvcmQgd2hpY2ggY29udGFpbnMgYSBzcGFjZSBjaGFyYWN0ZXIgLT4gdXNlIHNsb3cgd29yZCBmaW5kXG4gICAgICAgID8gZ2V0V29yZEF0UG9zU2xvdyhjb2x1bW4sIHdvcmREZWZpbml0aW9uLCB0ZXh0LCB0ZXh0T2Zmc2V0KVxuICAgICAgICAvLyBzYW5lIHdvcmQgZGVmaW5pdGlvbiAtPiB1c2UgZmFzdCB3b3JkIGZpbmRcbiAgICAgICAgOiBnZXRXb3JkQXRQb3NGYXN0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQpO1xuICAgIC8vIGJvdGggKGdldFdvcmRBdFBvc0Zhc3QgYW5kIGdldFdvcmRBdFBvc1Nsb3cpIGxlYXZlIHRoZSB3b3JkRGVmaW5pdGlvbi1SZWdFeHBcbiAgICAvLyBpbiBhbiB1bmRlZmluZWQgc3RhdGUgYW5kIHRvIG5vdCBjb25mdXNlIG90aGVyIHVzZXJzIG9mIHRoZSB3b3JkRGVmaW5pdGlvblxuICAgIC8vIHdlIHJlc2V0IHRoZSBsYXN0SW5kZXhcbiAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiByZXQ7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js ***!
  \*******************************************************************************/
/*! exports provided: computeLinks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeLinks\", function() { return computeLinks; });\n/* harmony import */ var _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/characterClassifier.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\");\n/* harmony import */ var _core_uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/uint.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/uint.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nvar StateMachine = /** @class */ (function () {\n    function StateMachine(edges) {\n        var maxCharCode = 0;\n        var maxState = 0 /* Invalid */;\n        for (var i = 0, len = edges.length; i < len; i++) {\n            var _a = edges[i], from = _a[0], chCode = _a[1], to = _a[2];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        var states = new _core_uint_js__WEBPACK_IMPORTED_MODULE_1__[\"Uint8Matrix\"](maxState, maxCharCode, 0 /* Invalid */);\n        for (var i = 0, len = edges.length; i < len; i++) {\n            var _b = edges[i], from = _b[0], chCode = _b[1], to = _b[2];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    StateMachine.prototype.nextState = function (currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    };\n    return StateMachine;\n}());\n// State machine for http:// or https:// or file://\nvar _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* Start */, 104 /* h */, 2 /* H */],\n            [1 /* Start */, 72 /* H */, 2 /* H */],\n            [1 /* Start */, 102 /* f */, 6 /* F */],\n            [1 /* Start */, 70 /* F */, 6 /* F */],\n            [2 /* H */, 116 /* t */, 3 /* HT */],\n            [2 /* H */, 84 /* T */, 3 /* HT */],\n            [3 /* HT */, 116 /* t */, 4 /* HTT */],\n            [3 /* HT */, 84 /* T */, 4 /* HTT */],\n            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],\n            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],\n            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],\n            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],\n            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],\n            [6 /* F */, 105 /* i */, 7 /* FI */],\n            [6 /* F */, 73 /* I */, 7 /* FI */],\n            [7 /* FI */, 108 /* l */, 8 /* FIL */],\n            [7 /* FI */, 76 /* L */, 8 /* FIL */],\n            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],\n            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],\n            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],\n            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],\n            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],\n        ]);\n    }\n    return _stateMachine;\n}\nvar _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__[\"CharacterClassifier\"](0 /* None */);\n        var FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；？！＠＃＄％＆＊‘“〈《「『【〔（［｛｢｣｝］）〕】』」》〉”’｀～…';\n        for (var i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);\n        }\n        var CANNOT_END_WITH_CHARACTERS = '.,;';\n        for (var i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nvar LinkComputer = /** @class */ (function () {\n    function LinkComputer() {\n    }\n    LinkComputer._createLink = function (classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        var lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            var chCode = line.charCodeAt(lastIncludedCharIndex);\n            var chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            var charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            var lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)\n                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    };\n    LinkComputer.computeLinks = function (model) {\n        var stateMachine = getStateMachine();\n        var classifier = getClassifier();\n        var result = [];\n        for (var i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            var line = model.getLineContent(i);\n            var len = line.length;\n            var j = 0;\n            var linkBeginIndex = 0;\n            var linkBeginChCode = 0;\n            var state = 1 /* Start */;\n            var hasOpenParens = false;\n            var hasOpenSquareBracket = false;\n            var hasOpenCurlyBracket = false;\n            while (j < len) {\n                var resetStateMachine = false;\n                var chCode = line.charCodeAt(j);\n                if (state === 13 /* Accept */) {\n                    var chClass = void 0;\n                    switch (chCode) {\n                        case 40 /* OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 41 /* CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        case 91 /* OpenSquareBracket */:\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 93 /* CloseSquareBracket */:\n                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        case 123 /* OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 125 /* CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        /* The following three rules make it that ' or \" or ` are allowed inside links if the link began with a different one */\n                        case 39 /* SingleQuote */:\n                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 34 /* DoubleQuote */:\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 96 /* BackTick */:\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* End */) {\n                    var chClass = classifier.get(chCode);\n                    // Check if character terminates link\n                    if (chClass === 1 /* ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    };\n    return LinkComputer;\n}());\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nfunction computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9saW5rQ29tcHV0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9saW5rQ29tcHV0ZXIuanM/MzgzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuLi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xuaW1wb3J0IHsgVWludDhNYXRyaXggfSBmcm9tICcuLi9jb3JlL3VpbnQuanMnO1xudmFyIFN0YXRlTWFjaGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hY2hpbmUoZWRnZXMpIHtcbiAgICAgICAgdmFyIG1heENoYXJDb2RlID0gMDtcbiAgICAgICAgdmFyIG1heFN0YXRlID0gMCAvKiBJbnZhbGlkICovO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWRnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGVkZ2VzW2ldLCBmcm9tID0gX2FbMF0sIGNoQ29kZSA9IF9hWzFdLCB0byA9IF9hWzJdO1xuICAgICAgICAgICAgaWYgKGNoQ29kZSA+IG1heENoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgbWF4Q2hhckNvZGUgPSBjaENvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG1heFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbWF4U3RhdGUgPSBmcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvID4gbWF4U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBtYXhTdGF0ZSA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heENoYXJDb2RlKys7XG4gICAgICAgIG1heFN0YXRlKys7XG4gICAgICAgIHZhciBzdGF0ZXMgPSBuZXcgVWludDhNYXRyaXgobWF4U3RhdGUsIG1heENoYXJDb2RlLCAwIC8qIEludmFsaWQgKi8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWRnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfYiA9IGVkZ2VzW2ldLCBmcm9tID0gX2JbMF0sIGNoQ29kZSA9IF9iWzFdLCB0byA9IF9iWzJdO1xuICAgICAgICAgICAgc3RhdGVzLnNldChmcm9tLCBjaENvZGUsIHRvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuX21heENoYXJDb2RlID0gbWF4Q2hhckNvZGU7XG4gICAgfVxuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUubmV4dFN0YXRlID0gZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgY2hDb2RlKSB7XG4gICAgICAgIGlmIChjaENvZGUgPCAwIHx8IGNoQ29kZSA+PSB0aGlzLl9tYXhDaGFyQ29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogSW52YWxpZCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmdldChjdXJyZW50U3RhdGUsIGNoQ29kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYWNoaW5lO1xufSgpKTtcbi8vIFN0YXRlIG1hY2hpbmUgZm9yIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gb3IgZmlsZTovL1xudmFyIF9zdGF0ZU1hY2hpbmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3RhdGVNYWNoaW5lKCkge1xuICAgIGlmIChfc3RhdGVNYWNoaW5lID09PSBudWxsKSB7XG4gICAgICAgIF9zdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKFtcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCAxMDQgLyogaCAqLywgMiAvKiBIICovXSxcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCA3MiAvKiBIICovLCAyIC8qIEggKi9dLFxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDEwMiAvKiBmICovLCA2IC8qIEYgKi9dLFxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDcwIC8qIEYgKi8sIDYgLyogRiAqL10sXG4gICAgICAgICAgICBbMiAvKiBIICovLCAxMTYgLyogdCAqLywgMyAvKiBIVCAqL10sXG4gICAgICAgICAgICBbMiAvKiBIICovLCA4NCAvKiBUICovLCAzIC8qIEhUICovXSxcbiAgICAgICAgICAgIFszIC8qIEhUICovLCAxMTYgLyogdCAqLywgNCAvKiBIVFQgKi9dLFxuICAgICAgICAgICAgWzMgLyogSFQgKi8sIDg0IC8qIFQgKi8sIDQgLyogSFRUICovXSxcbiAgICAgICAgICAgIFs0IC8qIEhUVCAqLywgMTEyIC8qIHAgKi8sIDUgLyogSFRUUCAqL10sXG4gICAgICAgICAgICBbNCAvKiBIVFQgKi8sIDgwIC8qIFAgKi8sIDUgLyogSFRUUCAqL10sXG4gICAgICAgICAgICBbNSAvKiBIVFRQICovLCAxMTUgLyogcyAqLywgOSAvKiBCZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbNSAvKiBIVFRQICovLCA4MyAvKiBTICovLCA5IC8qIEJlZm9yZUNvbG9uICovXSxcbiAgICAgICAgICAgIFs1IC8qIEhUVFAgKi8sIDU4IC8qIENvbG9uICovLCAxMCAvKiBBZnRlckNvbG9uICovXSxcbiAgICAgICAgICAgIFs2IC8qIEYgKi8sIDEwNSAvKiBpICovLCA3IC8qIEZJICovXSxcbiAgICAgICAgICAgIFs2IC8qIEYgKi8sIDczIC8qIEkgKi8sIDcgLyogRkkgKi9dLFxuICAgICAgICAgICAgWzcgLyogRkkgKi8sIDEwOCAvKiBsICovLCA4IC8qIEZJTCAqL10sXG4gICAgICAgICAgICBbNyAvKiBGSSAqLywgNzYgLyogTCAqLywgOCAvKiBGSUwgKi9dLFxuICAgICAgICAgICAgWzggLyogRklMICovLCAxMDEgLyogZSAqLywgOSAvKiBCZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbOCAvKiBGSUwgKi8sIDY5IC8qIEUgKi8sIDkgLyogQmVmb3JlQ29sb24gKi9dLFxuICAgICAgICAgICAgWzkgLyogQmVmb3JlQ29sb24gKi8sIDU4IC8qIENvbG9uICovLCAxMCAvKiBBZnRlckNvbG9uICovXSxcbiAgICAgICAgICAgIFsxMCAvKiBBZnRlckNvbG9uICovLCA0NyAvKiBTbGFzaCAqLywgMTEgLyogQWxtb3N0VGhlcmUgKi9dLFxuICAgICAgICAgICAgWzExIC8qIEFsbW9zdFRoZXJlICovLCA0NyAvKiBTbGFzaCAqLywgMTIgLyogRW5kICovXSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGVNYWNoaW5lO1xufVxudmFyIF9jbGFzc2lmaWVyID0gbnVsbDtcbmZ1bmN0aW9uIGdldENsYXNzaWZpZXIoKSB7XG4gICAgaWYgKF9jbGFzc2lmaWVyID09PSBudWxsKSB7XG4gICAgICAgIF9jbGFzc2lmaWVyID0gbmV3IENoYXJhY3RlckNsYXNzaWZpZXIoMCAvKiBOb25lICovKTtcbiAgICAgICAgdmFyIEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMgPSAnIFxcdDw+XFwnXFxcIuOAgeOAgu+9oe+9pO+8jO+8ju+8mu+8m++8n++8ge+8oO+8g++8hO+8he+8hu+8iuKAmOKAnOOAiOOAiuOAjOOAjuOAkOOAlO+8iO+8u++9m++9ou+9o++9ne+8ve+8ieOAleOAkeOAj+OAjeOAi+OAieKAneKAme+9gO+9nuKApic7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRk9SQ0VfVEVSTUlOQVRJT05fQ0hBUkFDVEVSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMgPSAnLiw7JztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KENBTk5PVF9FTkRfV0lUSF9DSEFSQUNURVJTLmNoYXJDb2RlQXQoaSksIDIgLyogQ2Fubm90RW5kSW4gKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY2xhc3NpZmllcjtcbn1cbnZhciBMaW5rQ29tcHV0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua0NvbXB1dGVyKCkge1xuICAgIH1cbiAgICBMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsgPSBmdW5jdGlvbiAoY2xhc3NpZmllciwgbGluZSwgbGluZU51bWJlciwgbGlua0JlZ2luSW5kZXgsIGxpbmtFbmRJbmRleCkge1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgdG8gZW5kIGxpbmsgaW4gY2VydGFpbiBjaGFyYWN0ZXJzLi4uXG4gICAgICAgIHZhciBsYXN0SW5jbHVkZWRDaGFySW5kZXggPSBsaW5rRW5kSW5kZXggLSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY2hDb2RlID0gbGluZS5jaGFyQ29kZUF0KGxhc3RJbmNsdWRlZENoYXJJbmRleCk7XG4gICAgICAgICAgICB2YXIgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XG4gICAgICAgICAgICBpZiAoY2hDbGFzcyAhPT0gMiAvKiBDYW5ub3RFbmRJbiAqLykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEluY2x1ZGVkQ2hhckluZGV4LS07XG4gICAgICAgIH0gd2hpbGUgKGxhc3RJbmNsdWRlZENoYXJJbmRleCA+IGxpbmtCZWdpbkluZGV4KTtcbiAgICAgICAgLy8gSGFuZGxlIGxpbmtzIGVuY2xvc2VkIGluIHBhcmVucywgc3F1YXJlIGJyYWNrZXRzIGFuZCBjdXJseXMuXG4gICAgICAgIGlmIChsaW5rQmVnaW5JbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZUJlZm9yZUxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGlua0JlZ2luSW5kZXggLSAxKTtcbiAgICAgICAgICAgIHZhciBsYXN0Q2hhckNvZGVJbkxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGFzdEluY2x1ZGVkQ2hhckluZGV4KTtcbiAgICAgICAgICAgIGlmICgoY2hhckNvZGVCZWZvcmVMaW5rID09PSA0MCAvKiBPcGVuUGFyZW4gKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSA0MSAvKiBDbG9zZVBhcmVuICovKVxuICAgICAgICAgICAgICAgIHx8IChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDkxIC8qIE9wZW5TcXVhcmVCcmFja2V0ICovICYmIGxhc3RDaGFyQ29kZUluTGluayA9PT0gOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovKVxuICAgICAgICAgICAgICAgIHx8IChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDEyMyAvKiBPcGVuQ3VybHlCcmFjZSAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDEyNSAvKiBDbG9zZUN1cmx5QnJhY2UgKi8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiApIGlmICggaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiBdIGlmIFsgaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiB9IGlmIHsgaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XG4gICAgICAgICAgICAgICAgbGFzdEluY2x1ZGVkQ2hhckluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBsaW5rQmVnaW5JbmRleCArIDEsXG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGxhc3RJbmNsdWRlZENoYXJJbmRleCArIDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cmw6IGxpbmUuc3Vic3RyaW5nKGxpbmtCZWdpbkluZGV4LCBsYXN0SW5jbHVkZWRDaGFySW5kZXggKyAxKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlua0NvbXB1dGVyLmNvbXB1dGVMaW5rcyA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgc3RhdGVNYWNoaW5lID0gZ2V0U3RhdGVNYWNoaW5lKCk7XG4gICAgICAgIHZhciBjbGFzc2lmaWVyID0gZ2V0Q2xhc3NpZmllcigpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTsgaSA8PSBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBtb2RlbC5nZXRMaW5lQ29udGVudChpKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIHZhciBsaW5rQmVnaW5JbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbGlua0JlZ2luQ2hDb2RlID0gMDtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IDEgLyogU3RhcnQgKi87XG4gICAgICAgICAgICB2YXIgaGFzT3BlblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGFzT3BlbkN1cmx5QnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzZXRTdGF0ZU1hY2hpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hDb2RlID0gbGluZS5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogQWNjZXB0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaENsYXNzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MCAvKiBPcGVuUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlblBhcmVucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDEgLyogQ2xvc2VQYXJlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGhhc09wZW5QYXJlbnMgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MSAvKiBPcGVuU3F1YXJlQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAoaGFzT3BlblNxdWFyZUJyYWNrZXQgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjMgLyogT3BlbkN1cmx5QnJhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlbkN1cmx5QnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI1IC8qIENsb3NlQ3VybHlCcmFjZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGhhc09wZW5DdXJseUJyYWNrZXQgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIGZvbGxvd2luZyB0aHJlZSBydWxlcyBtYWtlIGl0IHRoYXQgJyBvciBcIiBvciBgIGFyZSBhbGxvd2VkIGluc2lkZSBsaW5rcyBpZiB0aGUgbGluayBiZWdhbiB3aXRoIGEgZGlmZmVyZW50IG9uZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOSAvKiBTaW5nbGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gMzQgLyogRG91YmxlUXVvdGUgKi8gfHwgbGlua0JlZ2luQ2hDb2RlID09PSA5NiAvKiBCYWNrVGljayAqLykgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0IC8qIERvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAobGlua0JlZ2luQ2hDb2RlID09PSAzOSAvKiBTaW5nbGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDk2IC8qIEJhY2tUaWNrICovKSA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTYgLyogQmFja1RpY2sgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDM5IC8qIFNpbmdsZVF1b3RlICovIHx8IGxpbmtCZWdpbkNoQ29kZSA9PT0gMzQgLyogRG91YmxlUXVvdGUgKi8pID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgdGVybWluYXRlcyBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENsYXNzID09PSAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmtDb21wdXRlci5fY3JlYXRlTGluayhjbGFzc2lmaWVyLCBsaW5lLCBpLCBsaW5rQmVnaW5JbmRleCwgaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTdGF0ZU1hY2hpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAxMiAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChjaENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgdGVybWluYXRlcyBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENsYXNzID09PSAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTMgLyogQWNjZXB0ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlTWFjaGluZS5uZXh0U3RhdGUoc3RhdGUsIGNoQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCAvKiBJbnZhbGlkICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0U3RhdGVNYWNoaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMSAvKiBTdGFydCAqLztcbiAgICAgICAgICAgICAgICAgICAgaGFzT3BlblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB3aGVyZSB0aGUgbGluayBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkluZGV4ID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkNoQ29kZSA9IGNoQ29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxMyAvKiBBY2NlcHQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgaSwgbGlua0JlZ2luSW5kZXgsIGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua0NvbXB1dGVyO1xufSgpKTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgbGlua3MgY29udGFpbnMgaW4gdGhlIHByb3ZpZGVkXG4gKiBkb2N1bWVudC4gKk5vdGUqIHRoYXQgdGhpcyBvcGVyYXRpb24gaXMgY29tcHV0YXRpb25hbFxuICogZXhwZW5zaXZlIGFuZCBzaG91bGQgbm90IHJ1biBpbiB0aGUgVUkgdGhyZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUxpbmtzKG1vZGVsKSB7XG4gICAgaWYgKCFtb2RlbCB8fCB0eXBlb2YgbW9kZWwuZ2V0TGluZUNvdW50ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBtb2RlbC5nZXRMaW5lQ29udGVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVbmtub3duIGNhbGxlciFcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gTGlua0NvbXB1dGVyLmNvbXB1dGVMaW5rcyhtb2RlbCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js ***!
  \*************************************************************************************************/
/*! exports provided: BasicInplaceReplace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicInplaceReplace\", function() { return BasicInplaceReplace; });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar BasicInplaceReplace = /** @class */ (function () {\n    function BasicInplaceReplace() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    BasicInplaceReplace.prototype.navigateValueSet = function (range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            var result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            var result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    };\n    BasicInplaceReplace.prototype.doNavigateValueSet = function (text, up) {\n        var numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    };\n    BasicInplaceReplace.prototype.numberReplace = function (value, up) {\n        var precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        var n1 = Number(value);\n        var n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    };\n    BasicInplaceReplace.prototype.textReplace = function (value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    };\n    BasicInplaceReplace.prototype.valueSetsReplace = function (valueSets, value, up) {\n        var result = null;\n        for (var i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    };\n    BasicInplaceReplace.prototype.valueSetReplace = function (valueSet, value, up) {\n        var idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    };\n    BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n    return BasicInplaceReplace;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanM/MmUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbnZhciBCYXNpY0lucGxhY2VSZXBsYWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2ljSW5wbGFjZVJlcGxhY2UoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZVNldCA9IFtcbiAgICAgICAgICAgIFsndHJ1ZScsICdmYWxzZSddLFxuICAgICAgICAgICAgWydUcnVlJywgJ0ZhbHNlJ10sXG4gICAgICAgICAgICBbJ1ByaXZhdGUnLCAnUHVibGljJywgJ0ZyaWVuZCcsICdSZWFkT25seScsICdQYXJ0aWFsJywgJ1Byb3RlY3RlZCcsICdXcml0ZU9ubHknXSxcbiAgICAgICAgICAgIFsncHVibGljJywgJ3Byb3RlY3RlZCcsICdwcml2YXRlJ10sXG4gICAgICAgIF07XG4gICAgfVxuICAgIEJhc2ljSW5wbGFjZVJlcGxhY2UucHJvdG90eXBlLm5hdmlnYXRlVmFsdWVTZXQgPSBmdW5jdGlvbiAocmFuZ2UxLCB0ZXh0MSwgcmFuZ2UyLCB0ZXh0MiwgdXApIHtcbiAgICAgICAgaWYgKHJhbmdlMSAmJiB0ZXh0MSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQxLCB1cCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlMSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlMiAmJiB0ZXh0Mikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQyLCB1cCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlMixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCYXNpY0lucGxhY2VSZXBsYWNlLnByb3RvdHlwZS5kb05hdmlnYXRlVmFsdWVTZXQgPSBmdW5jdGlvbiAodGV4dCwgdXApIHtcbiAgICAgICAgdmFyIG51bWJlclJlc3VsdCA9IHRoaXMubnVtYmVyUmVwbGFjZSh0ZXh0LCB1cCk7XG4gICAgICAgIGlmIChudW1iZXJSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFJlcGxhY2UodGV4dCwgdXApO1xuICAgIH07XG4gICAgQmFzaWNJbnBsYWNlUmVwbGFjZS5wcm90b3R5cGUubnVtYmVyUmVwbGFjZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdXApIHtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCB2YWx1ZS5sZW5ndGggLSAodmFsdWUubGFzdEluZGV4T2YoJy4nKSArIDEpKTtcbiAgICAgICAgdmFyIG4xID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgdmFyIG4yID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNOYU4objEpICYmICFpc05hTihuMikgJiYgbjEgPT09IG4yKSB7XG4gICAgICAgICAgICBpZiAobjEgPT09IDAgJiYgIXVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IGRvIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy9cdFx0XHR9IGVsc2UgaWYobjEgPT09IDkgJiYgdXApIHtcbiAgICAgICAgICAgICAgICAvL1x0XHRcdFx0cmV0dXJuIG51bGw7IC8vIGRvbid0IGluc2VydCAxMCBpbnRvIGEgbnVtYmVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuMSA9IE1hdGguZmxvb3IobjEgKiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIG4xICs9IHVwID8gcHJlY2lzaW9uIDogLXByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKG4xIC8gcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJhc2ljSW5wbGFjZVJlcGxhY2UucHJvdG90eXBlLnRleHRSZXBsYWNlID0gZnVuY3Rpb24gKHZhbHVlLCB1cCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVNldHNSZXBsYWNlKHRoaXMuX2RlZmF1bHRWYWx1ZVNldCwgdmFsdWUsIHVwKTtcbiAgICB9O1xuICAgIEJhc2ljSW5wbGFjZVJlcGxhY2UucHJvdG90eXBlLnZhbHVlU2V0c1JlcGxhY2UgPSBmdW5jdGlvbiAodmFsdWVTZXRzLCB2YWx1ZSwgdXApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZVNldHMubGVuZ3RoOyByZXN1bHQgPT09IG51bGwgJiYgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZhbHVlU2V0UmVwbGFjZSh2YWx1ZVNldHNbaV0sIHZhbHVlLCB1cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEJhc2ljSW5wbGFjZVJlcGxhY2UucHJvdG90eXBlLnZhbHVlU2V0UmVwbGFjZSA9IGZ1bmN0aW9uICh2YWx1ZVNldCwgdmFsdWUsIHVwKSB7XG4gICAgICAgIHZhciBpZHggPSB2YWx1ZVNldC5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZHggKz0gdXAgPyArMSA6IC0xO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZHggPSB2YWx1ZVNldC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWR4ICU9IHZhbHVlU2V0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVNldFtpZHhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRSA9IG5ldyBCYXNpY0lucGxhY2VSZXBsYWNlKCk7XG4gICAgcmV0dXJuIEJhc2ljSW5wbGFjZVJlcGxhY2U7XG59KCkpO1xuZXhwb3J0IHsgQmFzaWNJbnBsYWNlUmVwbGFjZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services sync recursive":
/*!***********************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services sync ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error('Cannot find module \"' + req + '\".');\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/monaco-editor/esm/vs/editor/common/services sync recursive\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcyBzeW5jIHJlY3Vyc2l2ZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzIHN5bmM/MmYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgbW9kdWxlIFwiJyArIHJlcSArICdcIi4nKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzIHN5bmMgcmVjdXJzaXZlXCI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/services sync recursive\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js ***!
  \****************************************************************************************/
/*! exports provided: BaseEditorSimpleWorker, EditorSimpleWorkerImpl, create */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseEditorSimpleWorker\", function() { return BaseEditorSimpleWorker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditorSimpleWorkerImpl\", function() { return EditorSimpleWorkerImpl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/uri.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uri.js\");\n/* harmony import */ var _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/winjs.base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../diff/diffComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js\");\n/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ \"./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model/mirrorTextModel.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\");\n/* harmony import */ var _modes_linkComputer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../modes/linkComputer.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js\");\n/* harmony import */ var _modes_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../modes/supports/inplaceReplaceSupport.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js\");\n/* harmony import */ var _model_wordHelper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../model/wordHelper.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js\");\n/* harmony import */ var _standalone_standaloneBase_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../standalone/standaloneBase.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js\");\n/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../base/common/platform.js */ \"./node_modules/monaco-editor/esm/vs/base/common/platform.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\nvar MirrorModel = /** @class */ (function (_super) {\n    __extends(MirrorModel, _super);\n    function MirrorModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MirrorModel.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MirrorModel.prototype, \"version\", {\n        get: function () {\n            return this._versionId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MirrorModel.prototype, \"eol\", {\n        get: function () {\n            return this._eol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MirrorModel.prototype.getValue = function () {\n        return this.getText();\n    };\n    MirrorModel.prototype.getLinesContent = function () {\n        return this._lines.slice(0);\n    };\n    MirrorModel.prototype.getLineCount = function () {\n        return this._lines.length;\n    };\n    MirrorModel.prototype.getLineContent = function (lineNumber) {\n        return this._lines[lineNumber - 1];\n    };\n    MirrorModel.prototype.getWordAtPosition = function (position, wordDefinition) {\n        var wordAtText = Object(_model_wordHelper_js__WEBPACK_IMPORTED_MODULE_9__[\"getWordAtText\"])(position.column, Object(_model_wordHelper_js__WEBPACK_IMPORTED_MODULE_9__[\"ensureValidWordDefinition\"])(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new _core_range_js__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    };\n    MirrorModel.prototype.getWordUntilPosition = function (position, wordDefinition) {\n        var wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    };\n    MirrorModel.prototype._getAllWords = function (wordDefinition) {\n        var _this = this;\n        var result = [];\n        this._lines.forEach(function (line) {\n            _this._wordenize(line, wordDefinition).forEach(function (info) {\n                result.push(line.substring(info.start, info.end));\n            });\n        });\n        return result;\n    };\n    MirrorModel.prototype.getAllUniqueWords = function (wordDefinition, skipWordOnce) {\n        var foundSkipWord = false;\n        var uniqueWords = Object.create(null);\n        return this._getAllWords(wordDefinition).filter(function (word) {\n            if (skipWordOnce && !foundSkipWord && skipWordOnce === word) {\n                foundSkipWord = true;\n                return false;\n            }\n            else if (uniqueWords[word]) {\n                return false;\n            }\n            else {\n                uniqueWords[word] = true;\n                return true;\n            }\n        });\n    };\n    MirrorModel.prototype._wordenize = function (content, wordDefinition) {\n        var result = [];\n        var match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    };\n    MirrorModel.prototype.getValueInRange = function (range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        var lineEnding = this._eol;\n        var startLineIndex = range.startLineNumber - 1;\n        var endLineIndex = range.endLineNumber - 1;\n        var resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (var i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    };\n    MirrorModel.prototype.offsetAt = function (position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);\n    };\n    MirrorModel.prototype.positionAt = function (offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        var out = this._lineStarts.getIndexOf(offset);\n        var lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    };\n    MirrorModel.prototype._validateRange = function (range) {\n        var start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        var end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    };\n    MirrorModel.prototype._validatePosition = function (position) {\n        if (!_core_position_js__WEBPACK_IMPORTED_MODULE_5__[\"Position\"].isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        var lineNumber = position.lineNumber, column = position.column;\n        var hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            var maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber: lineNumber, column: column };\n        }\n    };\n    return MirrorModel;\n}(_model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_6__[\"MirrorTextModel\"]));\n/**\n * @internal\n */\nvar BaseEditorSimpleWorker = /** @class */ (function () {\n    function BaseEditorSimpleWorker(foreignModuleFactory) {\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    BaseEditorSimpleWorker.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\n        var original = this._getModel(originalUrl);\n        var modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        var originalLines = original.getLinesContent();\n        var modifiedLines = modified.getLinesContent();\n        var diffComputer = new _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_3__[\"DiffComputer\"](originalLines, modifiedLines, {\n            shouldPostProcessCharChanges: true,\n            shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n            shouldMakePrettyDiff: true\n        });\n        return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(diffComputer.computeDiff());\n    };\n    BaseEditorSimpleWorker.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\n        var original = this._getModel(originalUrl);\n        var modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        var originalLines = original.getLinesContent();\n        var modifiedLines = modified.getLinesContent();\n        var diffComputer = new _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_3__[\"DiffComputer\"](originalLines, modifiedLines, {\n            shouldPostProcessCharChanges: false,\n            shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n            shouldMakePrettyDiff: true\n        });\n        return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(diffComputer.computeDiff());\n    };\n    BaseEditorSimpleWorker.prototype.computeMoreMinimalEdits = function (modelUrl, edits) {\n        var model = this._getModel(modelUrl);\n        if (!model) {\n            return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(edits);\n        }\n        var result = [];\n        var lastEol;\n        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {\n            var _a = edits_1[_i], range = _a.range, text = _a.text, eol = _a.eol;\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (!range) {\n                // eol-change only\n                continue;\n            }\n            var original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                // noop\n                continue;\n            }\n            // make sure diff won't take too long\n            if (Math.max(text.length, original.length) > BaseEditorSimpleWorker._diffLimit) {\n                result.push({ range: range, text: text });\n                continue;\n            }\n            // compute diff between original and edit.text\n            var changes = Object(_base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_4__[\"stringDiff\"])(original, text, false);\n            var editOffset = model.offsetAt(_core_range_js__WEBPACK_IMPORTED_MODULE_2__[\"Range\"].lift(range).getStartPosition());\n            for (var _b = 0, changes_1 = changes; _b < changes_1.length; _b++) {\n                var change = changes_1[_b];\n                var start = model.positionAt(editOffset + change.originalStart);\n                var end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                var newEdit = {\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                };\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                    result.push(newEdit);\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: undefined, range: undefined });\n        }\n        return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(result);\n    };\n    // ---- END minimal edits ---------------------------------------------------------------\n    BaseEditorSimpleWorker.prototype.computeLinks = function (modelUrl) {\n        var model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(Object(_modes_linkComputer_js__WEBPACK_IMPORTED_MODULE_7__[\"computeLinks\"])(model));\n    };\n    // ---- BEGIN suggest --------------------------------------------------------------------------\n    BaseEditorSimpleWorker.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {\n        var model = this._getModel(modelUrl);\n        if (model) {\n            var suggestions = [];\n            var wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            var currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;\n            for (var _i = 0, _a = model.getAllUniqueWords(wordDefRegExp); _i < _a.length; _i++) {\n                var word = _a[_i];\n                if (word !== currentWord && isNaN(Number(word))) {\n                    suggestions.push({\n                        type: 'text',\n                        label: word,\n                        insertText: word,\n                        noAutoAccept: true,\n                        overwriteBefore: currentWord.length\n                    });\n                }\n            }\n            return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as({ suggestions: suggestions });\n        }\n        return undefined;\n    };\n    // ---- END suggest --------------------------------------------------------------------------\n    BaseEditorSimpleWorker.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {\n        var model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        var wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        if (range.startColumn === range.endColumn) {\n            range = {\n                startLineNumber: range.startLineNumber,\n                startColumn: range.startColumn,\n                endLineNumber: range.endLineNumber,\n                endColumn: range.endColumn + 1\n            };\n        }\n        var selectionText = model.getValueInRange(range);\n        var wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n        var word = null;\n        if (wordRange !== null) {\n            word = model.getValueInRange(wordRange);\n        }\n        var result = _modes_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_8__[\"BasicInplaceReplace\"].INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n        return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(result);\n    };\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    BaseEditorSimpleWorker.prototype.loadForeignModule = function (moduleId, createData) {\n        var _this = this;\n        var ctx = {\n            getMirrorModels: function () {\n                return _this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            var methods = [];\n            for (var prop in this._foreignModule) {\n                if (typeof this._foreignModule[prop] === 'function') {\n                    methods.push(prop);\n                }\n            }\n            return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(methods);\n        }\n        return new _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"](function (c, e) {\n            Promise.resolve(/*! AMD require */).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(\"./node_modules/monaco-editor/esm/vs/editor/common/services sync recursive\")(moduleId)]; (function (foreignModule) {\n                _this._foreignModule = foreignModule.create(ctx, createData);\n                var methods = [];\n                for (var prop in _this._foreignModule) {\n                    if (typeof _this._foreignModule[prop] === 'function') {\n                        methods.push(prop);\n                    }\n                }\n                c(methods);\n            }).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);}).catch(e.bind(this));\n        });\n    };\n    // foreign method request\n    BaseEditorSimpleWorker.prototype.fmr = function (method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].wrapError(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].as(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_1__[\"TPromise\"].wrapError(e);\n        }\n    };\n    // ---- END diff --------------------------------------------------------------------------\n    // ---- BEGIN minimal edits ---------------------------------------------------------------\n    BaseEditorSimpleWorker._diffLimit = 10000;\n    return BaseEditorSimpleWorker;\n}());\n\n/**\n * @internal\n */\nvar EditorSimpleWorkerImpl = /** @class */ (function (_super) {\n    __extends(EditorSimpleWorkerImpl, _super);\n    function EditorSimpleWorkerImpl(foreignModuleFactory) {\n        var _this = _super.call(this, foreignModuleFactory) || this;\n        _this._models = Object.create(null);\n        return _this;\n    }\n    EditorSimpleWorkerImpl.prototype.dispose = function () {\n        this._models = Object.create(null);\n    };\n    EditorSimpleWorkerImpl.prototype._getModel = function (uri) {\n        return this._models[uri];\n    };\n    EditorSimpleWorkerImpl.prototype._getModels = function () {\n        var _this = this;\n        var all = [];\n        Object.keys(this._models).forEach(function (key) { return all.push(_this._models[key]); });\n        return all;\n    };\n    EditorSimpleWorkerImpl.prototype.acceptNewModel = function (data) {\n        this._models[data.url] = new MirrorModel(_base_common_uri_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(data.url), data.lines, data.EOL, data.versionId);\n    };\n    EditorSimpleWorkerImpl.prototype.acceptModelChanged = function (strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        var model = this._models[strURL];\n        model.onEvents(e);\n    };\n    EditorSimpleWorkerImpl.prototype.acceptRemovedModel = function (strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    };\n    return EditorSimpleWorkerImpl;\n}(BaseEditorSimpleWorker));\n\n/**\n * Called on the worker side\n * @internal\n */\nfunction create() {\n    return new EditorSimpleWorkerImpl(null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    _base_common_platform_js__WEBPACK_IMPORTED_MODULE_11__[\"globals\"].monaco = Object(_standalone_standaloneBase_js__WEBPACK_IMPORTED_MODULE_10__[\"createMonacoBaseAPI\"])();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanM/Y2NmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IFVSSSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgVFByb21pc2UgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi93aW5qcy5iYXNlLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBEaWZmQ29tcHV0ZXIgfSBmcm9tICcuLi9kaWZmL2RpZmZDb21wdXRlci5qcyc7XG5pbXBvcnQgeyBzdHJpbmdEaWZmIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBNaXJyb3JUZXh0TW9kZWwgYXMgQmFzZU1pcnJvck1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvbWlycm9yVGV4dE1vZGVsLmpzJztcbmltcG9ydCB7IGNvbXB1dGVMaW5rcyB9IGZyb20gJy4uL21vZGVzL2xpbmtDb21wdXRlci5qcyc7XG5pbXBvcnQgeyBCYXNpY0lucGxhY2VSZXBsYWNlIH0gZnJvbSAnLi4vbW9kZXMvc3VwcG9ydHMvaW5wbGFjZVJlcGxhY2VTdXBwb3J0LmpzJztcbmltcG9ydCB7IGdldFdvcmRBdFRleHQsIGVuc3VyZVZhbGlkV29yZERlZmluaXRpb24gfSBmcm9tICcuLi9tb2RlbC93b3JkSGVscGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZU1vbmFjb0Jhc2VBUEkgfSBmcm9tICcuLi9zdGFuZGFsb25lL3N0YW5kYWxvbmVCYXNlLmpzJztcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgTWlycm9yTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1pcnJvck1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1pcnJvck1vZGVsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXJyb3JNb2RlbC5wcm90b3R5cGUsIFwidXJpXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWlycm9yTW9kZWwucHJvdG90eXBlLCBcInZlcnNpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXJyb3JNb2RlbC5wcm90b3R5cGUsIFwiZW9sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW9sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNaXJyb3JNb2RlbC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKTtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5nZXRMaW5lc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5zbGljZSgwKTtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5nZXRMaW5lQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5sZW5ndGg7XG4gICAgfTtcbiAgICBNaXJyb3JNb2RlbC5wcm90b3R5cGUuZ2V0TGluZUNvbnRlbnQgPSBmdW5jdGlvbiAobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xuICAgIH07XG4gICAgTWlycm9yTW9kZWwucHJvdG90eXBlLmdldFdvcmRBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB3b3JkRGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgd29yZEF0VGV4dCA9IGdldFdvcmRBdFRleHQocG9zaXRpb24uY29sdW1uLCBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLCAwKTtcbiAgICAgICAgaWYgKHdvcmRBdFRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UocG9zaXRpb24ubGluZU51bWJlciwgd29yZEF0VGV4dC5zdGFydENvbHVtbiwgcG9zaXRpb24ubGluZU51bWJlciwgd29yZEF0VGV4dC5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTWlycm9yTW9kZWwucHJvdG90eXBlLmdldFdvcmRVbnRpbFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB3b3JkRGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgd29yZEF0UG9zaXRpb24gPSB0aGlzLmdldFdvcmRBdFBvc2l0aW9uKHBvc2l0aW9uLCB3b3JkRGVmaW5pdGlvbik7XG4gICAgICAgIGlmICghd29yZEF0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd29yZDogJycsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHBvc2l0aW9uLmNvbHVtbixcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHBvc2l0aW9uLmNvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd29yZDogdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyh3b3JkQXRQb3NpdGlvbi5zdGFydENvbHVtbiAtIDEsIHBvc2l0aW9uLmNvbHVtbiAtIDEpLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHdvcmRBdFBvc2l0aW9uLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBwb3NpdGlvbi5jb2x1bW5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5fZ2V0QWxsV29yZHMgPSBmdW5jdGlvbiAod29yZERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLl9saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBfdGhpcy5fd29yZGVuaXplKGxpbmUsIHdvcmREZWZpbml0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zdWJzdHJpbmcoaW5mby5zdGFydCwgaW5mby5lbmQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5nZXRBbGxVbmlxdWVXb3JkcyA9IGZ1bmN0aW9uICh3b3JkRGVmaW5pdGlvbiwgc2tpcFdvcmRPbmNlKSB7XG4gICAgICAgIHZhciBmb3VuZFNraXBXb3JkID0gZmFsc2U7XG4gICAgICAgIHZhciB1bmlxdWVXb3JkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBbGxXb3Jkcyh3b3JkRGVmaW5pdGlvbikuZmlsdGVyKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgICAgICBpZiAoc2tpcFdvcmRPbmNlICYmICFmb3VuZFNraXBXb3JkICYmIHNraXBXb3JkT25jZSA9PT0gd29yZCkge1xuICAgICAgICAgICAgICAgIGZvdW5kU2tpcFdvcmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVuaXF1ZVdvcmRzW3dvcmRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlV29yZHNbd29yZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5fd29yZGVuaXplID0gZnVuY3Rpb24gKGNvbnRlbnQsIHdvcmREZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSAwOyAvLyByZXNldCBsYXN0SW5kZXgganVzdCB0byBiZSBzdXJlXG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWMoY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFswXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpdCBkaWQgbWF0Y2ggdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdGFydDogbWF0Y2guaW5kZXgsIGVuZDogbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5nZXRWYWx1ZUluUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl92YWxpZGF0ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5zdGFydENvbHVtbiAtIDEsIHJhbmdlLmVuZENvbHVtbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lRW5kaW5nID0gdGhpcy5fZW9sO1xuICAgICAgICB2YXIgc3RhcnRMaW5lSW5kZXggPSByYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxO1xuICAgICAgICB2YXIgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIDE7XG4gICAgICAgIHZhciByZXN1bHRMaW5lcyA9IFtdO1xuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW3N0YXJ0TGluZUluZGV4XS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmVJbmRleCArIDE7IGkgPCBlbmRMaW5lSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tlbmRMaW5lSW5kZXhdLnN1YnN0cmluZygwLCByYW5nZS5lbmRDb2x1bW4gLSAxKSk7XG4gICAgICAgIHJldHVybiByZXN1bHRMaW5lcy5qb2luKGxpbmVFbmRpbmcpO1xuICAgIH07XG4gICAgTWlycm9yTW9kZWwucHJvdG90eXBlLm9mZnNldEF0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUxpbmVTdGFydHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVTdGFydHMuZ2V0QWNjdW11bGF0ZWRWYWx1ZShwb3NpdGlvbi5saW5lTnVtYmVyIC0gMikgKyAocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgfTtcbiAgICBNaXJyb3JNb2RlbC5wcm90b3R5cGUucG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9lbnN1cmVMaW5lU3RhcnRzKCk7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLl9saW5lU3RhcnRzLmdldEluZGV4T2Yob2Zmc2V0KTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSB0aGlzLl9saW5lc1tvdXQuaW5kZXhdLmxlbmd0aDtcbiAgICAgICAgLy8gRW5zdXJlIHdlIHJldHVybiBhIHZhbGlkIHBvc2l0aW9uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyOiAxICsgb3V0LmluZGV4LFxuICAgICAgICAgICAgY29sdW1uOiAxICsgTWF0aC5taW4ob3V0LnJlbWFpbmRlciwgbGluZUxlbmd0aClcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1pcnJvck1vZGVsLnByb3RvdHlwZS5fdmFsaWRhdGVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uKHsgbGluZU51bWJlcjogcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBjb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uIH0pO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLmVuZExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2UuZW5kQ29sdW1uIH0pO1xuICAgICAgICBpZiAoc3RhcnQubGluZU51bWJlciAhPT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyXG4gICAgICAgICAgICB8fCBzdGFydC5jb2x1bW4gIT09IHJhbmdlLnN0YXJ0Q29sdW1uXG4gICAgICAgICAgICB8fCBlbmQubGluZU51bWJlciAhPT0gcmFuZ2UuZW5kTGluZU51bWJlclxuICAgICAgICAgICAgfHwgZW5kLmNvbHVtbiAhPT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnQubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogZW5kLmNvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBNaXJyb3JNb2RlbC5wcm90b3R5cGUuX3ZhbGlkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKCFQb3NpdGlvbi5pc0lQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvc2l0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwb3NpdGlvbi5saW5lTnVtYmVyLCBjb2x1bW4gPSBwb3NpdGlvbi5jb2x1bW47XG4gICAgICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IDE7XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZU51bWJlciA+IHRoaXMuX2xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuX2xpbmVzW2xpbmVOdW1iZXIgLSAxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF4Q2hhcmFjdGVyID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2x1bW4gPiBtYXhDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBtYXhDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLCBjb2x1bW46IGNvbHVtbiB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWlycm9yTW9kZWw7XG59KEJhc2VNaXJyb3JNb2RlbCkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUVkaXRvclNpbXBsZVdvcmtlcihmb3JlaWduTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeSA9IGZvcmVpZ25Nb2R1bGVGYWN0b3J5O1xuICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gLS0tLSBCRUdJTiBkaWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQmFzZUVkaXRvclNpbXBsZVdvcmtlci5wcm90b3R5cGUuY29tcHV0ZURpZmYgPSBmdW5jdGlvbiAob3JpZ2luYWxVcmwsIG1vZGlmaWVkVXJsLCBpZ25vcmVUcmltV2hpdGVzcGFjZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9nZXRNb2RlbChvcmlnaW5hbFVybCk7XG4gICAgICAgIHZhciBtb2RpZmllZCA9IHRoaXMuX2dldE1vZGVsKG1vZGlmaWVkVXJsKTtcbiAgICAgICAgaWYgKCFvcmlnaW5hbCB8fCAhbW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmVzID0gb3JpZ2luYWwuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgICAgIHZhciBtb2RpZmllZExpbmVzID0gbW9kaWZpZWQuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgICAgIHZhciBkaWZmQ29tcHV0ZXIgPSBuZXcgRGlmZkNvbXB1dGVyKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHtcbiAgICAgICAgICAgIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXM6IHRydWUsXG4gICAgICAgICAgICBzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZTogaWdub3JlVHJpbVdoaXRlc3BhY2UsXG4gICAgICAgICAgICBzaG91bGRNYWtlUHJldHR5RGlmZjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRQcm9taXNlLmFzKGRpZmZDb21wdXRlci5jb21wdXRlRGlmZigpKTtcbiAgICB9O1xuICAgIEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIucHJvdG90eXBlLmNvbXB1dGVEaXJ0eURpZmYgPSBmdW5jdGlvbiAob3JpZ2luYWxVcmwsIG1vZGlmaWVkVXJsLCBpZ25vcmVUcmltV2hpdGVzcGFjZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9nZXRNb2RlbChvcmlnaW5hbFVybCk7XG4gICAgICAgIHZhciBtb2RpZmllZCA9IHRoaXMuX2dldE1vZGVsKG1vZGlmaWVkVXJsKTtcbiAgICAgICAgaWYgKCFvcmlnaW5hbCB8fCAhbW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmVzID0gb3JpZ2luYWwuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgICAgIHZhciBtb2RpZmllZExpbmVzID0gbW9kaWZpZWQuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgICAgIHZhciBkaWZmQ29tcHV0ZXIgPSBuZXcgRGlmZkNvbXB1dGVyKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHtcbiAgICAgICAgICAgIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2U6IGlnbm9yZVRyaW1XaGl0ZXNwYWNlLFxuICAgICAgICAgICAgc2hvdWxkTWFrZVByZXR0eURpZmY6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUUHJvbWlzZS5hcyhkaWZmQ29tcHV0ZXIuY29tcHV0ZURpZmYoKSk7XG4gICAgfTtcbiAgICBCYXNlRWRpdG9yU2ltcGxlV29ya2VyLnByb3RvdHlwZS5jb21wdXRlTW9yZU1pbmltYWxFZGl0cyA9IGZ1bmN0aW9uIChtb2RlbFVybCwgZWRpdHMpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gVFByb21pc2UuYXMoZWRpdHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RFb2w7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZWRpdHNfMSA9IGVkaXRzOyBfaSA8IGVkaXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBlZGl0c18xW19pXSwgcmFuZ2UgPSBfYS5yYW5nZSwgdGV4dCA9IF9hLnRleHQsIGVvbCA9IF9hLmVvbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW9sID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGxhc3RFb2wgPSBlb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gZW9sLWNoYW5nZSBvbmx5XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxufFxcbnxcXHIvZywgbW9kZWwuZW9sKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbCA9PT0gdGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBkaWZmIHdvbid0IHRha2UgdG9vIGxvbmdcbiAgICAgICAgICAgIGlmIChNYXRoLm1heCh0ZXh0Lmxlbmd0aCwgb3JpZ2luYWwubGVuZ3RoKSA+IEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIGJldHdlZW4gb3JpZ2luYWwgYW5kIGVkaXQudGV4dFxuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSBzdHJpbmdEaWZmKG9yaWdpbmFsLCB0ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgZWRpdE9mZnNldCA9IG1vZGVsLm9mZnNldEF0KFJhbmdlLmxpZnQocmFuZ2UpLmdldFN0YXJ0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIGNoYW5nZXNfMSA9IGNoYW5nZXM7IF9iIDwgY2hhbmdlc18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzXzFbX2JdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG1vZGVsLnBvc2l0aW9uQXQoZWRpdE9mZnNldCArIGNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdFZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LnN1YnN0cihjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHsgc3RhcnRMaW5lTnVtYmVyOiBzdGFydC5saW5lTnVtYmVyLCBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLCBlbmRMaW5lTnVtYmVyOiBlbmQubGluZU51bWJlciwgZW5kQ29sdW1uOiBlbmQuY29sdW1uIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5nZXRWYWx1ZUluUmFuZ2UobmV3RWRpdC5yYW5nZSkgIT09IG5ld0VkaXQudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdFZGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYXN0RW9sID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBlb2w6IGxhc3RFb2wsIHRleHQ6IHVuZGVmaW5lZCwgcmFuZ2U6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVFByb21pc2UuYXMocmVzdWx0KTtcbiAgICB9O1xuICAgIC8vIC0tLS0gRU5EIG1pbmltYWwgZWRpdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQmFzZUVkaXRvclNpbXBsZVdvcmtlci5wcm90b3R5cGUuY29tcHV0ZUxpbmtzID0gZnVuY3Rpb24gKG1vZGVsVXJsKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRQcm9taXNlLmFzKGNvbXB1dGVMaW5rcyhtb2RlbCkpO1xuICAgIH07XG4gICAgLy8gLS0tLSBCRUdJTiBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQmFzZUVkaXRvclNpbXBsZVdvcmtlci5wcm90b3R5cGUudGV4dHVhbFN1Z2dlc3QgPSBmdW5jdGlvbiAobW9kZWxVcmwsIHBvc2l0aW9uLCB3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBzdWdnZXN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFdvcmQgPSBtb2RlbC5nZXRXb3JkVW50aWxQb3NpdGlvbihwb3NpdGlvbiwgd29yZERlZlJlZ0V4cCkud29yZDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtb2RlbC5nZXRBbGxVbmlxdWVXb3Jkcyh3b3JkRGVmUmVnRXhwKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAod29yZCAhPT0gY3VycmVudFdvcmQgJiYgaXNOYU4oTnVtYmVyKHdvcmQpKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQXV0b0FjY2VwdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZUJlZm9yZTogY3VycmVudFdvcmQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUUHJvbWlzZS5hcyh7IHN1Z2dlc3Rpb25zOiBzdWdnZXN0aW9ucyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLy8gLS0tLSBFTkQgc3VnZ2VzdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIucHJvdG90eXBlLm5hdmlnYXRlVmFsdWVTZXQgPSBmdW5jdGlvbiAobW9kZWxVcmwsIHJhbmdlLCB1cCwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZENvbHVtbiArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGlvblRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UocmFuZ2UpO1xuICAgICAgICB2YXIgd29yZFJhbmdlID0gbW9kZWwuZ2V0V29yZEF0UG9zaXRpb24oeyBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4gfSwgd29yZERlZlJlZ0V4cCk7XG4gICAgICAgIHZhciB3b3JkID0gbnVsbDtcbiAgICAgICAgaWYgKHdvcmRSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZSh3b3JkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBCYXNpY0lucGxhY2VSZXBsYWNlLklOU1RBTkNFLm5hdmlnYXRlVmFsdWVTZXQocmFuZ2UsIHNlbGVjdGlvblRleHQsIHdvcmRSYW5nZSwgd29yZCwgdXApO1xuICAgICAgICByZXR1cm4gVFByb21pc2UuYXMocmVzdWx0KTtcbiAgICB9O1xuICAgIC8vIC0tLS0gQkVHSU4gZm9yZWlnbiBtb2R1bGUgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIucHJvdG90eXBlLmxvYWRGb3JlaWduTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBjcmVhdGVEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICBnZXRNaXJyb3JNb2RlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dldE1vZGVscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeShjdHgsIGNyZWF0ZURhdGEpO1xuICAgICAgICAgICAgLy8gc3RhdGljIGZvcmVpbmcgbW9kdWxlXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl9mb3JlaWduTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9mb3JlaWduTW9kdWxlW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVFByb21pc2UuYXMobWV0aG9kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUUHJvbWlzZShmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICAgICAgcmVxdWlyZShbbW9kdWxlSWRdLCBmdW5jdGlvbiAoZm9yZWlnbk1vZHVsZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9mb3JlaWduTW9kdWxlID0gZm9yZWlnbk1vZHVsZS5jcmVhdGUoY3R4LCBjcmVhdGVEYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gX3RoaXMuX2ZvcmVpZ25Nb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5fZm9yZWlnbk1vZHVsZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMobWV0aG9kcyk7XG4gICAgICAgICAgICB9LCBlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBmb3JlaWduIG1ldGhvZCByZXF1ZXN0XG4gICAgQmFzZUVkaXRvclNpbXBsZVdvcmtlci5wcm90b3R5cGUuZm1yID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2ZvcmVpZ25Nb2R1bGUgfHwgdHlwZW9mIHRoaXMuX2ZvcmVpZ25Nb2R1bGVbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIFRQcm9taXNlLndyYXBFcnJvcihuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWVzdEhhbmRsZXIgb3IgbWV0aG9kOiAnICsgbWV0aG9kKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBUUHJvbWlzZS5hcyh0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0uYXBwbHkodGhpcy5fZm9yZWlnbk1vZHVsZSwgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gVFByb21pc2Uud3JhcEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS0tIEVORCBkaWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLSBCRUdJTiBtaW5pbWFsIGVkaXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCA9IDEwMDAwO1xuICAgIHJldHVybiBCYXNlRWRpdG9yU2ltcGxlV29ya2VyO1xufSgpKTtcbmV4cG9ydCB7IEJhc2VFZGl0b3JTaW1wbGVXb3JrZXIgfTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBFZGl0b3JTaW1wbGVXb3JrZXJJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFZGl0b3JTaW1wbGVXb3JrZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVkaXRvclNpbXBsZVdvcmtlckltcGwoZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9tb2RlbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVkaXRvclNpbXBsZVdvcmtlckltcGwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcbiAgICBFZGl0b3JTaW1wbGVXb3JrZXJJbXBsLnByb3RvdHlwZS5fZ2V0TW9kZWwgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHNbdXJpXTtcbiAgICB9O1xuICAgIEVkaXRvclNpbXBsZVdvcmtlckltcGwucHJvdG90eXBlLl9nZXRNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbGwgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFsbC5wdXNoKF90aGlzLl9tb2RlbHNba2V5XSk7IH0pO1xuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH07XG4gICAgRWRpdG9yU2ltcGxlV29ya2VySW1wbC5wcm90b3R5cGUuYWNjZXB0TmV3TW9kZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl9tb2RlbHNbZGF0YS51cmxdID0gbmV3IE1pcnJvck1vZGVsKFVSSS5wYXJzZShkYXRhLnVybCksIGRhdGEubGluZXMsIGRhdGEuRU9MLCBkYXRhLnZlcnNpb25JZCk7XG4gICAgfTtcbiAgICBFZGl0b3JTaW1wbGVXb3JrZXJJbXBsLnByb3RvdHlwZS5hY2NlcHRNb2RlbENoYW5nZWQgPSBmdW5jdGlvbiAoc3RyVVJMLCBlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW9kZWxzW3N0clVSTF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLl9tb2RlbHNbc3RyVVJMXTtcbiAgICAgICAgbW9kZWwub25FdmVudHMoZSk7XG4gICAgfTtcbiAgICBFZGl0b3JTaW1wbGVXb3JrZXJJbXBsLnByb3RvdHlwZS5hY2NlcHRSZW1vdmVkTW9kZWwgPSBmdW5jdGlvbiAoc3RyVVJMKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW9kZWxzW3N0clVSTF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxzW3N0clVSTF07XG4gICAgfTtcbiAgICByZXR1cm4gRWRpdG9yU2ltcGxlV29ya2VySW1wbDtcbn0oQmFzZUVkaXRvclNpbXBsZVdvcmtlcikpO1xuZXhwb3J0IHsgRWRpdG9yU2ltcGxlV29ya2VySW1wbCB9O1xuLyoqXG4gKiBDYWxsZWQgb24gdGhlIHdvcmtlciBzaWRlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IEVkaXRvclNpbXBsZVdvcmtlckltcGwobnVsbCk7XG59XG5pZiAodHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBSdW5uaW5nIGluIGEgd2ViIHdvcmtlclxuICAgIGdsb2JhbHMubW9uYWNvID0gY3JlYXRlTW9uYWNvQmFzZUFQSSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js ***!
  \**************************************************************************************/
/*! exports provided: Severity, MarkerSeverity, KeyMod, KeyCode, createMonacoBaseAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Severity\", function() { return Severity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkerSeverity\", function() { return MarkerSeverity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyMod\", function() { return KeyMod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyCode\", function() { return KeyCode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createMonacoBaseAPI\", function() { return createMonacoBaseAPI; });\n/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/event.js */ \"./node_modules/monaco-editor/esm/vs/base/common/event.js\");\n/* harmony import */ var _base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/keyCodes.js */ \"./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\");\n/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\");\n/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\");\n/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/selection.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\");\n/* harmony import */ var _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../base/common/winjs.base.js */ \"./node_modules/monaco-editor/esm/vs/base/common/winjs.base.js\");\n/* harmony import */ var _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../base/common/cancellation.js */ \"./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\");\n/* harmony import */ var _core_token_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/token.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/token.js\");\n/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../base/common/uri.js */ \"./node_modules/monaco-editor/esm/vs/base/common/uri.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n// --------------------------------------------\n// This is repeated here so it can be exported\n// because TS inlines const enums\n// --------------------------------------------\nvar Severity;\n(function (Severity) {\n    Severity[Severity[\"Ignore\"] = 0] = \"Ignore\";\n    Severity[Severity[\"Info\"] = 1] = \"Info\";\n    Severity[Severity[\"Warning\"] = 2] = \"Warning\";\n    Severity[Severity[\"Error\"] = 3] = \"Error\";\n})(Severity || (Severity = {}));\nvar MarkerSeverity;\n(function (MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\n// --------------------------------------------\n// This is repeated here so it can be exported\n// because TS inlines const enums\n// --------------------------------------------\nvar KeyMod = /** @class */ (function () {\n    function KeyMod() {\n    }\n    KeyMod.chord = function (firstPart, secondPart) {\n        return Object(_base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_1__[\"KeyChord\"])(firstPart, secondPart);\n    };\n    KeyMod.CtrlCmd = 2048 /* CtrlCmd */;\n    KeyMod.Shift = 1024 /* Shift */;\n    KeyMod.Alt = 512 /* Alt */;\n    KeyMod.WinCtrl = 256 /* WinCtrl */;\n    return KeyMod;\n}());\n\n// --------------------------------------------\n// This is repeated here so it can be exported\n// because TS inlines const enums\n// --------------------------------------------\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nvar KeyCode;\n(function (KeyCode) {\n    /**\n     * Placed first to cover the 0 value of the enum.\n     */\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\n    KeyCode[KeyCode[\"KEY_0\"] = 21] = \"KEY_0\";\n    KeyCode[KeyCode[\"KEY_1\"] = 22] = \"KEY_1\";\n    KeyCode[KeyCode[\"KEY_2\"] = 23] = \"KEY_2\";\n    KeyCode[KeyCode[\"KEY_3\"] = 24] = \"KEY_3\";\n    KeyCode[KeyCode[\"KEY_4\"] = 25] = \"KEY_4\";\n    KeyCode[KeyCode[\"KEY_5\"] = 26] = \"KEY_5\";\n    KeyCode[KeyCode[\"KEY_6\"] = 27] = \"KEY_6\";\n    KeyCode[KeyCode[\"KEY_7\"] = 28] = \"KEY_7\";\n    KeyCode[KeyCode[\"KEY_8\"] = 29] = \"KEY_8\";\n    KeyCode[KeyCode[\"KEY_9\"] = 30] = \"KEY_9\";\n    KeyCode[KeyCode[\"KEY_A\"] = 31] = \"KEY_A\";\n    KeyCode[KeyCode[\"KEY_B\"] = 32] = \"KEY_B\";\n    KeyCode[KeyCode[\"KEY_C\"] = 33] = \"KEY_C\";\n    KeyCode[KeyCode[\"KEY_D\"] = 34] = \"KEY_D\";\n    KeyCode[KeyCode[\"KEY_E\"] = 35] = \"KEY_E\";\n    KeyCode[KeyCode[\"KEY_F\"] = 36] = \"KEY_F\";\n    KeyCode[KeyCode[\"KEY_G\"] = 37] = \"KEY_G\";\n    KeyCode[KeyCode[\"KEY_H\"] = 38] = \"KEY_H\";\n    KeyCode[KeyCode[\"KEY_I\"] = 39] = \"KEY_I\";\n    KeyCode[KeyCode[\"KEY_J\"] = 40] = \"KEY_J\";\n    KeyCode[KeyCode[\"KEY_K\"] = 41] = \"KEY_K\";\n    KeyCode[KeyCode[\"KEY_L\"] = 42] = \"KEY_L\";\n    KeyCode[KeyCode[\"KEY_M\"] = 43] = \"KEY_M\";\n    KeyCode[KeyCode[\"KEY_N\"] = 44] = \"KEY_N\";\n    KeyCode[KeyCode[\"KEY_O\"] = 45] = \"KEY_O\";\n    KeyCode[KeyCode[\"KEY_P\"] = 46] = \"KEY_P\";\n    KeyCode[KeyCode[\"KEY_Q\"] = 47] = \"KEY_Q\";\n    KeyCode[KeyCode[\"KEY_R\"] = 48] = \"KEY_R\";\n    KeyCode[KeyCode[\"KEY_S\"] = 49] = \"KEY_S\";\n    KeyCode[KeyCode[\"KEY_T\"] = 50] = \"KEY_T\";\n    KeyCode[KeyCode[\"KEY_U\"] = 51] = \"KEY_U\";\n    KeyCode[KeyCode[\"KEY_V\"] = 52] = \"KEY_V\";\n    KeyCode[KeyCode[\"KEY_W\"] = 53] = \"KEY_W\";\n    KeyCode[KeyCode[\"KEY_X\"] = 54] = \"KEY_X\";\n    KeyCode[KeyCode[\"KEY_Y\"] = 55] = \"KEY_Y\";\n    KeyCode[KeyCode[\"KEY_Z\"] = 56] = \"KEY_Z\";\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\n    KeyCode[KeyCode[\"NumLock\"] = 78] = \"NumLock\";\n    KeyCode[KeyCode[\"ScrollLock\"] = 79] = \"ScrollLock\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ';:' key\n     */\n    KeyCode[KeyCode[\"US_SEMICOLON\"] = 80] = \"US_SEMICOLON\";\n    /**\n     * For any country/region, the '+' key\n     * For the US standard keyboard, the '=+' key\n     */\n    KeyCode[KeyCode[\"US_EQUAL\"] = 81] = \"US_EQUAL\";\n    /**\n     * For any country/region, the ',' key\n     * For the US standard keyboard, the ',<' key\n     */\n    KeyCode[KeyCode[\"US_COMMA\"] = 82] = \"US_COMMA\";\n    /**\n     * For any country/region, the '-' key\n     * For the US standard keyboard, the '-_' key\n     */\n    KeyCode[KeyCode[\"US_MINUS\"] = 83] = \"US_MINUS\";\n    /**\n     * For any country/region, the '.' key\n     * For the US standard keyboard, the '.>' key\n     */\n    KeyCode[KeyCode[\"US_DOT\"] = 84] = \"US_DOT\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '/?' key\n     */\n    KeyCode[KeyCode[\"US_SLASH\"] = 85] = \"US_SLASH\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '`~' key\n     */\n    KeyCode[KeyCode[\"US_BACKTICK\"] = 86] = \"US_BACKTICK\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '[{' key\n     */\n    KeyCode[KeyCode[\"US_OPEN_SQUARE_BRACKET\"] = 87] = \"US_OPEN_SQUARE_BRACKET\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '\\|' key\n     */\n    KeyCode[KeyCode[\"US_BACKSLASH\"] = 88] = \"US_BACKSLASH\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ']}' key\n     */\n    KeyCode[KeyCode[\"US_CLOSE_SQUARE_BRACKET\"] = 89] = \"US_CLOSE_SQUARE_BRACKET\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ''\"' key\n     */\n    KeyCode[KeyCode[\"US_QUOTE\"] = 90] = \"US_QUOTE\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     */\n    KeyCode[KeyCode[\"OEM_8\"] = 91] = \"OEM_8\";\n    /**\n     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n     */\n    KeyCode[KeyCode[\"OEM_102\"] = 92] = \"OEM_102\";\n    KeyCode[KeyCode[\"NUMPAD_0\"] = 93] = \"NUMPAD_0\";\n    KeyCode[KeyCode[\"NUMPAD_1\"] = 94] = \"NUMPAD_1\";\n    KeyCode[KeyCode[\"NUMPAD_2\"] = 95] = \"NUMPAD_2\";\n    KeyCode[KeyCode[\"NUMPAD_3\"] = 96] = \"NUMPAD_3\";\n    KeyCode[KeyCode[\"NUMPAD_4\"] = 97] = \"NUMPAD_4\";\n    KeyCode[KeyCode[\"NUMPAD_5\"] = 98] = \"NUMPAD_5\";\n    KeyCode[KeyCode[\"NUMPAD_6\"] = 99] = \"NUMPAD_6\";\n    KeyCode[KeyCode[\"NUMPAD_7\"] = 100] = \"NUMPAD_7\";\n    KeyCode[KeyCode[\"NUMPAD_8\"] = 101] = \"NUMPAD_8\";\n    KeyCode[KeyCode[\"NUMPAD_9\"] = 102] = \"NUMPAD_9\";\n    KeyCode[KeyCode[\"NUMPAD_MULTIPLY\"] = 103] = \"NUMPAD_MULTIPLY\";\n    KeyCode[KeyCode[\"NUMPAD_ADD\"] = 104] = \"NUMPAD_ADD\";\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 105] = \"NUMPAD_SEPARATOR\";\n    KeyCode[KeyCode[\"NUMPAD_SUBTRACT\"] = 106] = \"NUMPAD_SUBTRACT\";\n    KeyCode[KeyCode[\"NUMPAD_DECIMAL\"] = 107] = \"NUMPAD_DECIMAL\";\n    KeyCode[KeyCode[\"NUMPAD_DIVIDE\"] = 108] = \"NUMPAD_DIVIDE\";\n    /**\n     * Cover all key codes when IME is processing input.\n     */\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 109] = \"KEY_IN_COMPOSITION\";\n    KeyCode[KeyCode[\"ABNT_C1\"] = 110] = \"ABNT_C1\";\n    KeyCode[KeyCode[\"ABNT_C2\"] = 111] = \"ABNT_C2\";\n    /**\n     * Placed last to cover the length of the enum.\n     * Please do not depend on this value!\n     */\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 112] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {}));\nfunction createMonacoBaseAPI() {\n    return {\n        editor: undefined,\n        languages: undefined,\n        CancellationTokenSource: _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_6__[\"CancellationTokenSource\"],\n        Emitter: _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__[\"Emitter\"],\n        KeyCode: KeyCode,\n        KeyMod: KeyMod,\n        Position: _core_position_js__WEBPACK_IMPORTED_MODULE_2__[\"Position\"],\n        Range: _core_range_js__WEBPACK_IMPORTED_MODULE_3__[\"Range\"],\n        Selection: _core_selection_js__WEBPACK_IMPORTED_MODULE_4__[\"Selection\"],\n        SelectionDirection: _core_selection_js__WEBPACK_IMPORTED_MODULE_4__[\"SelectionDirection\"],\n        Severity: Severity,\n        MarkerSeverity: MarkerSeverity,\n        Promise: _base_common_winjs_base_js__WEBPACK_IMPORTED_MODULE_5__[\"TPromise\"],\n        Uri: _base_common_uri_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n        Token: _core_token_js__WEBPACK_IMPORTED_MODULE_7__[\"Token\"]\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zdGFuZGFsb25lL3N0YW5kYWxvbmVCYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc3RhbmRhbG9uZS9zdGFuZGFsb25lQmFzZS5qcz82ZWFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcbmltcG9ydCB7IEtleUNob3JkIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24va2V5Q29kZXMuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFNlbGVjdGlvbkRpcmVjdGlvbiB9IGZyb20gJy4uL2NvcmUvc2VsZWN0aW9uLmpzJztcbmltcG9ydCB7IFRQcm9taXNlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vd2luanMuYmFzZS5qcyc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJy4uL2NvcmUvdG9rZW4uanMnO1xuaW1wb3J0IFVSSSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoaXMgaXMgcmVwZWF0ZWQgaGVyZSBzbyBpdCBjYW4gYmUgZXhwb3J0ZWRcbi8vIGJlY2F1c2UgVFMgaW5saW5lcyBjb25zdCBlbnVtc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCB2YXIgU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKFNldmVyaXR5KSB7XG4gICAgU2V2ZXJpdHlbU2V2ZXJpdHlbXCJJZ25vcmVcIl0gPSAwXSA9IFwiSWdub3JlXCI7XG4gICAgU2V2ZXJpdHlbU2V2ZXJpdHlbXCJJbmZvXCJdID0gMV0gPSBcIkluZm9cIjtcbiAgICBTZXZlcml0eVtTZXZlcml0eVtcIldhcm5pbmdcIl0gPSAyXSA9IFwiV2FybmluZ1wiO1xuICAgIFNldmVyaXR5W1NldmVyaXR5W1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcbn0pKFNldmVyaXR5IHx8IChTZXZlcml0eSA9IHt9KSk7XG5leHBvcnQgdmFyIE1hcmtlclNldmVyaXR5O1xuKGZ1bmN0aW9uIChNYXJrZXJTZXZlcml0eSkge1xuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiSGludFwiXSA9IDFdID0gXCJIaW50XCI7XG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJJbmZvXCJdID0gMl0gPSBcIkluZm9cIjtcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIldhcm5pbmdcIl0gPSA0XSA9IFwiV2FybmluZ1wiO1xuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiRXJyb3JcIl0gPSA4XSA9IFwiRXJyb3JcIjtcbn0pKE1hcmtlclNldmVyaXR5IHx8IChNYXJrZXJTZXZlcml0eSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhpcyBpcyByZXBlYXRlZCBoZXJlIHNvIGl0IGNhbiBiZSBleHBvcnRlZFxuLy8gYmVjYXVzZSBUUyBpbmxpbmVzIGNvbnN0IGVudW1zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEtleU1vZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLZXlNb2QoKSB7XG4gICAgfVxuICAgIEtleU1vZC5jaG9yZCA9IGZ1bmN0aW9uIChmaXJzdFBhcnQsIHNlY29uZFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XG4gICAgfTtcbiAgICBLZXlNb2QuQ3RybENtZCA9IDIwNDggLyogQ3RybENtZCAqLztcbiAgICBLZXlNb2QuU2hpZnQgPSAxMDI0IC8qIFNoaWZ0ICovO1xuICAgIEtleU1vZC5BbHQgPSA1MTIgLyogQWx0ICovO1xuICAgIEtleU1vZC5XaW5DdHJsID0gMjU2IC8qIFdpbkN0cmwgKi87XG4gICAgcmV0dXJuIEtleU1vZDtcbn0oKSk7XG5leHBvcnQgeyBLZXlNb2QgfTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGlzIGlzIHJlcGVhdGVkIGhlcmUgc28gaXQgY2FuIGJlIGV4cG9ydGVkXG4vLyBiZWNhdXNlIFRTIGlubGluZXMgY29uc3QgZW51bXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFZpcnR1YWwgS2V5IENvZGVzLCB0aGUgdmFsdWUgZG9lcyBub3QgaG9sZCBhbnkgaW5oZXJlbnQgbWVhbmluZy5cbiAqIEluc3BpcmVkIHNvbWV3aGF0IGZyb20gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvZGQzNzU3MzEodj12cy44NSkuYXNweFxuICogQnV0IHRoZXNlIGFyZSBcIm1vcmUgZ2VuZXJhbFwiLCBhcyB0aGV5IHNob3VsZCB3b3JrIGFjcm9zcyBicm93c2VycyAmIE9TYHMuXG4gKi9cbmV4cG9ydCB2YXIgS2V5Q29kZTtcbihmdW5jdGlvbiAoS2V5Q29kZSkge1xuICAgIC8qKlxuICAgICAqIFBsYWNlZCBmaXJzdCB0byBjb3ZlciB0aGUgMCB2YWx1ZSBvZiB0aGUgZW51bS5cbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCYWNrc3BhY2VcIl0gPSAxXSA9IFwiQmFja3NwYWNlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVGFiXCJdID0gMl0gPSBcIlRhYlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVudGVyXCJdID0gM10gPSBcIkVudGVyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2hpZnRcIl0gPSA0XSA9IFwiU2hpZnRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDdHJsXCJdID0gNV0gPSBcIkN0cmxcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBbHRcIl0gPSA2XSA9IFwiQWx0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGF1c2VCcmVha1wiXSA9IDddID0gXCJQYXVzZUJyZWFrXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ2Fwc0xvY2tcIl0gPSA4XSA9IFwiQ2Fwc0xvY2tcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFc2NhcGVcIl0gPSA5XSA9IFwiRXNjYXBlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU3BhY2VcIl0gPSAxMF0gPSBcIlNwYWNlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGFnZVVwXCJdID0gMTFdID0gXCJQYWdlVXBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQYWdlRG93blwiXSA9IDEyXSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFbmRcIl0gPSAxM10gPSBcIkVuZFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkhvbWVcIl0gPSAxNF0gPSBcIkhvbWVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJMZWZ0QXJyb3dcIl0gPSAxNV0gPSBcIkxlZnRBcnJvd1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVwQXJyb3dcIl0gPSAxNl0gPSBcIlVwQXJyb3dcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJSaWdodEFycm93XCJdID0gMTddID0gXCJSaWdodEFycm93XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRG93bkFycm93XCJdID0gMThdID0gXCJEb3duQXJyb3dcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJJbnNlcnRcIl0gPSAxOV0gPSBcIkluc2VydFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRlbGV0ZVwiXSA9IDIwXSA9IFwiRGVsZXRlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzBcIl0gPSAyMV0gPSBcIktFWV8wXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzFcIl0gPSAyMl0gPSBcIktFWV8xXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzJcIl0gPSAyM10gPSBcIktFWV8yXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzNcIl0gPSAyNF0gPSBcIktFWV8zXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzRcIl0gPSAyNV0gPSBcIktFWV80XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzVcIl0gPSAyNl0gPSBcIktFWV81XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzZcIl0gPSAyN10gPSBcIktFWV82XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzdcIl0gPSAyOF0gPSBcIktFWV83XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzhcIl0gPSAyOV0gPSBcIktFWV84XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzlcIl0gPSAzMF0gPSBcIktFWV85XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0FcIl0gPSAzMV0gPSBcIktFWV9BXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0JcIl0gPSAzMl0gPSBcIktFWV9CXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0NcIl0gPSAzM10gPSBcIktFWV9DXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0RcIl0gPSAzNF0gPSBcIktFWV9EXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0VcIl0gPSAzNV0gPSBcIktFWV9FXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0ZcIl0gPSAzNl0gPSBcIktFWV9GXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0dcIl0gPSAzN10gPSBcIktFWV9HXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0hcIl0gPSAzOF0gPSBcIktFWV9IXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0lcIl0gPSAzOV0gPSBcIktFWV9JXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0pcIl0gPSA0MF0gPSBcIktFWV9KXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0tcIl0gPSA0MV0gPSBcIktFWV9LXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0xcIl0gPSA0Ml0gPSBcIktFWV9MXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX01cIl0gPSA0M10gPSBcIktFWV9NXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX05cIl0gPSA0NF0gPSBcIktFWV9OXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX09cIl0gPSA0NV0gPSBcIktFWV9PXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1BcIl0gPSA0Nl0gPSBcIktFWV9QXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1FcIl0gPSA0N10gPSBcIktFWV9RXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1JcIl0gPSA0OF0gPSBcIktFWV9SXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1NcIl0gPSA0OV0gPSBcIktFWV9TXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1RcIl0gPSA1MF0gPSBcIktFWV9UXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1VcIl0gPSA1MV0gPSBcIktFWV9VXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1ZcIl0gPSA1Ml0gPSBcIktFWV9WXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1dcIl0gPSA1M10gPSBcIktFWV9XXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1hcIl0gPSA1NF0gPSBcIktFWV9YXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1lcIl0gPSA1NV0gPSBcIktFWV9ZXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1pcIl0gPSA1Nl0gPSBcIktFWV9aXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWV0YVwiXSA9IDU3XSA9IFwiTWV0YVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNvbnRleHRNZW51XCJdID0gNThdID0gXCJDb250ZXh0TWVudVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxXCJdID0gNTldID0gXCJGMVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyXCJdID0gNjBdID0gXCJGMlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYzXCJdID0gNjFdID0gXCJGM1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY0XCJdID0gNjJdID0gXCJGNFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY1XCJdID0gNjNdID0gXCJGNVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY2XCJdID0gNjRdID0gXCJGNlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY3XCJdID0gNjVdID0gXCJGN1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY4XCJdID0gNjZdID0gXCJGOFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY5XCJdID0gNjddID0gXCJGOVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMFwiXSA9IDY4XSA9IFwiRjEwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjExXCJdID0gNjldID0gXCJGMTFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTJcIl0gPSA3MF0gPSBcIkYxMlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxM1wiXSA9IDcxXSA9IFwiRjEzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE0XCJdID0gNzJdID0gXCJGMTRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTVcIl0gPSA3M10gPSBcIkYxNVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNlwiXSA9IDc0XSA9IFwiRjE2XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE3XCJdID0gNzVdID0gXCJGMTdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMThcIl0gPSA3Nl0gPSBcIkYxOFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxOVwiXSA9IDc3XSA9IFwiRjE5XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtTG9ja1wiXSA9IDc4XSA9IFwiTnVtTG9ja1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNjcm9sbExvY2tcIl0gPSA3OV0gPSBcIlNjcm9sbExvY2tcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnOzonIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX1NFTUlDT0xPTlwiXSA9IDgwXSA9IFwiVVNfU0VNSUNPTE9OXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcrJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJz0rJyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19FUVVBTFwiXSA9IDgxXSA9IFwiVVNfRVFVQUxcIjtcbiAgICAvKipcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJywnIGtleVxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLDwnIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX0NPTU1BXCJdID0gODJdID0gXCJVU19DT01NQVwiO1xuICAgIC8qKlxuICAgICAqIEZvciBhbnkgY291bnRyeS9yZWdpb24sIHRoZSAnLScga2V5XG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICctXycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfTUlOVVNcIl0gPSA4M10gPSBcIlVTX01JTlVTXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcuJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJy4+JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19ET1RcIl0gPSA4NF0gPSBcIlVTX0RPVFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcvPycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfU0xBU0hcIl0gPSA4NV0gPSBcIlVTX1NMQVNIXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ2B+JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19CQUNLVElDS1wiXSA9IDg2XSA9IFwiVVNfQkFDS1RJQ0tcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnW3snIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX09QRU5fU1FVQVJFX0JSQUNLRVRcIl0gPSA4N10gPSBcIlVTX09QRU5fU1FVQVJFX0JSQUNLRVRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnXFx8JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19CQUNLU0xBU0hcIl0gPSA4OF0gPSBcIlVTX0JBQ0tTTEFTSFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICddfScga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfQ0xPU0VfU1FVQVJFX0JSQUNLRVRcIl0gPSA4OV0gPSBcIlVTX0NMT1NFX1NRVUFSRV9CUkFDS0VUXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJydcIicga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfUVVPVEVcIl0gPSA5MF0gPSBcIlVTX1FVT1RFXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJPRU1fOFwiXSA9IDkxXSA9IFwiT0VNXzhcIjtcbiAgICAvKipcbiAgICAgKiBFaXRoZXIgdGhlIGFuZ2xlIGJyYWNrZXQga2V5IG9yIHRoZSBiYWNrc2xhc2gga2V5IG9uIHRoZSBSVCAxMDIta2V5IGtleWJvYXJkLlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk9FTV8xMDJcIl0gPSA5Ml0gPSBcIk9FTV8xMDJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfMFwiXSA9IDkzXSA9IFwiTlVNUEFEXzBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfMVwiXSA9IDk0XSA9IFwiTlVNUEFEXzFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfMlwiXSA9IDk1XSA9IFwiTlVNUEFEXzJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfM1wiXSA9IDk2XSA9IFwiTlVNUEFEXzNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfNFwiXSA9IDk3XSA9IFwiTlVNUEFEXzRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfNVwiXSA9IDk4XSA9IFwiTlVNUEFEXzVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfNlwiXSA9IDk5XSA9IFwiTlVNUEFEXzZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfN1wiXSA9IDEwMF0gPSBcIk5VTVBBRF83XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzhcIl0gPSAxMDFdID0gXCJOVU1QQURfOFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF85XCJdID0gMTAyXSA9IFwiTlVNUEFEXzlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfTVVMVElQTFlcIl0gPSAxMDNdID0gXCJOVU1QQURfTVVMVElQTFlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfQUREXCJdID0gMTA0XSA9IFwiTlVNUEFEX0FERFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9TRVBBUkFUT1JcIl0gPSAxMDVdID0gXCJOVU1QQURfU0VQQVJBVE9SXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX1NVQlRSQUNUXCJdID0gMTA2XSA9IFwiTlVNUEFEX1NVQlRSQUNUXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX0RFQ0lNQUxcIl0gPSAxMDddID0gXCJOVU1QQURfREVDSU1BTFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9ESVZJREVcIl0gPSAxMDhdID0gXCJOVU1QQURfRElWSURFXCI7XG4gICAgLyoqXG4gICAgICogQ292ZXIgYWxsIGtleSBjb2RlcyB3aGVuIElNRSBpcyBwcm9jZXNzaW5nIGlucHV0LlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9JTl9DT01QT1NJVElPTlwiXSA9IDEwOV0gPSBcIktFWV9JTl9DT01QT1NJVElPTlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFCTlRfQzFcIl0gPSAxMTBdID0gXCJBQk5UX0MxXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQUJOVF9DMlwiXSA9IDExMV0gPSBcIkFCTlRfQzJcIjtcbiAgICAvKipcbiAgICAgKiBQbGFjZWQgbGFzdCB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBlbnVtLlxuICAgICAqIFBsZWFzZSBkbyBub3QgZGVwZW5kIG9uIHRoaXMgdmFsdWUhXG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTUFYX1ZBTFVFXCJdID0gMTEyXSA9IFwiTUFYX1ZBTFVFXCI7XG59KShLZXlDb2RlIHx8IChLZXlDb2RlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb25hY29CYXNlQVBJKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVkaXRvcjogdW5kZWZpbmVkLFxuICAgICAgICBsYW5ndWFnZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U6IENhbmNlbGxhdGlvblRva2VuU291cmNlLFxuICAgICAgICBFbWl0dGVyOiBFbWl0dGVyLFxuICAgICAgICBLZXlDb2RlOiBLZXlDb2RlLFxuICAgICAgICBLZXlNb2Q6IEtleU1vZCxcbiAgICAgICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgICAgICBSYW5nZTogUmFuZ2UsXG4gICAgICAgIFNlbGVjdGlvbjogU2VsZWN0aW9uLFxuICAgICAgICBTZWxlY3Rpb25EaXJlY3Rpb246IFNlbGVjdGlvbkRpcmVjdGlvbixcbiAgICAgICAgU2V2ZXJpdHk6IFNldmVyaXR5LFxuICAgICAgICBNYXJrZXJTZXZlcml0eTogTWFya2VyU2V2ZXJpdHksXG4gICAgICAgIFByb21pc2U6IFRQcm9taXNlLFxuICAgICAgICBVcmk6IFVSSSxcbiAgICAgICAgVG9rZW46IFRva2VuXG4gICAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js ***!
  \****************************************************************************************/
/*! exports provided: PrefixSumIndexOfResult, PrefixSumComputer, PrefixSumComputerWithCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrefixSumIndexOfResult\", function() { return PrefixSumIndexOfResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrefixSumComputer\", function() { return PrefixSumComputer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrefixSumComputerWithCache\", function() { return PrefixSumComputerWithCache; });\n/* harmony import */ var _core_uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/uint.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/core/uint.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar PrefixSumIndexOfResult = /** @class */ (function () {\n    function PrefixSumIndexOfResult(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n    }\n    return PrefixSumIndexOfResult;\n}());\n\nvar PrefixSumComputer = /** @class */ (function () {\n    function PrefixSumComputer(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    PrefixSumComputer.prototype.getCount = function () {\n        return this.values.length;\n    };\n    PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {\n        insertIndex = Object(_core_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint32\"])(insertIndex);\n        var oldValues = this.values;\n        var oldPrefixSum = this.prefixSum;\n        var insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    };\n    PrefixSumComputer.prototype.changeValue = function (index, value) {\n        index = Object(_core_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint32\"])(index);\n        value = Object(_core_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint32\"])(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    };\n    PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {\n        startIndex = Object(_core_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint32\"])(startIndex);\n        cnt = Object(_core_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint32\"])(cnt);\n        var oldValues = this.values;\n        var oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        var maxCnt = oldValues.length - startIndex;\n        if (cnt >= maxCnt) {\n            cnt = maxCnt;\n        }\n        if (cnt === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - cnt);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + cnt), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    };\n    PrefixSumComputer.prototype.getTotalValue = function () {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getAccumulatedValue(this.values.length - 1);\n    };\n    PrefixSumComputer.prototype.getAccumulatedValue = function (index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = Object(_core_uint_js__WEBPACK_IMPORTED_MODULE_0__[\"toUint32\"])(index);\n        return this._getAccumulatedValue(index);\n    };\n    PrefixSumComputer.prototype._getAccumulatedValue = function (index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        var startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (var i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    };\n    PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {\n        accumulatedValue = Math.floor(accumulatedValue); //@perf\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalValue();\n        var low = 0;\n        var high = this.values.length - 1;\n        var mid;\n        var midStop;\n        var midStart;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (accumulatedValue < midStart) {\n                high = mid - 1;\n            }\n            else if (accumulatedValue >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\n    };\n    return PrefixSumComputer;\n}());\n\nvar PrefixSumComputerWithCache = /** @class */ (function () {\n    function PrefixSumComputerWithCache(values) {\n        this._cacheAccumulatedValueStart = 0;\n        this._cache = null;\n        this._actual = new PrefixSumComputer(values);\n        this._bustCache();\n    }\n    PrefixSumComputerWithCache.prototype._bustCache = function () {\n        this._cacheAccumulatedValueStart = 0;\n        this._cache = null;\n    };\n    PrefixSumComputerWithCache.prototype.insertValues = function (insertIndex, insertValues) {\n        if (this._actual.insertValues(insertIndex, insertValues)) {\n            this._bustCache();\n        }\n    };\n    PrefixSumComputerWithCache.prototype.changeValue = function (index, value) {\n        if (this._actual.changeValue(index, value)) {\n            this._bustCache();\n        }\n    };\n    PrefixSumComputerWithCache.prototype.removeValues = function (startIndex, cnt) {\n        if (this._actual.removeValues(startIndex, cnt)) {\n            this._bustCache();\n        }\n    };\n    PrefixSumComputerWithCache.prototype.getTotalValue = function () {\n        return this._actual.getTotalValue();\n    };\n    PrefixSumComputerWithCache.prototype.getAccumulatedValue = function (index) {\n        return this._actual.getAccumulatedValue(index);\n    };\n    PrefixSumComputerWithCache.prototype.getIndexOf = function (accumulatedValue) {\n        accumulatedValue = Math.floor(accumulatedValue); //@perf\n        if (this._cache !== null) {\n            var cacheIndex = accumulatedValue - this._cacheAccumulatedValueStart;\n            if (cacheIndex >= 0 && cacheIndex < this._cache.length) {\n                // Cache hit!\n                return this._cache[cacheIndex];\n            }\n        }\n        // Cache miss!\n        return this._actual.getIndexOf(accumulatedValue);\n    };\n    /**\n     * Gives a hint that a lot of requests are about to come in for these accumulated values.\n     */\n    PrefixSumComputerWithCache.prototype.warmUpCache = function (accumulatedValueStart, accumulatedValueEnd) {\n        var newCache = [];\n        for (var accumulatedValue = accumulatedValueStart; accumulatedValue <= accumulatedValueEnd; accumulatedValue++) {\n            newCache[accumulatedValue - accumulatedValueStart] = this.getIndexOf(accumulatedValue);\n        }\n        this._cache = newCache;\n        this._cacheAccumulatedValueStart = accumulatedValueStart;\n    };\n    return PrefixSumComputerWithCache;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi92aWV3TW9kZWwvcHJlZml4U3VtQ29tcHV0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi92aWV3TW9kZWwvcHJlZml4U3VtQ29tcHV0ZXIuanM/MmRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IHRvVWludDMyIH0gZnJvbSAnLi4vY29yZS91aW50LmpzJztcbnZhciBQcmVmaXhTdW1JbmRleE9mUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZWZpeFN1bUluZGV4T2ZSZXN1bHQoaW5kZXgsIHJlbWFpbmRlcikge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gcmVtYWluZGVyO1xuICAgIH1cbiAgICByZXR1cm4gUHJlZml4U3VtSW5kZXhPZlJlc3VsdDtcbn0oKSk7XG5leHBvcnQgeyBQcmVmaXhTdW1JbmRleE9mUmVzdWx0IH07XG52YXIgUHJlZml4U3VtQ29tcHV0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlZml4U3VtQ29tcHV0ZXIodmFsdWVzKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4ID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IC0xO1xuICAgIH1cbiAgICBQcmVmaXhTdW1Db21wdXRlci5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGg7XG4gICAgfTtcbiAgICBQcmVmaXhTdW1Db21wdXRlci5wcm90b3R5cGUuaW5zZXJ0VmFsdWVzID0gZnVuY3Rpb24gKGluc2VydEluZGV4LCBpbnNlcnRWYWx1ZXMpIHtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSB0b1VpbnQzMihpbnNlcnRJbmRleCk7XG4gICAgICAgIHZhciBvbGRWYWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgdmFyIG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xuICAgICAgICB2YXIgaW5zZXJ0VmFsdWVzTGVuID0gaW5zZXJ0VmFsdWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGluc2VydFZhbHVlc0xlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggKyBpbnNlcnRWYWx1ZXNMZW4pO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KDAsIGluc2VydEluZGV4KSwgMCk7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoaW5zZXJ0SW5kZXgpLCBpbnNlcnRJbmRleCArIGluc2VydFZhbHVlc0xlbik7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChpbnNlcnRWYWx1ZXMsIGluc2VydEluZGV4KTtcbiAgICAgICAgaWYgKGluc2VydEluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5zZXJ0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlZml4U3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBQcmVmaXhTdW1Db21wdXRlci5wcm90b3R5cGUuY2hhbmdlVmFsdWUgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gdG9VaW50MzIoaW5kZXgpO1xuICAgICAgICB2YWx1ZSA9IHRvVWludDMyKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzW2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUHJlZml4U3VtQ29tcHV0ZXIucHJvdG90eXBlLnJlbW92ZVZhbHVlcyA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBjbnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRvVWludDMyKHN0YXJ0SW5kZXgpO1xuICAgICAgICBjbnQgPSB0b1VpbnQzMihjbnQpO1xuICAgICAgICB2YXIgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHZhciBvbGRQcmVmaXhTdW0gPSB0aGlzLnByZWZpeFN1bTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gb2xkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhDbnQgPSBvbGRWYWx1ZXMubGVuZ3RoIC0gc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGNudCA+PSBtYXhDbnQpIHtcbiAgICAgICAgICAgIGNudCA9IG1heENudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY250ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkob2xkVmFsdWVzLmxlbmd0aCAtIGNudCk7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgc3RhcnRJbmRleCksIDApO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KHN0YXJ0SW5kZXggKyBjbnQpLCBzdGFydEluZGV4KTtcbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBzdGFydEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID49IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtLnNldChvbGRQcmVmaXhTdW0uc3ViYXJyYXkoMCwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUHJlZml4U3VtQ29tcHV0ZXIucHJvdG90eXBlLmdldFRvdGFsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBY2N1bXVsYXRlZFZhbHVlKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgUHJlZml4U3VtQ29tcHV0ZXIucHJvdG90eXBlLmdldEFjY3VtdWxhdGVkVmFsdWUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB0b1VpbnQzMihpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBY2N1bXVsYXRlZFZhbHVlKGluZGV4KTtcbiAgICB9O1xuICAgIFByZWZpeFN1bUNvbXB1dGVyLnByb3RvdHlwZS5fZ2V0QWNjdW11bGF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPD0gdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXhTdW1baW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdICsgMTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtWzBdID0gdGhpcy52YWx1ZXNbMF07XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtW2ldID0gdGhpcy5wcmVmaXhTdW1baSAtIDFdICsgdGhpcy52YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gTWF0aC5tYXgodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeFN1bVtpbmRleF07XG4gICAgfTtcbiAgICBQcmVmaXhTdW1Db21wdXRlci5wcm90b3R5cGUuZ2V0SW5kZXhPZiA9IGZ1bmN0aW9uIChhY2N1bXVsYXRlZFZhbHVlKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkVmFsdWUgPSBNYXRoLmZsb29yKGFjY3VtdWxhdGVkVmFsdWUpOyAvL0BwZXJmXG4gICAgICAgIC8vIENvbXB1dGUgYWxsIHN1bXMgKHRvIGdldCBhIGZ1bGx5IHZhbGlkIHByZWZpeFN1bSlcbiAgICAgICAgdGhpcy5nZXRUb3RhbFZhbHVlKCk7XG4gICAgICAgIHZhciBsb3cgPSAwO1xuICAgICAgICB2YXIgaGlnaCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBtaWQ7XG4gICAgICAgIHZhciBtaWRTdG9wO1xuICAgICAgICB2YXIgbWlkU3RhcnQ7XG4gICAgICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICAgICAgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSAvIDIpIHwgMDtcbiAgICAgICAgICAgIG1pZFN0b3AgPSB0aGlzLnByZWZpeFN1bVttaWRdO1xuICAgICAgICAgICAgbWlkU3RhcnQgPSBtaWRTdG9wIC0gdGhpcy52YWx1ZXNbbWlkXTtcbiAgICAgICAgICAgIGlmIChhY2N1bXVsYXRlZFZhbHVlIDwgbWlkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY3VtdWxhdGVkVmFsdWUgPj0gbWlkU3RvcCkge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByZWZpeFN1bUluZGV4T2ZSZXN1bHQobWlkLCBhY2N1bXVsYXRlZFZhbHVlIC0gbWlkU3RhcnQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZpeFN1bUNvbXB1dGVyO1xufSgpKTtcbmV4cG9ydCB7IFByZWZpeFN1bUNvbXB1dGVyIH07XG52YXIgUHJlZml4U3VtQ29tcHV0ZXJXaXRoQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlZml4U3VtQ29tcHV0ZXJXaXRoQ2FjaGUodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlQWNjdW11bGF0ZWRWYWx1ZVN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3R1YWwgPSBuZXcgUHJlZml4U3VtQ29tcHV0ZXIodmFsdWVzKTtcbiAgICAgICAgdGhpcy5fYnVzdENhY2hlKCk7XG4gICAgfVxuICAgIFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlLnByb3RvdHlwZS5fYnVzdENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWNoZUFjY3VtdWxhdGVkVmFsdWVTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbnVsbDtcbiAgICB9O1xuICAgIFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlLnByb3RvdHlwZS5pbnNlcnRWYWx1ZXMgPSBmdW5jdGlvbiAoaW5zZXJ0SW5kZXgsIGluc2VydFZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5fYWN0dWFsLmluc2VydFZhbHVlcyhpbnNlcnRJbmRleCwgaW5zZXJ0VmFsdWVzKSkge1xuICAgICAgICAgICAgdGhpcy5fYnVzdENhY2hlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlLnByb3RvdHlwZS5jaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbC5jaGFuZ2VWYWx1ZShpbmRleCwgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9idXN0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJlZml4U3VtQ29tcHV0ZXJXaXRoQ2FjaGUucHJvdG90eXBlLnJlbW92ZVZhbHVlcyA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBjbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbC5yZW1vdmVWYWx1ZXMoc3RhcnRJbmRleCwgY250KSkge1xuICAgICAgICAgICAgdGhpcy5fYnVzdENhY2hlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlLnByb3RvdHlwZS5nZXRUb3RhbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsLmdldFRvdGFsVmFsdWUoKTtcbiAgICB9O1xuICAgIFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlLnByb3RvdHlwZS5nZXRBY2N1bXVsYXRlZFZhbHVlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWwuZ2V0QWNjdW11bGF0ZWRWYWx1ZShpbmRleCk7XG4gICAgfTtcbiAgICBQcmVmaXhTdW1Db21wdXRlcldpdGhDYWNoZS5wcm90b3R5cGUuZ2V0SW5kZXhPZiA9IGZ1bmN0aW9uIChhY2N1bXVsYXRlZFZhbHVlKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkVmFsdWUgPSBNYXRoLmZsb29yKGFjY3VtdWxhdGVkVmFsdWUpOyAvL0BwZXJmXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlSW5kZXggPSBhY2N1bXVsYXRlZFZhbHVlIC0gdGhpcy5fY2FjaGVBY2N1bXVsYXRlZFZhbHVlU3RhcnQ7XG4gICAgICAgICAgICBpZiAoY2FjaGVJbmRleCA+PSAwICYmIGNhY2hlSW5kZXggPCB0aGlzLl9jYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSBoaXQhXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2NhY2hlSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhY2hlIG1pc3MhXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWwuZ2V0SW5kZXhPZihhY2N1bXVsYXRlZFZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVzIGEgaGludCB0aGF0IGEgbG90IG9mIHJlcXVlc3RzIGFyZSBhYm91dCB0byBjb21lIGluIGZvciB0aGVzZSBhY2N1bXVsYXRlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgUHJlZml4U3VtQ29tcHV0ZXJXaXRoQ2FjaGUucHJvdG90eXBlLndhcm1VcENhY2hlID0gZnVuY3Rpb24gKGFjY3VtdWxhdGVkVmFsdWVTdGFydCwgYWNjdW11bGF0ZWRWYWx1ZUVuZCkge1xuICAgICAgICB2YXIgbmV3Q2FjaGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYWNjdW11bGF0ZWRWYWx1ZSA9IGFjY3VtdWxhdGVkVmFsdWVTdGFydDsgYWNjdW11bGF0ZWRWYWx1ZSA8PSBhY2N1bXVsYXRlZFZhbHVlRW5kOyBhY2N1bXVsYXRlZFZhbHVlKyspIHtcbiAgICAgICAgICAgIG5ld0NhY2hlW2FjY3VtdWxhdGVkVmFsdWUgLSBhY2N1bXVsYXRlZFZhbHVlU3RhcnRdID0gdGhpcy5nZXRJbmRleE9mKGFjY3VtdWxhdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3Q2FjaGU7XG4gICAgICAgIHRoaXMuX2NhY2hlQWNjdW11bGF0ZWRWYWx1ZVN0YXJ0ID0gYWNjdW11bGF0ZWRWYWx1ZVN0YXJ0O1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlO1xufSgpKTtcbmV4cG9ydCB7IFByZWZpeFN1bUNvbXB1dGVyV2l0aENhY2hlIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js\n");

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/editor.worker.js":
/*!*******************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/editor.worker.js ***!
  \*******************************************************************/
/*! exports provided: initialize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialize\", function() { return initialize; });\n/* harmony import */ var _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/services/editorSimpleWorker.js */ \"./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\");\n/* harmony import */ var _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/common/worker/simpleWorker.js */ \"./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nvar initialized = false;\nfunction initialize(foreignModule) {\n    if (initialized) {\n        return;\n    }\n    initialized = true;\n    var editorWorker = new _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_0__[\"EditorSimpleWorkerImpl\"](foreignModule);\n    var simpleWorker = new _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_1__[\"SimpleWorkerServer\"](function (msg) {\n        self.postMessage(msg);\n    }, editorWorker);\n    self.onmessage = function (e) {\n        simpleWorker.onmessage(e.data);\n    };\n}\nself.onmessage = function (e) {\n    // Ignore first message in this case and initialize if not yet initialized\n    if (!initialized) {\n        initialize(null);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2VkaXRvci53b3JrZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2VkaXRvci53b3JrZXIuanM/ZTUwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEVkaXRvclNpbXBsZVdvcmtlckltcGwgfSBmcm9tICcuL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMnO1xuaW1wb3J0IHsgU2ltcGxlV29ya2VyU2VydmVyIH0gZnJvbSAnLi4vYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlci5qcyc7XG52YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKGZvcmVpZ25Nb2R1bGUpIHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgdmFyIGVkaXRvcldvcmtlciA9IG5ldyBFZGl0b3JTaW1wbGVXb3JrZXJJbXBsKGZvcmVpZ25Nb2R1bGUpO1xuICAgIHZhciBzaW1wbGVXb3JrZXIgPSBuZXcgU2ltcGxlV29ya2VyU2VydmVyKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH0sIGVkaXRvcldvcmtlcik7XG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzaW1wbGVXb3JrZXIub25tZXNzYWdlKGUuZGF0YSk7XG4gICAgfTtcbn1cbnNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAvLyBJZ25vcmUgZmlyc3QgbWVzc2FnZSBpbiB0aGlzIGNhc2UgYW5kIGluaXRpYWxpemUgaWYgbm90IHlldCBpbml0aWFsaXplZFxuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZShudWxsKTtcbiAgICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/monaco-editor/esm/vs/editor/editor.worker.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ })

/******/ });